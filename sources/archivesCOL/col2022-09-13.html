<!DOCTYPE html>
<html lang="en">


<head>
	<title>CadsolOnLine 3D</title>
	<link rel="icon" type="image/x-icon" href="./favicon.ico">
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0">
	<link type="text/css" rel="stylesheet" href="./main2022-07-19.css">
</head>

<body>
	
	<div id="container">
	  <div id="info">
		<h1>CadsolOnLine</h1>
		<div id="ver">" " </div>
		 Help: <a href="https://cadsolonline.web-pages.fr" target="_blank">cadsolonline.web-pages.fr </a></br>

		3D library: <a href="https://threejs.org" target="_blank" rel="noopener">Three.js</a> </br>

		Astronomical library:
		<a href="https://en.wikipedia.org/wiki/Jean_Meeus" target="_blank" rel="noopener">Jean Meeus</a> </br>
		<!--  <a href="https://en.wikipedia.org/wiki/Sonia_Keys" target="_blank" rel="noopener">Sonia Keys</a> & 
        <a href="https://github.com/commenthol/astronomia" target="_blank" rel="noopener">commenthol</a></br>
	    <a     https://articles.adsabs.harvard.edu//full/2000JRASC..94...95C/0000103.000.html     Dominique Collin-->
		<p>
		<img src="./imageMoret.jpg" alt="Image" style="max-width:100%;height:auto">
		</p>
		
		<label for="jsoninput"> Open the Sundial ... </label>
	    </br></br>

		<div id="menu">  </div>
		<input type="file" id="jsoninput" accept=".json">
	

		<script>
			const docinputjson = document.getElementById('jsoninput');
			docinputjson.style.opacity = 0;
		</script>

	  </div>
	
	<!-- <input type="range" min="1" max="100" value="50" class="slider" id="myRange">  -->
	<div id="time"> </div>

	</div>

	<!-- <div id="deceqt"> </div> -->
	
	<script type="module">


		import * as THREE from '../build/three.module.js';  //144dev
			import Stats from './jsm/libs/stats.module.js';
		//	import { GUI } from './jsm/libs/dat.gui.module.js';
			import { GUI } from './jsm/libs/lil-gui.module.min.js';
	   		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		    import {apparentEquatorial} from '../astronomia-master/src/solar.js';
		    import * as JULIAN from '../astronomia-master/src/julian.js';		
		    import * as base from '../astronomia-master/src/base.js';					
            import * as EQTIME from '../astronomia-master/src/eqtime.js';	
            import * as SEXA from '../astronomia-master/src/sexagesimal.js';

            import { FontLoader } from './jsm/loaders/FontLoader.js';
			import { TextGeometry } from './jsm/geometries/TextGeometry.js';
			import * as BUFGEOUTILS from  './jsm/utils/BufferGeometryUtils.js';
            import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';
			//import { DDSLoader } from './jsm/loaders/DDSLoader.js';
			import { PLYExporter } from './jsm/exporters/PLYExporter.js';
			//import { GLTFExporter } from './jsm/exporters/GLTFExporter.js';
			import { OBJExporter } from './jsm/exporters/OBJExporter.js';
			import { STLExporter } from './jsm/exporters/STLExporter.js';
			//import POLYHEDRA from "./polyhedra.js";


            document.getElementById("jsoninput").addEventListener('change', function() {loadJsonFile() });
	
			const SP="Polar or straight style", BF="Bifilar (vertical)",BFG='Bifilar generalised';

			const HS="solar",HLSA="legal (summer autumn)", HLWS="legal (winter spring)",HA="Antique";
			const HB='babylonic',HI="italic",
			   HSDSA="Sidereals (summer, autumn)",
			   HSDWS="Sidereals (winter, spring)";     

			let  cs ={    version:"2022-09-13", 
						  hsol:13.5,
				          dayofYear:105,
						  year:2022,
						 
						  //geometry 
						  typeCadran:SP,			        
					      largeur:600,
				          hauteur:400,
				          epaisseur:30,
				          decli:0,
				          incli:90,
				          rot:0,

				          hgnomon:50,
				          egnomon:1,
				          xgnomon:0,				         
				          ygnomon:100, 
				          vgnomon:true,
				          vstyle:true,
				          vsousstyle:true,
						  angleStyleSousstylaire:0,
						  xPole:0,
						  yPole:0,

						  hfilHorizontal:30,
						  hfilVertical:50,
						  anglefilHorizontal:0,
						  anglefilVertical:90,
						  
								hA1:30,xA1:-300,yA1:100, //support1 du fil A
								hA2:30,xA2: 300,yA2:100, //support2 du fil A
								hB1:50,xB1:0,yB1:-200,  //support1 du fil B	
								hB2:50,xB2:0,yB2: 200,  //support2 du fil B
							   
						//colors sundial
						  colorCS: "rgb(200,200,200)",
				          emissiveCS:"rgb(100,100,100)",
				          specularCS:"rgb(0,0,0)",
						  metalness:0.5,
				          opaciteCS:0.8,
						  //texture:'acier',
				          
						 //geolocation
						  lati:43.6,
				          longi:3.9,
				          adresse:"",
				          urlOpenStreet:"",
				          timezone:"",
				          offset_sec:0,
				          offset_string:"",
				          now_in_dst:0,
				          dst:0,
						  autoLocation:false,

						 // hours
				          heuresSolaires:true,
						  heuresLegalesSummerAutums:false,
						  heuresLegalesWinterSpring:false,
						  heuresAntiques:false,
						  heuresBabyloniques:false,
						  heuresItaliques:false,
						  heuresSideralesWS:false,
						  heuresSideralesSA:false,
						  colorHS:"rgb(200,0,0)",
						  colorHLSummerAutums:"rgb(0,200,5)",
						  colorHLWinterSpring:"rgb(0,0,200)",
						  colorHeuresAntiques:"rgb(200,0,200)",
						  colorHeuresBabyloniques:"rgb(0,150,200)",
						  colorHeuresItaliques:"rgb(0,150,100)",
						  colorHeuresSDSA:"rgb(100,100,10)",
						  colorHeuresSDWS:"rgb(102,16,10)",
						  textSizeHS:1,
						  textSizeSA:1,
						  textSizeWS:1,
						  textSizeHA:1,
						  textSizeHB:1,
						  textSizeHI:1,
						  textSizeSDSA:1,
						  textSizeSDWS:1,
						  hoursTextSize:1,
						  subDivisions:1,
						  precisionHours:5,   // un point tous les 5 jours, tous les jours au voisinage des solstices 

						  //arcs diurnes
						  equinoxeAndSolstices:false,
						  colorequinoxeAndSolstice:"rgb(152,0,0)",
						  datesArcsDiurnes:[],  // [[date, dec en rad]]  tableau Ã  deux dimensions
				          precisionArcs:15,   // un point toutes les 15 minutes

						  //display
						  devise:"Carpe Diem",
						  deviseSize:1,				          
				          axesESZ:true,
				          voirTerre:true,
				          vrotscene:0,					      
						  vrotSun:0,
						  //backgroundColor
						  background:"rgb(22,35,39)",
						  //export
						  unitSVG:'auto',
						  nameFile:"mySundial",						 
				          export:"Sundial(JSON)"
				          };

						  let  TS=TableSol(cs.year);
            
				let container, stats,buttonNewSundial;
				let camera, scene, renderer;   
		        container = document.getElementById( 'container' );
                
				// camera

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 5, 10000 );
				camera.position.set( 2000, 2000, 2000 );
				//camera.position.set( 0, 0, 2000 );

				// scene
                scene = new THREE.Scene();
				scene.background = new THREE.Color( cs.background );
				//scene.fog = new THREE.Fog( 0xaaaaaa, 10, 10000 );
				// light

				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1, 1 ).normalize();
				
				const ambientLight = new THREE.AmbientLight( 0x303030 ); // soft white light
				//const ambientLight = new THREE.LightProbe(); 
        		scene.add( ambientLight );

				//Set up shadow properties for the light
				light.shadow.mapSize.width = 2048*4; // default
				light.shadow.mapSize.height =2048*4; // default
				light.shadow.camera.near = -1000; // default
				light.shadow.camera.far = 1000; // default
				light.shadow.camera.top = 1000;
				light.shadow.camera.bottom = -1000;
				light.shadow.camera.right = 1000;
				light.shadow.camera.left = -1000;
				

				light.castShadow = true; // default false
				scene.add( light );
				//const helperLight = new THREE.DirectionalLightHelper( light, 100 );
				//scene.add( helperLight );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
				//renderer.toneMapping=THREE.CineonToneMapping;
				container.appendChild( renderer.domElement );

		    	// renderer.setPixelRatio( window.devicePixelRatio );
			    // renderer.outputEncoding = THREE.sRGBEncoding;
			
				// stats
				stats = new Stats();
				container.appendChild( stats.dom );

                // OrbitControls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10000;

				//addEventListener
				window.addEventListener( 'resize', onWindowResize );
				controls.addEventListener( 'change', render );
				
				//Button New Sundial
				buttonNewSundial = document.createElement( 'button' );
			    buttonNewSundial.innerHTML ='New Sundial';
			    const menu = document.getElementById( 'menu' );
			    menu.appendChild( buttonNewSundial );
				buttonNewSundial.addEventListener("click", function() { run() });

				
				//
			    const labeltime = document.getElementById( 'time' );			
                labeltime.innerHTML = 'Time';
				// const labeldeceqt = document.getElementById( 'deceqt' );
                // labeldeceqt.innerHTML = 'deceqt';
	
				const version = document.getElementById('ver');
				version.innerHTML="Version: "+cs.version

			let cadran,gnomon,meshDevise,stylePolaire,sousStylaire,filHorizontal,filVertical,pilierH1,pilierH2,pilierH3,pilierH4 ;
			let cadranSolaireGroup,axeMondeGroup, earthGroup;
			let heuresSolairesGroup,heuresLegalesGroupSA,heuresLegalesGroupWS,heuresAntiquesGroup,arcsDiurnesGroup;
			let heuresBabyloniquesGroup,heuresItaliquesGroup,heuresSDSAgroup,heuresSDWSgroup;
			let heuresSolairesListeMesh,heuresLegalesListeMeshSA,heuresLegalesListeMeshWS,heuresAntiquesListeMesh,
		    	heuresBabyloniquesListeMesh,
				heuresItaliquesListeMesh,
				heuresSDSAListeMesh,heuresSDWSListeMesh,
			    arcsDiurnesListeMesh;
			let angleStylePlan
			let CSVtext='',SVGtext='',CSVephemerid='';
			const separateurCSV =";"
			      
                  
 // width="$(cs.largeur.toString())mm" height="$(cd.hauteur.toString())mm"

		

                cadranSolaireGroup = new THREE.Group();

                heuresSolairesGroup=new THREE.Group();
				heuresLegalesGroupSA=new THREE.Group();
				heuresLegalesGroupWS=new THREE.Group();
				heuresAntiquesGroup=new THREE.Group();
				heuresBabyloniquesGroup=new THREE.Group();
				heuresItaliquesGroup=new THREE.Group();
				heuresSDSAgroup=new THREE.Group();
				heuresSDWSgroup=new THREE.Group();
				arcsDiurnesGroup=new THREE.Group();

				heuresSolairesListeMesh=[];
                heuresLegalesListeMeshSA=[];
				heuresLegalesListeMeshWS=[];
				heuresAntiquesListeMesh=[];
				heuresBabyloniquesListeMesh=[];
				heuresItaliquesListeMesh=[];
				heuresSDSAListeMesh=[];
				heuresSDWSListeMesh=[];

				arcsDiurnesListeMesh=[];

			    //const texture = new THREE.TextureLoader().load( 'metaltexture.jpg' );
			   // const materialCST = new THREE.MeshBasicMaterial( { map: texture } );
			   const textureAcier = new THREE.TextureLoader().load( 'metaltexture.jpg' )
			   const textureCuivre = new THREE.TextureLoader().load( 'metall001-new-tileable.png' );
			   const textureFruits = new THREE.TextureLoader().load( 'fruits.jpg');
			   const textureAsphalt = new THREE.TextureLoader().load( 'asphalt.jpg');
               let texture=textureAcier
				const optionsMaterial={roughness:0.5,metalness:0.5,transparent:true,opacity:1,side:THREE.DoubleSide,map: texture}
                const materialHeuresSolaires  = new THREE.MeshStandardMaterial(optionsMaterial);
				const materialHeuresLegalesSA = new THREE.MeshStandardMaterial(optionsMaterial);
				const materialHeuresLegalesWS = new THREE.MeshStandardMaterial(optionsMaterial);
				const materialHeuresAntiques  = new THREE.MeshStandardMaterial(optionsMaterial);
				const materialHeuresBabyloniques  = new THREE.MeshStandardMaterial(optionsMaterial);
				const materialHeuresItaliques  = new THREE.MeshStandardMaterial(optionsMaterial);
				const materialHeuresSDSA  = new THREE.MeshStandardMaterial(optionsMaterial);
				const materialHeuresSDWS  = new THREE.MeshStandardMaterial(optionsMaterial);

				const materialArcsDiurnes     = new THREE.MeshStandardMaterial(optionsMaterial);				
				
                const materialGnomon          = new THREE.MeshStandardMaterial( 
					{transparent:true,opacity:1,roughness:0.1,metalness:0.5,side:THREE.DoubleSide,color: 0xffffff,map: textureAcier} );
                const materialCS = new THREE.MeshStandardMaterial(
					{transparent:true,opacity:0.8,roughness:0.5,map:textureAcier}); 

				 //  const geometryGnomon = new THREE.CapsuleGeometry( 1, 1, 4, 8 );
				 const geometryGnomon = new THREE.CylinderGeometry( 1, 1, 1, 16 );    
			     gnomon = new THREE.Mesh( geometryGnomon, materialGnomon );      
				// const geometryboutGnomon= new THREE.SphereGeometry( 1, 32, 32 );   
				// const boutGnomon=new THREE.Mesh( geometryboutGnomon, materialGnomon );
				// gnomon.add(boutGnomon)
				// boutGnomon.visible=true
                //materialCS.depthWrite=false; 
				//materialHeuresSolaires.tramage=true; 
                //materialHeuresSolaires.precision="highp"
               				
				// Axe de rotation de la terre
                   const axeMonde = new THREE.ArrowHelper(
							new THREE.Vector3( 0, Math.sin(cs.lati*Math.PI/180), -Math.cos(cs.lati*Math.PI/180)),
							new THREE.Vector3( 0, 0, 0 ), 
							Math.max(cs.largeur,cs.hauteur,cs.epaisseur), 
							0xffff00,30,15 );
						
               
               axeMondeGroup = new THREE.Group(); 
               axeMondeGroup.add(axeMonde);              			   	   
			   axeMonde.visible=false;
			  
                const textureLoader = new THREE.TextureLoader();

			    const earthGeometry = new THREE.SphereGeometry( 1, 32, 32 );
				const earthMaterial = new THREE.MeshPhongMaterial( {
					specular: 0x333333,
					emissive:"rgb(5,5,5)",
					shininess: 5,
				    map: textureLoader.load( './earth_pm_2048.jpg' ),
					specularMap: textureLoader.load( 'textures/planets/earth_specular_2048.jpg' ),
					normalMap: textureLoader.load( 'textures/planets/earth_normal_2048.jpg' ),
					normalScale: new THREE.Vector2( 1,1 )					
			  	    } );
				earthMaterial.tranparent=true;
				earthMaterial.opacity=0.5;
				const sphereEarth = new THREE.Mesh( earthGeometry, earthMaterial );
				earthGroup = new THREE.Group();  
			    earthGroup.add(sphereEarth);


		        const geometrySun = new THREE.SphereGeometry( 15, 32, 16 );
			    const materialSun = new THREE.MeshPhongMaterial( { 
					                        //color: 0xffff00, 
											//specular: 0x333333,
											emissive:"rgb(100,100,5)",
											shininess: 5,
				                            map: textureLoader.load( './sun.jpg' ) } );
			    const sphereSun = new THREE.Mesh( geometrySun, materialSun );
				axeMondeGroup.add( sphereSun );
                sphereSun.parent=axeMonde;


			    const axeTerre = new THREE.ArrowHelper(
				   new THREE.Vector3( 1,1,1),
                   new THREE.Vector3( 0,0, 0 ), 
                   Math.max(cs.largeur,cs.hauteur,cs.epaisseur), 
                   0xffffff,30,15 );
                earthGroup.add(axeTerre);  

			
			   const axeLocalisation = new THREE.ArrowHelper(
                   new THREE.Vector3( 0, -1,0),
                   new THREE.Vector3( 0, 0, 0 ), 
                   Math.max(cs.largeur,cs.hauteur,cs.epaisseur), 
                   0x00ff00,30,15 );
    
			
               
			
			   
			   

               

			   let fontDevise;
			   loadFontDevise();

			  // getLocation();

			  

//-----------------------------------------------------------------------------------------------------				          
function run() {	        
	           
			   init();	
		   
			   animate(); 
		   
   }

//-------------------------------------------------------------------------------------------------
function initCSVtext(){
	CSVtext="CadsolOnLine      "+separateurCSV+"x"+separateurCSV+"y"+"\n\n";
    CSVtext +=" Version:"+cs.version+"\n\n";	
}

function initSVGtext(unit){
SVGtext=
`<?xml version="1.0" standalone="no"?>
<svg 
` 
if (unit=="auto") {SVGtext+=`width="100%" height="auto"`} 
  else{SVGtext+=`width="${cs.largeur.toString()+unit}" height="${cs.hauteur.toString()+unit}"`}

SVGtext+=` viewBox="0 0 ${cs.largeur.toString()} ${cs.hauteur.toString()}" preserveAspectRatio="xMinYMin meet"
  xmlns="http://www.w3.org/2000/svg">

  <desc> 

  CadsolOnLine  ${cs.version}
  
  </desc>

  <rect x="0" y="0" width="${cs.largeur.toString()}" height="${cs.hauteur.toString()}" 
   fill="${cs.colorCS}" stroke="black" stroke-width="1px" />
 
  
`	
      
// <rect x="0" y="0" width="${cs.largeur.toString()}" height="${cs.hauteur.toString()}"
//         fill="none" stroke="black" stroke-width="1"/>
//   width="${cs.largeur.toString()+cs.unitSVG}" height="${cs.hauteur.toString()+cs.unitSVG}"
//height="auto"
}	

function closeSVGtext(){SVGtext +='</svg>';
                      // console.log(SVGtext)
					   }

//----------------------------------------------------------------------------------------------------
			   
function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showPosition);
  } else { 
    alert("Geolocation is not supported by this browser.") ;
  }
}

function showPosition(position) {
  cs.lati = position.coords.latitude ; 
  cs.longi= position.coords.longitude;
}
//----------------------------------------------------------------------------
function loadFontDevise() {
    const loader = new FontLoader();
    loader.load( './fonts/helvetiker_regular.typeface.json', function ( response ) {
                 fontDevise = response } );
	}

// Ecritures------------------------------------------------------------  
function EcrireDevise(texte,x,y){

  const fontGeometry = new TextGeometry( texte, {
		   font: fontDevise,
		   size:10*cs.deviseSize,             //ajuster sur largeur
		   height: 2*cs.deviseSize,           //ajuster sur largeur
		   curveSegments: 4,
		   bevelEnabled: true,
		   bevelThickness: 0.5*cs.deviseSize, //ajuster sur largeur
		   bevelSize: 0.5*cs.deviseSize,      //ajuster sur largeur
		   bevelOffset: 0,
		   bevelSegments: 1
	   } );
if (cs.deviseSize==0) return;
meshDevise=new THREE.Mesh( fontGeometry, materialGnomon);
cadranSolaireGroup.add(meshDevise);
meshDevise.position.x = x;
meshDevise.position.y = y;
meshDevise.position.z = cs.epaisseur/2

if (SVGtext.length>0) {
 x=x+cs.largeur/2;y=-y+cs.hauteur/2;
 SVGtext +=`<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.deviseSize*12).toString()}" font-family="Verdana" > ${cs.devise}</text>
           `
}
} 

function EcrireTexte(texte,x,y,material,group,listeMesh){
if (cs.hoursTextSize==0) return;

let mesh
const fontGeometry = new TextGeometry( texte, {
			font: fontDevise,
			size:7*cs.hoursTextSize,             //ajuster sur largeur
			height: 1*cs.hoursTextSize,           //ajuster sur largeur
			curveSegments: 4,
			bevelEnabled: true,
			bevelThickness: 0.5*cs.hoursTextSize, //ajuster sur largeur
			bevelSize: 0.5*cs.hoursTextSize,      //ajuster sur largeur
			bevelOffset: 0,
			bevelSegments: 1
		} );
 mesh=new THREE.Mesh( fontGeometry, material);
 
 group.add(mesh);
 if (listeMesh){listeMesh.push(mesh)};
 //if (x>0){x-=10*cs.hoursTextSize}else{x+=2*cs.hoursTextSize}
 if ((x+7*cs.hoursTextSize)>(cs.largeur/2-5)){x-=14*cs.hoursTextSize}
 mesh.position.x = x;
 //if (y>0){y-=10*cs.hoursTextSize}else{y+=2*cs.hoursTextSize}
 if ((y+7*cs.hoursTextSize)>(cs.hauteur/2-5)){y-=14*cs.hoursTextSize}
 mesh.position.y = y;
 mesh.position.z = cs.epaisseur/2;

 if (SVGtext.length>0) {
 x=x+cs.largeur/2;y=-y+cs.hauteur/2;
 SVGtext +=`<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.hoursTextSize*12).toString()}" font-family="Verdana" stroke="${material.color.getStyle()}"> ${texte}</text>
           `
}

}


//TableSol------------------------
function TableSol(year) {
  let jde,ae,dec,eqt,jdes,eqts,decs;
  let decSunMin=0,decSunMax=0,jdecSunMin=0,jdecSunMax=0,j=0;
  jdes=[];eqts=[];decs=[]
  jde= JULIAN.CalendarGregorianToJD(year, 1, 1.5);  //Premier Janvier Ã  12h
  while (jde<=JULIAN.CalendarGregorianToJD(year, 12, 31.5))//31 decembre Ã  12h
    { 
    ae=apparentEquatorial(jde);
    dec=ae.dec;
	if (dec>decSunMax){decSunMax=dec;jdecSunMax=j};
	if (dec<decSunMin){decSunMin=dec;jdecSunMin=j};
    eqt=EQTIME.eSmart(jde);
    jdes.push(jde);eqts.push(eqt);decs.push(dec)
    jde+=1;j+=1
	 };
 // console.log(jdecSunMin,jdecSunMax);
  return {//Tableaux Ã  365 ou 366 elements, valeurs calculÃ©es Ã  12h, index: 0...364 ou 0...365
	      decSuns:decs,  //radians
          eqtimes:eqts,  //equation of time as an hour angle in radians.
          jdates:jdes,    //jourjulien
		  //jours des solstices
		  jdecSunMin,
		  jdecSunMax
          }             

}

//-----------------------------------------------------------------------------------------------------
function Ephemerid(year) {
    let d,s;
	
	CSVephemerid  = " DATE"+separateurCSV+"TIME EQUATION (s)"+separateurCSV+"SUN DECLINATION (Â°)"+separateurCSV+"Julian Day"+"\n"
	CSVephemerid +=" \n";
	CSVephemerid +="Ephemerids year:  "+cs.year+"\n\n";
	CSVephemerid +="CadsolOnLine  Version:"+cs.version+"\n\n";
	CSVephemerid +="(c) Jean Meeus \n* Chapter 28 Equation of time \n* Chapter 25  Solar Coordinates ...\n\n";
	CSVephemerid +=" \n";
 //   const TS=TableSol(cs.year);
	for (let i = 0; i < TS.decSuns.length; i++) {
		d=JULIAN.JDToCalendarGregorian(TS.jdates[i]);
		CSVephemerid +=d.day+"/"+d.month+"/"+d.year	+separateurCSV;  //date JJ/MM/YYYY
		s=Math.round(SEXA.secFromHourAngle(TS.eqtimes[i]));	// equation du temps en secondes	
		CSVephemerid +=s.toFixed(0)+'     '+separateurCSV;
		s=base.toDeg(TS.decSuns[i]);  //dec soleil en degres
		CSVephemerid +=s.toFixed(4);
		if (i==TS.jdecSunMin){CSVephemerid += "  Winter Solstice "}
		if (i==TS.jdecSunMax){CSVephemerid += "  Summer Solstice "}
		CSVephemerid +=separateurCSV
		CSVephemerid +=TS.jdates[i];
		CSVephemerid +="\n"
	}	
	//console.log(CSVephemerid)
   }

//------------------------------------------------------------------------------------------------------------
function TracerHeuresEtArcs(){
   initCSVtext()
   if (cs.heuresSolaires) {TracerHeuresSolaires()}
   if (cs.heuresLegalesWinterSpring){TracerHeuresLegalesWS()}
   if (cs.heuresLegalesSummerAutums){TracerHeuresLegalesSA()}
   if (cs.heuresAntiques){TracerHeuresAntiques()}
   if (cs.heuresBabyloniques){TracerHeuresBabyloniques()}
   if (cs.heuresItaliques){TracerHeuresItaliques()}
   if (cs.heuresSideralesSA){TracerHeuresSDSA()}
   if (cs.heuresSideralesWS){TracerHeuresSDWS()}
   TracerArcsDiurnes()
   TracerStyle()
}
// --------------------------------------------------------------------------------------------------------
function pointDansCadran(x,y)
{
	return ((Math.abs(x)<=(cs.largeur/2))&&(Math.abs(y)<=(cs.hauteur/2))) 
}
//---------------------------------------------------------------------------------------------------------
let g1,g2,k1,k2;
function calculg1g2k1k2(){
	
	const a=cs.hfilHorizontal
	const b=cs.hfilVertical
	const e=b-a
	const[sinj1,cosj1]=base.sincos(base.toRad(cs.anglefilHorizontal))
	const[sinj2,cosj2]=base.sincos(base.toRad(cs.anglefilVertical))
	const sinj1mj2=Math.sin(base.toRad(cs.anglefilHorizontal-cs.anglefilVertical))
	g1=(b*sinj2*cosj1-a*sinj1*cosj2)/sinj1mj2
	g2=(b*sinj1*cosj2-a*sinj2*cosj1)/sinj1mj2
	k1=e*cosj1*cosj2/sinj1mj2
	k2=e*sinj1*sinj2/sinj1mj2
}

function ligneSVG(xg,yg,xp,yp){if (SVGtext.length>0){
	xg=xg+cs.largeur/2;yg=-yg+cs.hauteur/2
	xp=xp+cs.largeur/2;yp=-yp+cs.hauteur/2
	SVGtext+=`
			<line x1="${xg.toFixed(3)}" y1="${yg.toFixed(3)}" x2="${xp.toFixed(3)}" y2="${yp.toFixed(3)}"
			stroke="black" stroke-width="1"/>
			`}}

function croixSVG(x,y){
	ligneSVG(x-3,y-3,x+3,y+3)
	ligneSVG(x-3,y+3,x+3,y-3)
}


function TracerStyle(){
	let v10,v20,v30,v40,xg,yg,xp,yp,OK=true;

	function TracerFil (alpha,hfil1,hfil2){
				let x1,y1,x2,y2,x3,y3,x4,y4,x10,y10,x20,y20;
				let coordFil=[];
				const a=Math.tan(alpha/180*Math.PI)
				const b=cs.ygnomon-a*cs.xgnomon
				const h=cs.hauteur/2; const l=cs.largeur/2;
				x1=(h-b)/a;y1=h;   if (pointDansCadran (x1,y1)){coordFil.push([x1,y1])}
				x2=l;y2=l*a+b  ;   if (pointDansCadran (x2,y2)){coordFil.push([x2,y2])}				
				x3=(-h-b)/a;y3=-h; if (pointDansCadran (x3,y3)){coordFil.push([x3,y3])}	
				x4=-l;y4=(-l)*a+b; if (pointDansCadran (x4,y4)){coordFil.push([x4,y4])}	
				OK=(coordFil.length==2)
				if (OK) {
				x10=coordFil[0][0];y10=coordFil[0][1]
				v10=new THREE.Vector3( x10,y10, (cs.epaisseur/2+hfil1)  )
				x20=coordFil[1][0];y20=coordFil[1][1]
		        v20=new THREE.Vector3( x20,y20, (cs.epaisseur/2+hfil2)  )
			    }
                return OK}



    if (typeof(stylePolaire)!=="undefined") {stylePolaire.geometry.dispose()};
	if (typeof(sousStylaire)!=="undefined") {stylePolaire.geometry.dispose()};
	cadranSolaireGroup.remove(stylePolaire);
	cadranSolaireGroup.remove(sousStylaire);
	if (typeof(filHorizontal)!=="undefined") {filHorizontal.geometry.dispose()};
	if (typeof(filVertical)!=="undefined") {filVertical.geometry.dispose()};
	cadranSolaireGroup.remove(filHorizontal);
	cadranSolaireGroup.remove(filVertical);
	if (typeof(pilierH1)!=="undefined") {pilierH1.geometry.dispose()};
	if (typeof(pilierH2)!=="undefined") {pilierH2.geometry.dispose()};
	if (typeof(pilierH3)!=="undefined") {pilierH3.geometry.dispose()};
	if (typeof(pilierH4)!=="undefined") {pilierH4.geometry.dispose()};
	cadranSolaireGroup.remove(pilierH1);
	cadranSolaireGroup.remove(pilierH2);
	cadranSolaireGroup.remove(pilierH3);
	cadranSolaireGroup.remove(pilierH4);




if (cs.typeCadran==SP){
	if ( cs.angleStyleSousstylaire>0.4) { 
		//  Si l'angle Style polaire-SousStylaire> 0.4Â°
		const v1=new THREE.Vector3( cs.xPole+cs.xgnomon,cs.yPole+cs.ygnomon, (cs.epaisseur+cs.egnomon)/2 );
		const v2=new THREE.Vector3( cs.xgnomon,cs.ygnomon, cs.hgnomon+(cs.epaisseur+cs.egnomon)/2);
		const tubeGeometrySP = new THREE.TubeGeometry( new THREE.LineCurve3( v1, v2 ), 16, cs.egnomon,8 );
		stylePolaire = new THREE.Mesh( tubeGeometrySP, materialGnomon);
		stylePolaire.castShadow = true;
		cadranSolaireGroup.add(stylePolaire);
		stylePolaire.visible=cs.vstyle;
		// Sous-stylaire
		const v3=new THREE.Vector3( cs.xPole+cs.xgnomon,cs.yPole+cs.ygnomon, (cs.epaisseur+cs.egnomon)/2 );
		const v4=new THREE.Vector3( cs.xgnomon,cs.ygnomon, (cs.epaisseur+cs.egnomon)/2);
		const tubeGeometrySS = new THREE.TubeGeometry( new THREE.LineCurve3( v3, v4 ), 16, cs.egnomon,8 );
		sousStylaire = new THREE.Mesh( tubeGeometrySS, materialGnomon);
		sousStylaire.castShadow = true;
		cadranSolaireGroup.add(sousStylaire);
		sousStylaire.visible=cs.vsousstyle

		gnomon.visible=cs.vgnomon
		//boutGnomon.visible=cs.vgnomon
		ligneSVG(v3.x,v3.y,v4.x,v4.y)
		croixSVG(v4.x,v4.y)
		//console.log(SVGtext)
		
		}// sinon style polaire parallele au plan  ${cs.egnomon.toFixed(2)}
	}

if (cs.typeCadran==BF){
	  calculg1g2k1k2()
	  if (cs.anglefilVertical==90){
    	v10=new THREE.Vector3( cs.xgnomon,-cs.hauteur/2, (cs.epaisseur/2+cs.hfilVertical)  );
		v20=new THREE.Vector3( cs.xgnomon, cs.hauteur/2, (cs.epaisseur/2+cs.hfilVertical)  )}
		    else TracerFil(cs.anglefilVertical,cs.hfilVertical,cs.hfilVertical);
		cs.xB1=v10.x;cs.yB1=v10.y;cs.xB2=v20.x;cs.yB2=v20.y;
		const tubeGeometryFV = new THREE.TubeGeometry( new THREE.LineCurve3( v10, v20 ), 16, cs.egnomon,8 );
		filVertical = new THREE.Mesh( tubeGeometryFV, materialGnomon);
		filVertical.castShadow = true;
		cadranSolaireGroup.add(filVertical);

	  if (cs.anglefilHorizontal==0){
		v10=new THREE.Vector3( -cs.largeur/2, cs.ygnomon, (cs.epaisseur/2+cs.hfilHorizontal)  );
		v20=new THREE.Vector3(  cs.largeur/2, cs.ygnomon, (cs.epaisseur/2+cs.hfilHorizontal)  )}
		    else TracerFil(cs.anglefilHorizontal,cs.hfilHorizontal,cs.hfilHorizontal);
		cs.xA1=v10.x;cs.yA1=v10.y;cs.xA2=v20.x;cs.yA2=v20.y;
		const tubeGeometryFH = new THREE.TubeGeometry( new THREE.LineCurve3( v10, v20 ), 16, cs.egnomon,8 );
		filHorizontal = new THREE.Mesh( tubeGeometryFH, materialGnomon);
		filHorizontal.castShadow = true;
		cadranSolaireGroup.add(filHorizontal)

		gnomon.visible=false;
		croixSVG(cs.xA1,cs.yA1);croixSVG(cs.xA2,cs.yA2);croixSVG(cs.xB1,cs.yB1);croixSVG(cs.xB2,cs.yB2)
		croixSVG(cs.xgnomon,cs.ygnomon)
		//console.log(g1,g2,k1,k2)
		
	}

	if (cs.typeCadran==BFG){

			if (cs.anglefilVertical==90){
			v10=new THREE.Vector3( cs.xgnomon,-cs.hauteur/2, (cs.epaisseur/2+cs.hB1)  );
			v20=new THREE.Vector3( cs.xgnomon, cs.hauteur/2, (cs.epaisseur/2+cs.hB2)  )}
				else TracerFil(cs.anglefilVertical,cs.hB1,cs.hB2);
			cs.xB1=v10.x;cs.yB1=v10.y;cs.xB2=v20.x;cs.yB2=v20.y;
			const tubeGeometryFV = new THREE.TubeGeometry( new THREE.LineCurve3( v10, v20 ), 16, cs.egnomon,8 );
			filVertical = new THREE.Mesh( tubeGeometryFV, materialGnomon);
			filVertical.castShadow = true;
			cadranSolaireGroup.add(filVertical);
			v30=new THREE.Vector3(v10.x,v10.y,-cs.epaisseur/2)
			const tubeGeometryH1=new THREE.TubeGeometry( new THREE.LineCurve3( v10, v30 ), 16, cs.egnomon,8 );
			pilierH1=new THREE.Mesh( tubeGeometryH1, materialGnomon);
			v40=new THREE.Vector3(v20.x,v20.y,-cs.epaisseur/2)
			const tubeGeometryH2=new THREE.TubeGeometry( new THREE.LineCurve3( v20, v40 ), 16, cs.egnomon,8 );
			pilierH2=new THREE.Mesh( tubeGeometryH2, materialGnomon);
			cadranSolaireGroup.add(pilierH1);cadranSolaireGroup.add(pilierH2);

			if (cs.anglefilHorizontal==0){
			v10=new THREE.Vector3( -cs.largeur/2, cs.ygnomon, (cs.epaisseur/2+cs.hA1)  );
			v20=new THREE.Vector3(  cs.largeur/2, cs.ygnomon, (cs.epaisseur/2+cs.hA2)  )}
				else TracerFil(cs.anglefilHorizontal,cs.hA1,cs.hA2);
			cs.xA1=v10.x;cs.yA1=v10.y;cs.xA2=v20.x;cs.yA2=v20.y;
			const tubeGeometryFH = new THREE.TubeGeometry( new THREE.LineCurve3( v10, v20 ), 16, cs.egnomon,8 );
			filHorizontal = new THREE.Mesh( tubeGeometryFH, materialGnomon);
			filHorizontal.castShadow = true;
			cadranSolaireGroup.add(filHorizontal)
			v30=new THREE.Vector3(v10.x,v10.y,-cs.epaisseur/2)
			const tubeGeometryH3=new THREE.TubeGeometry( new THREE.LineCurve3( v10, v30 ), 16, cs.egnomon,8 );
			pilierH3=new THREE.Mesh( tubeGeometryH3, materialGnomon);
			v40=new THREE.Vector3(v20.x,v20.y,-cs.epaisseur/2)
			const tubeGeometryH4=new THREE.TubeGeometry( new THREE.LineCurve3( v20, v40 ), 16, cs.egnomon,8 );
			pilierH4=new THREE.Mesh( tubeGeometryH4, materialGnomon);
			cadranSolaireGroup.add(pilierH3);cadranSolaireGroup.add(pilierH4);
			
			croixSVG(cs.xA1,cs.yA1);croixSVG(cs.xA2,cs.yA2);croixSVG(cs.xB1,cs.yB1);croixSVG(cs.xB2,cs.yB2)
		    croixSVG(cs.xgnomon,cs.ygnomon)
			gnomon.visible=false;
			
  //console.log(g1,g2,k1,k2)
  
}
}  //Tracer Style

//------------------------------------------------------------------------------------------------------
function ExtrudeSetting (c,spline,nsteps){
      const squareShape = new THREE.Shape()
					.moveTo(  0,c )
				//	.lineTo(  -c,c )
				    .lineTo(  -2*c,0 )
				//	.lineTo(  -c, -c)
					.lineTo(  0, -c)
					.lineTo(  0, c);
      const Settings = {
					steps:nsteps,
					bevelEnabled: false,
					extrudePath: spline
				};
	return {forme:squareShape,setting:Settings}
}
//---------------------------------------------------------------------------------------------------------
function effacelisteMesh(listeMesh,group){
   //Effacement des lignes existantes
   const lm=listeMesh.length;
   let mesh;
   for (let i = 0; i < lm; i++)
                    {
   	                mesh = listeMesh[ i ];
   	                mesh.geometry.dispose();
					group.remove(mesh);
					}
   listeMesh=[];
   cadranSolaireGroup.remove(group);
}	
//-----------------------------------------------------------------------------------------------------------------------
function traceLignes(sunDial,listeMesh,group,material)
{
	let tubeGeometry,mesh,xp,yp,zp,pipeSpline,pipeSplineCRC,longLigne,xs,ys,eptrait;
// tracÃ© des nouvelles lignes
    for (let i = 0; i < sunDial.lines.length; i++) {
		longLigne=sunDial.lines[i].points.length
   		if (longLigne>1) 
   		{ 	 CSVtext +="Heure: "+sunDial.lines[i].hour.toString()+"\n";
			 pipeSpline = [];
			 if(presqueEntier(sunDial.lines[i].hour)){eptrait= cs.egnomon}else{eptrait= cs.egnomon/2}
			 if (SVGtext.length>0)   {
				SVGtext+=` 
				          <polyline fill="none" stroke="${material.color.getStyle()}" stroke-width="${eptrait}"
				           points= " ` }
			
			 for (let p = 0; p < sunDial.lines[i].points.length; p++)
			    {
			 	xp=sunDial.lines[i].points[p].x+cs.xgnomon;
   			    yp=sunDial.lines[i].points[p].y+cs.ygnomon;
   			    zp=cs.epaisseur/2+cs.egnomon/2;
				
				pipeSpline.push(new THREE.Vector3(xp,yp,zp));
				CSVtext += "point: "+separateurCSV+xp.toFixed(2)+separateurCSV+yp.toFixed(2)+"\n";
				if (SVGtext.length>0){
					       xs=xp+cs.largeur/2;ys=-yp+cs.hauteur/2
				           SVGtext+=`${xs.toFixed(3)},${ys.toFixed(3)}   `
						}
				};		
				if (SVGtext.length>0)   { SVGtext+=`" />`	}
			if (pipeSpline.length>1) 
				{
				    pipeSplineCRC=[];
				    pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline,false,'chordal',1);

					
				    tubeGeometry = new THREE.TubeGeometry( pipeSplineCRC,180, eptrait,8,false );
					
					//const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,180)
			        //tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 

				    mesh = new THREE.Mesh( tubeGeometry, material);				  
					mesh.receiveShadow = true;
					listeMesh.push(mesh);
					group.add(mesh);
					cadranSolaireGroup.add(group) }				   
   		}
   }
//   TracerStyle()
}
                // const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,200)
			    // tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 
				// mesh = new THREE.Mesh( tubeGeometry, material);

				// const lineGeometry = new THREE.BufferGeometry().setFromPoints( pipeSplineCRC );				   
				// const lineMaterial = new THREE.LineBasicMaterial( {color:0x0000FF});
				// mesh = new THREE.Mesh( lineGeometry, lineMaterial);		 
  
//---------------------------------------------------------------------------------------------------------
function TracerHeuresSolaires ()
{  cs.hoursTextSize=cs.textSizeHS
   const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax,HS,heuresSolairesGroup,materialHeuresSolaires,heuresSolairesListeMesh);
   CSVtext+="\n\n"
   CSVtext+='Solar hours'+"\n\n"
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";
   traceLignes(sunDial,heuresSolairesListeMesh,heuresSolairesGroup,materialHeuresSolaires)

}

//-------------------------------------------------------------------------------------------------------
function TracerHeuresLegalesSA ()
{
   cs.hoursTextSize=cs.textSizeSA
   const sunDial=generalAJL
        (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
        TS.jdecSunMax,TS.jdecSunMin,HLSA,heuresLegalesGroupSA,materialHeuresLegalesSA,heuresLegalesListeMeshSA);
   CSVtext+="\n\n"
   CSVtext+='Legal hours (Summer and Autumn)'+"\n\n"
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";

   traceLignes(sunDial,heuresLegalesListeMeshSA,heuresLegalesGroupSA,materialHeuresLegalesSA)

}

function TracerHeuresLegalesWS(){

		cs.hoursTextSize=cs.textSizeWS
		const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax+1,HLWS,heuresLegalesGroupWS,materialHeuresLegalesWS,heuresLegalesListeMeshWS);
		 CSVtext+="\n\n"
		 CSVtext+='Legal hours (Winter and Spring)'+"\n\n"
		angleStylePlan=base.toDeg(sunDial.angle);
		CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";

		traceLignes(sunDial,heuresLegalesListeMeshWS,heuresLegalesGroupWS,materialHeuresLegalesWS)

}

//------------------------------------------------------------------------------------------------
function TracerHeuresAntiques ()
{
   if (Math.abs(cs.lati)>=66.6) {alert('Unequal hours make no sense in arctic latitudes');
                                 cadranSolaireGroup.remove(heuresAntiquesGroup);
								 return}
   cs.hoursTextSize=cs.textSizeHA
   const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax,HA,heuresAntiquesGroup,materialHeuresAntiques,heuresAntiquesListeMesh);
   CSVtext+="\n\n"
   CSVtext+='Antic hours'+"\n\n"
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";

   traceLignes(sunDial,heuresAntiquesListeMesh,heuresAntiquesGroup,materialHeuresAntiques)
}
//-----------------------------------------------------------------------------------------------------
function TracerHeuresBabyloniques(){
   if (Math.abs(cs.lati)>=66.6) {alert('Babylonics hours make no sense in arctic latitudes');
   								 cadranSolaireGroup.remove(heuresBabyloniquesGroup);
   								 return}
   cs.hoursTextSize=cs.textSizeHB;
   const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax,HB,heuresBabyloniquesGroup,materialHeuresBabyloniques,heuresBabyloniquesListeMesh);
   CSVtext+="\n\n"
   CSVtext+='Babylonics hours'+"\n\n"
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";

   traceLignes(sunDial,heuresBabyloniquesListeMesh,heuresBabyloniquesGroup,materialHeuresBabyloniques)

}
//-----------------------------------------------------------------------------------------------------
function TracerHeuresItaliques(){
   if (Math.abs(cs.lati)>=66.6) {alert('Italic hours make no sense in arctic latitudes');
   								 cadranSolaireGroup.remove(heuresItaliquesGroup);
   								 return}
   cs.hoursTextSize=cs.textSizeHI;
   const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMax,TS.jdecSunMin,HI,heuresItaliquesGroup,materialHeuresItaliques,heuresItaliquesListeMesh);
   CSVtext+="\n\n"
   CSVtext+='Italic hours'+"\n\n"
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";

   traceLignes(sunDial,heuresItaliquesListeMesh,heuresItaliquesGroup,materialHeuresItaliques)

}

//------------------------------------------------------------------------------------------------------
function TracerHeuresSDSA(){
	cs.hoursTextSize=cs.textSizeSDSA;
   const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMax,TS.jdecSunMin,HSDSA,heuresSDSAgroup,materialHeuresSDSA,heuresSDSAListeMesh);
   CSVtext+="\n\n"
   CSVtext+=HSDSA+"\n\n"
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";

   traceLignes(sunDial,heuresSDSAListeMesh,heuresSDSAgroup,materialHeuresSDSA)
}

function TracerHeuresSDWS(){
	cs.hoursTextSize=cs.textSizeSDWS;
   const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax,HSDWS,heuresSDWSgroup,materialHeuresSDWS,heuresSDWSListeMesh);
   CSVtext+="\n\n"
   CSVtext+=HSDWS+"\n\n"
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+angleStylePlan.toFixed(3)+"\n\n";

   traceLignes(sunDial,heuresSDWSListeMesh,heuresSDWSgroup,materialHeuresSDWS)

}

//---------------------------------------------------------------------------------------------------------
function TracerArcsDiurnes ()
{let tubeGeometry,mesh,xp,yp,zp,lm,pipeSpline,pipeSplineCRC,xs,ys;

   effacelisteMesh(arcsDiurnesListeMesh,arcsDiurnesGroup)
   
   const sunDial=arcsDiurnes
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax,arcsDiurnesGroup,materialArcsDiurnes,arcsDiurnesListeMesh);
   
   angleStylePlan=base.toDeg(sunDial.angle);
   CSVtext +="\n\n";
   CSVtext +="Diurnial arcs"+"\n\n";

   //traceLignes(sunDial,arcsDiurnesListeMesh,arcsDiurnesGroup,materialArcsDiurnes)
   // tracÃ© des nouvelles lignes
   for (let i = 0; i < sunDial.lines.length; i++) {
   		if (sunDial.lines[i].points.length>1) 
   		{ 	 CSVtext +="Date: "+sunDial.lines[i].date[0].toString()+"\n";
			 pipeSpline = [];
			 if (SVGtext.length>0)   {
				SVGtext+=` 
				          <polyline fill="none" stroke="${materialArcsDiurnes.color.getStyle()}" stroke-width="${cs.egnomon}"
				           points= " ` }
			
			 for (let p = 0; p < sunDial.lines[i].points.length; p++)
			    {
			 	xp=sunDial.lines[i].points[p].x+cs.xgnomon;
   			    yp=sunDial.lines[i].points[p].y+cs.ygnomon;
   			    zp=(cs.epaisseur+cs.egnomon)/2;				
				pipeSpline.push(new THREE.Vector3(xp,yp,zp));
				CSVtext+= "point: "+separateurCSV+xp.toFixed(2)+separateurCSV+yp.toFixed(2)+"\n"
				if (SVGtext.length>0){
					       xs=xp+cs.largeur/2;ys=-yp+cs.hauteur/2
				           SVGtext+=`${xs.toFixed(3)},${ys.toFixed(3)}   `
						   }
				};
				if (SVGtext.length>0)   { SVGtext+=`" />`	}			
				if (pipeSpline.length>1) 
				   {
				   pipeSplineCRC=[];
				   pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline);
				   tubeGeometry = new THREE.TubeGeometry( pipeSplineCRC,200, cs.egnomon,8,false );
				   mesh = new THREE.Mesh( tubeGeometry, materialArcsDiurnes);
				   mesh.receiveShadow = true;
				   arcsDiurnesListeMesh.push(mesh);
				   arcsDiurnesGroup.add(mesh);
			       }
   		 }
   }
  //TracerStyle(sunDial)
  cadranSolaireGroup.add(arcsDiurnesGroup); 
  
}

/**
 * Point return type represents a point to be used in constructing the sundial.
 */
function Point (x, y) {
  this.x = x || 0
  this.y = y || 0
}

/**
 * Line holds data to draw an hour line on the sundial.
 */
function LigneHoraire (hour, points) {
  this.hour = hour // 0 to 24
  this.points = points || [] // One or more points corresponding to the hour.
}

function LigneArc (date, points) {
  this.date = date 
  this.points = points || [] // One or more points corresponding to the date.
}

//const m = [-23.44,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-9,-8,-7,-6,-5,-4,-3,-2,-1,
//           0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23, 23.44]

/**
 * General computes data for the general case of a planar sundial.
 *
 * Argument Ï is geographic latitude at which the sundial will be located.
 * D is gnomonic declination, the azimuth of the perpendicular to the plane
 * of the sundial, measured from the southern meridian towards the west.
 * Argument a is the length of a straight stylus perpendicular to the plane
 * of the sundial, z is zenithal distance of the direction defined by the
 * stylus.  Angles Ï, D, and z are in radians.  Units of stylus length a
 * are arbitrary.
 *
 * Results consist of a set of lines, a center point, u, the length of a
 * polar stylus, and Ï, the angle which the polar stylus makes with the plane
 * of the sundial.  The center point, the points defining the hour lines, and
 * u are in units of a, the stylus length.  Ï is in radians.
 */

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
function Correction(H0,j) 
{ let c=0
	c=TS.eqtimes[j] + (cs.longi/15 - cs.offset_sec/3600)* Math.PI / 12;
 return (H0+c);  //angle horaire en radians, de -pi Ã  +pi
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
function coordOmbre(sH,cH,sD,cD,sz,cz,sÏ,cÏ,tÎ´,Q){
  
  if (cs.typeCadran==SP){
	const Nx = cD * sH - sD * (sÏ * cH - cÏ * tÎ´)
	const Ny = cz * sD * sH - (cÏ * sz - sÏ * cz * cD) * cH - (sÏ * sz + cÏ * cz * cD) * tÎ´	 
	return {
		xo: cs.hgnomon * Nx / Q,
		yo: cs.hgnomon * Ny / Q,
		ok:true }
  }
  if (cs.typeCadran==BF){
	const Dn = sD*sH+cD*(sÏ*cH-cÏ*tÎ´)
	const Nx = (g1*(cD * sH - sD * (sÏ * cH - cÏ * tÎ´))+k1*(sÏ*tÎ´+cÏ*cH))/Dn
	const Ny = (g2*(sÏ*tÎ´+cÏ*cH) + k2*(cD * sH - sD * (sÏ * cH - cÏ * tÎ´)))/Dn
	return {
		xo: -Nx,
		yo: -Ny,
		ok:true}
  }
  if (cs.typeCadran==BFG){
	const Nx = cD * sH - sD * (sÏ * cH - cÏ * tÎ´)
	const Ny = cz * sD * sH - (cÏ * sz - sÏ * cz * cD) * cH - (sÏ * sz + cÏ * cz * cD) * tÎ´	 
	const xA1=cs.hA1*Nx/Q+cs.xA1  //algorythme Hugo: coord des points d'ombre des supports
	const yA1=cs.hA1*Ny/Q+cs.yA1
	const xA2=cs.hA2*Nx/Q+cs.xA2
	const yA2=cs.hA2*Ny/Q+cs.yA2
	const xB1=cs.hB1*Nx/Q+cs.xB1
	const yB1=cs.hB1*Ny/Q+cs.yB1
	const xB2=cs.hB2*Nx/Q+cs.xB2
	const yB2=cs.hB2*Ny/Q+cs.yB2
	const a=yA2-yA1; const b=-xA2+xA1;    //coefs droite A1A2: a x + b y =c
	const c=xA1*(yA2-yA1)-yA1*(xA2-xA1)
	const ap=yB2-yB1; const bp=-xB2+xB1;  //coefs droite B1B2: ap x + bp y = cp
	const cp=xB1*(yB2-yB1)-yB1*(xB2-xB1)
	let det=a*bp-ap*b
	//console.log(det)
	const xombre=(bp*c-b*cp)/det-cs.xgnomon
	const yombre=(a*cp-ap*c)/det-cs.ygnomon
	const kxA=(xombre-xA1)/(xA2-xA1)
	const kxB=(xombre-xB1)/(xB2-xB1)
	const kyA=(yombre-yA1)/(yA2-yA1)
    const kyB=(yombre-yB1)/(yB2-yB1)
	//if ((kxA<0)||(kxA>1)||(kxB<0)||(kxB>1)||(kyA<0)||(kyA>1)||(kyB<0)||(kyB>1)){det=0}
	if ((kxA<0)||(kxA>1)||(kxB<0)||(kxB>1)||(!(pointDansCadran(xombre+cs.xgnomon,yombre+cs.ygnomon)))){det=0}
	//if (det!==0) {return{
	if (Math.abs(det)>1) {return{
	   xo:xombre,
	   yo:yombre,
	   ok:true}
	}else{return{
	   xo:0,
	   yo:0,
	   ok:false} } 
  }
}


function presqueEntier(x){
	return (Math.abs(Math.round(x)-x)<0.001)
}

function generalAJL (Ï, D, a, z,debut,fin,TypeHeure,group,material,listeMesh) { 
	// (Ï, D, a, z float64)  (lines []LigneHoraire, center Point, u, Ï float64)
	let l
	let coupe=false
	effacelisteMesh(listeMesh,group)
	let H,xp,yp,xm,ym,chiffreH=0,sHeure="";
	if (Ï*180/Math.PI>89.999999){Ï=89.999999*Math.PI/180}
	const [sÏ, cÏ] = base.sincos(Ï)
	const tÏ = sÏ / cÏ
	const [sD, cD] = base.sincos(D)
	const [sz, cz] = base.sincos(z)
	const P = sÏ * cz - cÏ * sz * cD
	const tan23p44=Math.tan(23.44/180*Math.PI) 
	const lines = []
	for (let i = 0; i <= 24; i+=cs.subDivisions) {
	  l = new LigneHoraire(i)
	  const Hi = (i - 12) * 15 * Math.PI / 180
	 
	  let j=debut;
	  while (j!==fin+1) 
	  {
        //if((Math.abs(j-TS.jdecSunMin)<5)||(Math.abs(j-TS.jdecSunMax)<5)){j++}else{j+=cs.precisionHours}
		j++     
		if (j>=TS.decSuns.length) {j=0}	
		if ((j%cs.precisionHours==0)||(Math.abs(j-TS.jdecSunMin)<=7)||(Math.abs(j-TS.jdecSunMax)<=7))
		{
		coupe=false	
        const tÎ´ = Math.tan(TS.decSuns[j])
		const cosH0=-tÏ * tÎ´
		let  H0 = Math.acos(cosH0)    //half day length 
		if (cosH0> 1){H0=-Math.PI}   //nuit polaire
		if (cosH0<=-1){H0= Math.PI}  //j0ur polaire

		if (TypeHeure==HS){H=Hi;chiffreH=i}     // Heures solaires
        if ((TypeHeure==HLSA)||(TypeHeure==HLWS)) {H=Correction(Hi,j);chiffreH=i}   //lÃ©gales
		if (TypeHeure==HA)  {H=H0/6*(i-12);chiffreH=i-6}  // heures antiques
	    if (TypeHeure==HB)  {H=i*15/180*Math.PI-H0;chiffreH=i}  //heures babyloniques
		if (TypeHeure==HI)  {H=(i-24)*15/180*Math.PI+H0 ;chiffreH=i}  //heures italiquesiques
		if (TypeHeure==HSDSA){
		   const RA=Math.PI-Math.asin(tÎ´/tan23p44) //heures sidÃ©rales
		   H=i*15/180*Math.PI-RA
		   chiffreH=i}
		if (TypeHeure==HSDWS){
		   const RA=Math.asin(tÎ´/tan23p44) //heures sidÃ©rales
		   H=(i-12)*15/180*Math.PI-RA
		   if ((i-12)<0){chiffreH=i+12}else{chiffreH=i-12}
		   }        
		const aH = Math.abs(H)		
		const [sH, cH] = base.sincos(H)
		if (aH <H0) { // sun above horizon
			const Q = sD * sz * sH + (cÏ * cz + sÏ * sz * cD) * cH + P * tÎ´
			if (Q > 0) { // sun above plane of sundial         
			const coor=coordOmbre(sH,cH,sD,cD,sz,cz,sÏ,cÏ,tÎ´,Q)       // Calcul des coodr de l'ombre
			if (coor.ok==true){
			   xp=coor.xo;yp=coor.yo;
			   if (pointDansCadran(xp+cs.xgnomon,yp+cs.ygnomon)) 
			      { if (coupe){
					if (l.points.length > 0){lines.push(l)}
					l = new LigneHoraire(i);coupe=false}
					l.points.push(new Point(xp,yp ));xm=xp+cs.xgnomon;ym=yp+cs.ygnomon }else {coupe=true}
		       }
			}
			}

		}
	  }
	  if(presqueEntier(chiffreH)){sHeure=Math.round(chiffreH).toString()} else{sHeure=""};
	  if (l.points.length > 0) {lines.push(l);
	                            EcrireTexte(sHeure,xm,ym,material,group,listeMesh)
							   }
	}
	const center = new Point()
	center.x = a / P * cÏ * sD
	center.y = -a / P * (sÏ * sz + cÏ * cz * cD)
	const aP = Math.abs(P)
	const u = a / aP
	const Ï = Math.asin(aP)
	cs.xPole=center.x; cs.yPole=center.y; cs.angleStyleSousstylaire=Ï*180/Math.PI;
//console.log (lines)
	return {
	  lines: lines,
	  center: center,
	  length: u,
	  angle: Ï
	}
  }


function arcsDiurnes (Ï, D, a, z,debut,fin,group,material,listeMesh) { 
	// (Ï, D, a, z float64)  (lines []LigneHoraire, center Point, u, Ï float64)
	let H,xp,yp,xm,ym,s,coupe,l;

	if (Ï*180/Math.PI>89.999999){Ï=89.999999*Math.PI/180}
	const [sÏ, cÏ] = base.sincos(Ï)
	const tÏ = sÏ / cÏ
	const [sD, cD] = base.sincos(D)
	const [sz, cz] = base.sincos(z)
	const P = sÏ * cz - cÏ * sz * cD
	 
	const lines = []
	
	for (const d of cs.datesArcsDiurnes)
	  {
	    l = new LigneArc(d)   
		coupe=false     
		for (let i = 0; i < 24*60; i+=cs.precisionArcs) 
		    {   
			const H = (i - 12*60)/60 * 15 * Math.PI / 180	
			const aH = Math.abs(H)
			const [sH, cH] = base.sincos(H)
			const tÎ´ = Math.tan(d[1])
			const cosH0=-tÏ * tÎ´
			let  H0 = Math.acos(cosH0)
			if (cosH0> 1){H0=-Math.PI}  //nuit polaire
			if (cosH0<=-1){H0= Math.PI}  //jour polaire
			if (aH <H0) 
			    { // sun above horizon
				const Q = sD * sz * sH + (cÏ * cz + sÏ * sz * cD) * cH + P * tÎ´
				if (Q > 0) 
				    { // sun above plane of sundial         
					const coord=coordOmbre(sH,cH,sD,cD,sz,cz,sÏ,cÏ,tÎ´,Q)
					if (coord.ok==true){
					    xp=coord.xo;yp=coord.yo;
					    if (pointDansCadran(xp+cs.xgnomon,yp+cs.ygnomon)) 
							{ if (coupe){
								if (l.points.length > 0) {lines.push(l) }
								l = new LigneArc(d);coupe=false  }
								l.points.push(new Point(xp,yp ));
								xm=xp+cs.xgnomon;ym=yp+cs.ygnomon;coupe=false } else {coupe=true}
						    }
					}
				}
	        }
	    if (l.points.length > 0) {lines.push(l) }
	}
	const center = new Point()
	center.x = a / P * cÏ * sD
	center.y = -a / P * (sÏ * sz + cÏ * cz * cD)
	const aP = Math.abs(P)
	const u = a / aP
	const Ï = Math.asin(aP)
	cs.xPole=center.x; cs.yPole=center.y; cs.angleStyleSousstylaire=Ï*180/Math.PI;
	return {
	  lines: lines,
	  center: center,
	  length: u,
	  angle: Ï
	}
  }
	  
//-----------------------------------------------------------------------------------------------------
function loadJsonFile() 
{ let csl;
  const [file] = document.querySelector('input[type=file]').files;
  
  const reader = new FileReader();
  reader.addEventListener("load", () => 
    {
	try{csl=JSON.parse(reader.result)}
	catch (e) {console.error("Parsing error:", e)} 
	//console.log(JSON.stringify(csl,null,2));
	for (var k in csl) {cs[k]=csl[k]}
	console.log(JSON.stringify(cs,null,2));
	TS=TableSol(cs.year);
    run();
    }, false);
  if (file) 
   {
    reader.readAsText(file);
   }
   
   return reader.result;
  

}	



//--------------------------------------------------------------------------------------------------------
//function saveString    Ecris la chaine de caracteres text dans le fichier texte de nom filename 
//saveString('mon texte','Bidon.txt');
			const link = document.createElement( 'a' );
			link.style.display = 'none';
			document.body.appendChild( link ); // Firefox workaround, see #6594
			function save( blob, filename ) {
						link.href = URL.createObjectURL( blob );
						link.download = filename;
						link.click();}
			function saveString( text, filename ) {			       
               save( new Blob( [ text ], { type: 'text/plain' } ), filename );
			  // console.log(text)
			}
				
// ---------------------------------------------------------------------------------------------------
  function 	eulerCsGroup() 
  {
  	const a = new THREE.Euler( (cs.incli-90)/180*Math.PI, cs.decli/180*Math.PI,cs.rot/180*Math.PI, 'YXZ' );
	cadranSolaireGroup.setRotationFromEuler(a); 	
  }

// ---------------------------------------------------------------------------------------------------
//   function 	eulerEarthGroup() 
//   {
//   	const a = new THREE.Euler( (cs.lati-90)/180*Math.PI, 0*Math.PI,-cs.longi/180*Math.PI, 'YZX' );
// 	earthGroup.setRotationFromEuler(a); 	
//   }

//---------------------------------------------------------------------------------------------------------
function init() {
		

                //Effacement de toute la page d'introduction  

		document.getElementById("info").style.display = "none";		

				// dat.GUI ///////////////////////////////////////////////////////////////////////////////////////

	
        
		
		
	 	
const gui = new GUI( 
			{ width: Math.min(Math.round(window.innerWidth/2),245),title:"Edit sundial..." } 
			);
        const  sp=""  
gui.$title.style.color = 'yellow'

function helpGui(g,textHelp){
			g.domElement.addEventListener("mouseover", function(){
				gui.title(textHelp)
			})
			g.domElement.addEventListener("mouseout", function(){
				gui.title("Edit sundial...")
			})
		}
		

		const hsol=gui.add( cs, "hsol", 0, 24, 0.01 )
                         .name("Hour  (0-24)")
                         .onChange(function(e){cs.hsol=e;PlacerLeSoleil()});
			  helpGui(hsol,'decimal hour')
			// hsol.domElement.addEventListener("mouseover", function(){
			// 	gui.title('decimal hour')
			// })
			// hsol.domElement.addEventListener("mouseout", function(){
			// 	gui.title("Edit sundial...")
			// })
        const dy=gui.add( cs, "dayofYear", 1, 365, 1 )
                         .name("Day (1-365))")
                         .onChange(function(e){cs.dayofYear=e;PlacerLeSoleil()}); 
			  helpGui(dy,'day of the year')
				
		gui.add(cs,"typeCadran",[SP,BF,BFG]).name("type of sundial")
		                 .onChange(function(e){
							 //console.log(e)
							 if (e==SP){folderGnomonBifilaireVertical.hide();
								        folderGnomonBifilaireGen.hide();
							        	ctlIncli.enable();   
										folderGnomonClassic.show();
										cs.typeCadran=SP;
										cs.vgnomon=true;
										TracerHeuresEtArcs();
										};
							 if (e==BF){folderGnomonClassic.hide();
										folderGnomonBifilaireGen.hide();
								        ctlIncli.setValue(90);
										cs.incli=90;
								        ctlIncli.disable();
								        folderGnomonBifilaireVertical.show()
										cs.typeCadran=BF;
										calculg1g2k1k2()
										TracerHeuresEtArcs();
									    };
							 if (e==BFG){folderGnomonClassic.hide();
										folderGnomonBifilaireVertical.hide();
										ctlIncli.enable();
										cs.typeCadran=BFG;
										folderGnomonBifilaireGen.show();
										TracerHeuresEtArcs() }
							
						    });
					
			
//// GEOLOCALISATION
const folderGeoSundial = gui.addFolder("Geolocation")
              //folderGeoSundial.domElement.addEventListener
			  folderGeoSundial.add(cs,"lati",-90,90,0.001) 
                    .name("Latitude")
                    .onChange(()=>{orienterAxedumonde();PlacerLaTerre() })
                    .onFinishChange(()=>{
                     orienterAxedumonde();
					 PlacerLaTerre();//eulerEarthGroup()
					 PlacerLeSoleil();TracerHeuresEtArcs()})
				    .listen();
              folderGeoSundial.add(cs,"longi",-180,180,0.001) 
                    .name("Longitude")
                    .onChange(()=>{PlacerLaTerre()
				  		           cs.offset_sec=Math.trunc(cs.longi/15)*3600}) 
                    .onFinishChange(()=>{PlacerLaTerre();//eulerEarthGroup():
					                           TracerHeuresEtArcs()})
					.listen();
              folderGeoSundial.add(cs,"adresse") 
                    .name("Seek by adress")
                    .onFinishChange(function(v){
                   	  if (v.length>0){
                   	  	RechercheParAdresse(v);
                     	TracerHeuresEtArcs();
                     	orienterAxedumonde();
						PlacerLaTerre ();}  })  
					.listen();
			const folderViewParam={functionViewMap(){
			//if (cs.urlOpenStreet==""){window.open(`https://www.openstreetmap.org/?mlat=${cs.lati.toFixed(3)}&mlon=${cs.longi.toFixed(3)}`)}
			//"_blank", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")}
			//window.open(cs.urlOpenStreet);
			//console.log(cs.urlOpenStreet)
			  window.open(cs.urlOpenStreet, "_blank", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")	}};
			  folderGeoSundial.add(folderViewParam,"functionViewMap")
		          .name('Map OpenStreet')
              folderGeoSundial.add(cs,"timezone") 
                    .name("Time zone")
				    .listen();
              folderGeoSundial.add(cs,"offset_sec",-43200,43200,3600) 
                    .name("offset from UTC (sec)")
                    .onFinishChange(function(v){
                   	    cs.offset_sec=v;
						TracerHeuresEtArcs() })
				    .listen();
			  console.log(cs)
			  folderGeoSundial.add(cs,"autoLocation") 
                    .name("auto")
                    .onFinishChange(function(v){
                   	    if (v) { getLocation()
							  TracerHeuresEtArcs();orienterAxedumonde();
						      PlacerLaTerre ()}
						 })
				   
            //   folderGeoSundial.add(cs,"offset_string") 
            //        .name(" offset (HHMM)");
            //   folderGeoSundial.add(cs,"now_in_dst") 
            //        .name("summer time (H)");

 const folderSundial = gui.addFolder( sp+'Geometry ' );

//// ORIENTATION				
	      	const folderOrientationSundial = folderSundial.addFolder("Orientation...");     
				folderOrientationSundial.add( cs, "decli", -180, 180, 0.1 )
				   .name("Declinaison")
				   .onChange(()=>{eulerCsGroup()}) 
				   .onFinishChange(()=>{TracerHeuresEtArcs() }); 
			const ctlIncli=	folderOrientationSundial.add( cs, "incli", -180, 180, 0.1 )
				   .name("Inclinaison")
				   .onChange(()=>{eulerCsGroup() })
				   .onFinishChange(()=>{TracerHeuresEtArcs()});
//                 folderOrientationSundial.add( cs, "rot", -180, 180, 0.1 )
//                    .name("Rotation")
//                    .onChange(function(v){
// 					cs.rot=v;
// 					eulerCsGroup() })
//                    .onFinishChange(function(){TracerHeuresEtArcs()});


//// DIMENTIONS
		      const folderDimensionsSundial = folderSundial.addFolder("Dimensions...");  
				folderDimensionsSundial.add( cs, "largeur", 10, 1000,0.1 )
				  .name("Width")
				  .onChange(()=>{ cadran.scale.x=cs.largeur;										
				                  meshDevise.position.x = -cs.largeur/2*0.9;
										})
				  .onFinishChange(function(){ TracerHeuresEtArcs() });				  
				folderDimensionsSundial.add( cs, "hauteur", 10, 1000, 0.1 )
				  .name("Height")
				  .onChange(function(v){cs.hauteur=v;cadran.scale.y=cs.hauteur;
				                        meshDevise.position.y = -cs.hauteur/2*0.9;
										PlacerLaTerre()})
				  .onFinishChange(function(){ TracerHeuresEtArcs() });				
				folderDimensionsSundial.add( cs, "epaisseur", 1, 1000, 0.1 )
				   .name("Depth")
				   .onChange(function(v){
					cs.epaisseur=v;
					cadran.scale.z=cs.epaisseur; 
					meshDevise.position.z = cs.epaisseur/2;					
					gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 })
				   .onFinishChange(function(){ TracerHeuresEtArcs() });    
				   
//// STYLE

const folderGnomon=folderSundial.addFolder('Shadow by ...');

        const folderGnomonClassic=folderGnomon.addFolder('Straight or polar style...');
				folderGnomonClassic.add( cs, "hgnomon", 1, 1000, 0.1 )
				  .name("Length straight style")
				  .onChange( function (e) {
                    cs.hgnomon=e;
                    gnomon.scale.y=cs.hgnomon;
                    gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 })
                  .onFinishChange(function(){TracerHeuresEtArcs()});				
                folderGnomonClassic.add( cs, "vgnomon" )
				  .name("straight style visible")
				  .onChange( function (e ) {
				  	cs.vgnomon=e				    
				    gnomon.visible=e})
				folderGnomonClassic.add( cs, "vstyle" )
				  .name("polar style visible")
				  .onChange( function (e ) {
					//TracerHeuresEtArcs()				    
				    stylePolaire.visible=e})
				folderGnomonClassic.add( cs, "vsousstyle" )
				  .name("under style visible")
				  .onChange( function (e ) {
					//TracerHeuresEtArcs()			    
				    sousStylaire.visible=e})

		const folderGnomonBifilaireVertical=folderGnomon.addFolder('Wires...');
		        folderGnomonBifilaireVertical.add( cs, "anglefilHorizontal", 0,180, 0.1 )
				  .name("angle  A")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})		
				folderGnomonBifilaireVertical.add( cs, "anglefilVertical", 0, 180, 0.1 )
				  .name("angle  B")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})	
		        folderGnomonBifilaireVertical.add( cs, "hfilHorizontal", 1, 500, 0.1 )
				  .name("height  A")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})	
				folderGnomonBifilaireVertical.add( cs, "hfilVertical", 1, 500, 0.1 )
				  .name("height  B")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})	
				

		
		
		        
		
		const folderGnomonBifilaireGen=folderGnomon.addFolder('Wires...');
		   
				folderGnomonBifilaireGen.add( cs, "anglefilHorizontal", 0,180, 0.1 )
				  .name("angle  A")
                  .onChange(function(){TracerStyle()})	
				  .onFinishChange(function(){TracerHeuresEtArcs()})	
				folderGnomonBifilaireGen.add( cs, "anglefilVertical", 0, 180, 0.1 )
				  .name("angle  B")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})	
				folderGnomonBifilaireGen.add( cs, "hA1", 0, 1000, 0.1 )
				  .name("height A1")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})	
				folderGnomonBifilaireGen.add( cs, "hA2", 0, 1000, 0.1 )
				  .name("height A2")
				  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})					
				folderGnomonBifilaireGen.add( cs, "hB1", 0, 1000, 0.1 )
				  .name("height B1")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})		
				folderGnomonBifilaireGen.add( cs, "hB2", 0, 1000, 0.1 )
				  .name("height B2")
                  .onChange(function(){TracerStyle()})
				  .onFinishChange(function(){TracerHeuresEtArcs()})		
		
		        
		const folderGnomonPosition=folderGnomon.addFolder('Position ...');		  
		       		  
				folderGnomonPosition.add( cs, "xgnomon", -1000, 1000, 0.1 )
				  .name(">")
				  .onChange(function(){
					gnomon.position.x=cs.xgnomon
					TracerStyle()
					gnomon.visible=(cs.vgnomon && cs.typeCadran==SP)})
				  .onFinishChange(function(){TracerHeuresEtArcs()})
				folderGnomonPosition.add( cs, "ygnomon", -1000, 1000, 0.1 )
				    .name("^")
                	.onChange(function(){
					gnomon.position.y=cs.ygnomon
					TracerStyle()
					gnomon.visible=(cs.vgnomon && cs.typeCadran==SP)})
				  	.onFinishChange(function(){TracerHeuresEtArcs()})

		folderGnomon.add( cs, "egnomon", 0.1, 5, 0.01 )
				  .name("Thickness")
				  .onChange(function(){
					gnomon.scale.x=cs.egnomon;
				    gnomon.scale.z=cs.egnomon; 
					
					TracerHeuresEtArcs()});		


                       
 
 //// COLOR             
 const folderColorsSundial = gui.addFolder("Color and texture");
				 	materialCS.color.setStyle(cs.colorCS); 
	                materialCS.emissive.setStyle(cs.emissiveCS); 
	               // materialCS.specular.setStyle(cs.specularCS); 
				    materialCS.metalness=cs.metalness;
	                materialCS.transparent=true;
	                materialCS.opacity=cs.opaciteCS;	              
              folderColorsSundial.addColor(cs, 'colorCS').name('reflection').onChange(function (e) {
                   materialCS.color = new THREE.Color(e);
                   cs.colorCS=materialCS.color.getStyle();
                   });           
              folderColorsSundial.addColor(cs, 'emissiveCS').name('emition').onChange(function (e) {
                   materialCS.emissive = new THREE.Color(e);
                   cs.emissiveCS=materialCS.emissive.getStyle();
                   });
			  folderColorsSundial.add(materialCS, 'metalness',0,1,0.1)
			  folderColorsSundial.add(materialCS, 'roughness',0,1,0.1)
            //   folderColorsSundial.addColor(controlCS, 'specular').onChange(function (e) {
            //        materialCS.specular = new THREE.Color(e);
            //        cs.specularCS=materialCS.specular.getStyle();
            //        });
            //   folderColorsSundial.add(materialCS, 'shininess', 0, 100, )              
              folderColorsSundial.add(cs,'opaciteCS',0,1,0.1)
                   .name('opacity').onChange(function(e)
                            {  materialCS.transparent=true;
              	               cs.opaciteCS=e;
                               materialCS.opacity=e }  );                      
              folderColorsSundial.add(materialCS, 'wireframe')
			                     .onChange(function(v){
									 materialGnomon.wireframe=v;
									 materialHeuresSolaires.wireframe=v;
									 materialHeuresLegalesSA.wireframe=v;
									 materialHeuresLegalesWS.wireframe=v;
									 materialArcsDiurnes.wireframe=v
								 });
             
			  const choixTextures={'steel':textureAcier,'copper':textureCuivre,'asphalt':textureAsphalt,'fruits':textureFruits}			  
			  folderColorsSundial.add( choixTextures,'steel', choixTextures ).name( 'Texture' )
			                    .onChange(function(t){
									materialCS.map=t
								    });		

//let  heure= {nom:"Solar (local true time)",trace:true,couleur:cs.colorHS,tailleFonte:cs.textSizeHS}     

const folderHours= gui.addFolder( sp+'Hours' );
        materialHeuresSolaires.color.setStyle(cs.colorHS);     
		materialHeuresLegalesSA.color.setStyle(cs.colorHLSummerAutums);  
		materialHeuresLegalesWS.color.setStyle(cs.colorHLWinterSpring);
		materialHeuresAntiques.color.setStyle(cs.colorHeuresAntiques);
		materialHeuresBabyloniques.color.setStyle(cs.colorHeuresBabyloniques);
		materialHeuresItaliques.color.setStyle(cs.colorHeuresItaliques);
		materialHeuresSDSA.color.setStyle(cs.colorHeuresSDSA);
		materialHeuresSDWS.color.setStyle(cs.colorHeuresSDWS);


			            folderHours.add(cs,'heuresSolaires')
			              .name(HS)
			              .onChange( function  (e){
			            	//cs.heuresSolaires=e;
			            	if (e) {cs.textSizeHS=cs.hoursTextSize;TracerHeuresSolaires()}else{cadranSolaireGroup.remove(heuresSolairesGroup)}});			     
			            folderHours.addColor(cs, 'colorHS')
						   .name('      color-> ')
			               .onChange(function (e) {
                           materialHeuresSolaires.color = new THREE.Color(e);
                           cs.colorHS=materialHeuresSolaires.color.getStyle()});
						// folderHours.add(cs,'textSizeHS',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresSolaires) {TracerHeuresSolaires()} });	

			            folderHours.add(cs,'heuresLegalesSummerAutums')
			              .name (HLSA)
			              .onChange( function  (e){
			            	if (e) {cs.textSizeSA=cs.hoursTextSize;TracerHeuresLegalesSA()}else{cadranSolaireGroup.remove(heuresLegalesGroupSA)}});			     
			            folderHours.addColor(cs, 'colorHLSummerAutums')
						   .name('      color-> ')
			               .onChange(function (e) {
                           materialHeuresLegalesSA.color = new THREE.Color(e);
                           cs.colorHLSummerAutums=materialHeuresLegalesSA.color.getStyle()});
						// folderHours.add(cs,'textSizeSA',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresLegalesSummerAutums) {TracerHeuresLegalesSA()} });	

			            folderHours.add(cs,'heuresLegalesWinterSpring')
			              .name(HLWS)
			              .onChange( function  (e){
			            	if (e) {cs.textSizeWS=cs.hoursTextSize;TracerHeuresLegalesWS()}else{cadranSolaireGroup.remove(heuresLegalesGroupWS)}});			     
			            folderHours.addColor(cs, 'colorHLWinterSpring')
						   .name("      color->  ")
			               .onChange(function (e) {
                           materialHeuresLegalesWS.color = new THREE.Color(e);
                           cs.colorHLWinterSpring=materialHeuresLegalesWS.color.getStyle()});
						// folderHours.add(cs,'textSizeWS',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresLegalesWinterSpring) {TracerHeuresLegalesWS()} });	
						
						folderHours.add(cs,'heuresAntiques')
			              .name(HA)
			              .onChange( function  (e){
			            	if (e) {cs.textSizeHA=cs.hoursTextSize;TracerHeuresAntiques()}else{cadranSolaireGroup.remove(heuresAntiquesGroup)}});			     
			            folderHours.addColor(cs, 'colorHeuresAntiques')
						   .name("      color->  ")
			               .onChange(function (e) {
                           materialHeuresAntiques.color = new THREE.Color(e);
                           cs.colorHeuresAntiques=materialHeuresAntiques.color.getStyle()});
						// folderHours.add(cs,'textSizeHA',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresAntiques) {TracerHeuresAntiques()} });	

						folderHours.add(cs,'heuresBabyloniques')
			              .name(HB)
						  
			              .onChange( function  (e){
			            	if (e) {cs.textSizeHB=cs.hoursTextSize;TracerHeuresBabyloniques()}else{cadranSolaireGroup.remove(heuresBabyloniquesGroup)}});			     
			            folderHours.addColor(cs, 'colorHeuresBabyloniques')
						   .name("      color->  ")
			               .onChange(function (e) {
                           materialHeuresBabyloniques.color = new THREE.Color(e);
                           cs.colorHeuresBayloniques=materialHeuresBabyloniques.color.getStyle()});
						// folderHours.add(cs,'textSizeHB',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresBabyloniques) {TracerHeuresBabyloniques()} });	

						folderHours.add(cs,'heuresItaliques')
			              .name(HI)
			              .onChange( function  (e){
			            	if (e) {cs.textSizeHI=cs.hoursTextSize;TracerHeuresItaliques()}else{cadranSolaireGroup.remove(heuresItaliquesGroup)}});			     
			            folderHours.addColor(cs, 'colorHeuresItaliques')
						   .name("      color->  ")
			               .onChange(function (e) {
                           materialHeuresItaliques.color = new THREE.Color(e);
                           cs.colorHeuresItaliques=materialHeuresItaliques.color.getStyle()});
						// folderHours.add(cs,'textSizeHI',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresItaliques) {TracerHeuresItaliques()} });	

						folderHours.add(cs,'heuresSideralesSA')
			              .name(HSDSA)
			              .onChange( function  (e){
			            	if (e) {cs.textSizeSDSA=cs.hoursTextSize;TracerHeuresSDSA()}else{cadranSolaireGroup.remove(heuresSDSAgroup)}});			     
			            folderHours.addColor(cs, 'colorHeuresSDSA')
						   .name("      color->  ")
			               .onChange(function (e) {
                           materialHeuresSDSA.color = new THREE.Color(e);
                           cs.colorHeuresSDSA=materialHeuresSDSA.color.getStyle()});
						// folderHours.add(cs,'textSizeSDSA',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresSideralesSA) {TracerHeuresSDSA()} });	

						folderHours.add(cs,'heuresSideralesWS')
			              .name(HSDWS)
			              .onChange( function  (e){
			            	if (e) {cs.textSizeSDWS=cs.hoursTextSize;TracerHeuresSDWS()}else{cadranSolaireGroup.remove(heuresSDWSgroup)}});			     
			            folderHours.addColor(cs, 'colorHeuresSDWS')
						   .name("      color->  ")
			               .onChange(function (e) {
                           materialHeuresSDWS.color = new THREE.Color(e);
                           cs.colorHeuresSDWS=materialHeuresSDWS.color.getStyle()});
						// folderHours.add(cs,'textSizeSDWS',0,5,0.1).name('   font size->')
			            //   .onFinishChange(function(v){
						//     if (cs.heuresSideralesWS) {TracerHeuresSDWS()} });	
					
					const folderHoursOptions=folderHours.addFolder("Options (choose before tracing)")
					folderHoursOptions.add(cs,'hoursTextSize',0,5,0.1).name('Font size')
					         //   .onFinishChange(function(v){TracerHeuresEtArcs()});
			        
					const subDiv={"no":1,
						          "30 min":0.5,
				                  "15 min":0.25,
								  "10 min":1/6,
								  " 5 min":1/12}
					folderHoursOptions.add( cs,"subDivisions", subDiv )
                         .name('Subdivisions')
						 .onChange(TracerHeuresEtArcs())
					
					const precisionH={"one day":1,
										   "2 days":2,
										   "5 days":5}
					folderHoursOptions.add( cs,"precisionHours", precisionH )
								.name('precision (days)')
								.onChange(TracerHeuresEtArcs())
                      

				
///// ARCS
        


        let dateArc={day:1,month:1,function1(){tracerArc()},function2(){effaceArcs()} };
		const folderArcs=   gui.addFolder( 'Diurnials arcs...' ); 
		              //  const folderDate= folderArcs.addFolder('Date')
					      folderArcs.add(dateArc,"day",1,31,1)
						            .name("Day of the month")
						          //  .onChange(function(v){dateArc.trace=false});
						  folderArcs.add(dateArc,"month",1,12,1)
						            .name("Month of the year")
						          //  .onChange(function(v){dateArc.trace=false});						  
						  folderArcs.add( dateArc, 'function1' )
						            .name("trace one arc");
						  folderArcs.add( dateArc, 'function2' )
						            .name("delete all arcs");
				function tracerArc(){
					let j=0,s="";
					j = JULIAN.DayOfYearGregorian(cs.year,dateArc.month,dateArc.day)
					s=dateArc.day+'/'+dateArc.month+'/'+cs.year
					cs.datesArcsDiurnes.push([s,TS.decSuns[j]])
					TracerArcsDiurnes()	
				}
				function effaceArcs(){
					// cs.datesArcsDiurnes=cs.datesArcsDiurnes.filter(
					// function(d){return((d[0]=='so.')||(d[0]=='eq.'))})	
					// TracerArcsDiurnes()	
					cs.datesArcsDiurnes=[[]]
					cs.equinoxeAndSolstices=false
					TracerArcsDiurnes()	
				}
						           
		folderArcs.add(cs,'equinoxeAndSolstices')
			.name('Equinoxe and solstices')
			.onChange(function(v){
				cs.equinoxeAndSolstices=v;
				if (v) {
					cs.datesArcsDiurnes.unshift(['solstice',base.toRad(-23.44)])
					cs.datesArcsDiurnes.unshift(['solstice',base.toRad( 23.44)])
					cs.datesArcsDiurnes.unshift(['equinoxe',0])
					}
					else{
						cs.datesArcsDiurnes=cs.datesArcsDiurnes.filter(function(d){
							return((d[0]!=='solstice')&&(d[0]!=='equinoxe'))})
						}
						//cs.datesArcsDiurnes=[];
				TracerArcsDiurnes()
				//console.log(cs.datesArcsDiurnes)
				})
			.listen();

		materialArcsDiurnes.color.setStyle(cs.colorequinoxeAndSolstice);
        folderArcs.addColor(cs, 'colorequinoxeAndSolstice')
						   .name("color ")
			               .onChange(function (e) {
                           materialArcsDiurnes.color = new THREE.Color(e);
                           cs.colorequinoxeAndSolstice=materialArcsDiurnes.color.getStyle()});
		
		const precisionA={"one minute":1,
						  " 5 min":5,
						  "10 min":15,
						  "30 min":30,
						  "60 min":60}
		folderArcs.add( cs,"precisionArcs", precisionA )
						.name('precision (min)')
						.onChange(TracerHeuresEtArcs())
						




///// Displays and animations

   
    const folderView = gui.addFolder( sp+'Displays and animations' );    	

        

		 folderView.add(cs,"axesESZ").name("East,South,Zenith")
                            .onChange(function(e){cs.axesESZ=e;axesESZHelper.visible=e});	

         folderView.add(cs,"voirTerre").name("Earth")
                            .onChange(function(e){
                            	cs.voirTerre=e;PlacerLaTerre()});	
		

	    const Vsun={ "0":0,
				"1sec  /sec":1,
				"1min  /sec":60,
				"10min /sec":600,
				"20min /sec":1200,
				"30min /sec":1800,
				"1h    /sec":3600}    
		folderView.add( cs,"vrotSun", Vsun )
                         .name('Rotation of sun')
                         .onChange(function(e){RotationSoleil(e)});
		
		folderView.add( cs,"vrotscene",0,10,1 )
                         .name('Rotation of the scene')  
						 .listen;


		///// DEVISE
        const folderDevise=   folderView.addFolder( 'Motto ...' ); 
            folderDevise.add(cs,'devise').name('text')
			    .onChange(function(v){
				cs.devise=v;
				cadranSolaireGroup.remove(meshDevise);
				EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9) });
			folderDevise.add(cs,'deviseSize',0,5,0.1).name('font size')
			    .onChange(function(v){
				cs.deviseSize=v;
				cadranSolaireGroup.remove(meshDevise);
				EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9) });
		
				folderView.addColor(cs,'background')
				          .name('wallpaper')
						  .onChange(function () {
							scene.background = new THREE.Color( cs.background )}) ;
								
            		
///// EXPORT
        const folderFiles = gui.addFolder( sp+'Export' ); 
		        const ButtonDownload= {functionDownload(){
					let e=cs.export
					if (e=="Sundial(JSON)") 
                               	  {saveString(JSON.stringify(cs,null,2),cs.nameFile+'.json')};
                	if (e=="Spreadsheet(CSV)")
                	              { initCSVtext();TracerHeuresEtArcs(); 
									saveString(CSVtext,cs.nameFile+'.csv')};
				 	if (e=="Ephemeris(CSV)")
								  {Ephemerid(cs.year);saveString(CSVephemerid,'Ephemerid'+cs.year+'.csv')};
					if (e=="3D(PLY)"){saveString(GenererPLY(),cs.nameFile+".PLY")};
					if (e=="3D(OBJ)"){saveString(GenererOBJ(),cs.nameFile+".OBJ")};
					if (e=="3D(STL)"){saveString(GenererSTL(),cs.nameFile+".STL")};
					if (e=="Scalable Vector Graphic(SVG)"){initSVGtext(cs.unitSVG); 
										EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9) ;
										TracerHeuresEtArcs()
										closeSVGtext();
						                saveString(SVGtext,cs.nameFile+'.svg')
										// w=window.open()
										// w.name="2D"
										// w.title="2D"
										// w.document.write(SVGtext);
										};
				    }}
		        folderFiles.add( ButtonDownload, 'functionDownload' ).name( 'Download' );	
                 
                folderFiles.add(cs,"nameFile").name("File name")

                folderFiles.add(cs,"export",
				["Sundial(JSON)","Spreadsheet(CSV)","3D(PLY)","3D(OBJ)","3D(STL)","Ephemeris(CSV)","Scalable Vector Graphic(SVG)"])
				    .name('Type of file');
					

				const absoluteUnits=   {
										"millimeters":"mm",
										"quarters-millimeters(0.25mm)":"Q",
										"centimeters":"cm",
										"inches (2.54cm)":"in",
										"pixels":"px",
										"auto":"auto"}
		        folderFiles.add( cs,"unitSVG", absoluteUnits )
                         .name('SVG units')
                         .onChange(function(e){});	
						 
		 const Button2D = {function2D(){
		                             	let w; // window
	                                	initSVGtext("auto"); 
										EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9) ;
										TracerHeuresEtArcs()
										closeSVGtext();										w=window.open()
										w.name=cs.nameFile
										w.document.write(`
					<html lang="en">
  			    	<head>
	                <title>CadsolOnLine  2D</title>
					</head>
					<body>
					`)				
										w.document.write(SVGtext)
										w.document.write(`
					</body>
					</html>
	                `)  }}	
	     gui.add( Button2D, 'function2D' ).name( '2D View' );		
					         

              //generateGeometry;   
			  
				scene.add( axeLocalisation );
				scene.add( cadranSolaireGroup);
				scene.add( axeMondeGroup );
				scene.add( earthGroup );
					


              const geometryCS = new THREE.BoxGeometry(1,1,1);	
			 

			  cadran = new THREE.Mesh( geometryCS, materialCS ); 	
              
			  //cadran = new THREE.Mesh( geometryCS, materialCST ); 
			  cadran.scale.x=cs.largeur; 
			  cadran.scale.y=cs.hauteur; 
			  cadran.scale.z=cs.epaisseur;
			  cadran.receiveShadow = true;
//console.log(geometryCS)
			      
               gnomon.position.x=cs.xgnomon; 
               gnomon.position.y=cs.ygnomon;
               gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 ; 
               gnomon.scale.y=cs.hgnomon;
               gnomon.scale.x=cs.egnomon;
			   gnomon.scale.z=cs.egnomon;
               gnomon.rotation.x = Math.PI*0.5;
               gnomon.castShadow = true; //default is false
			//    boutGnomon.position.x=gnomon.position.x
			//    boutGnomon.position.y=gnomon.position.y
			//    boutGnomon.position.z=cs.hgnomon
			 
			   //boutGnomon.scale.z=cs.egnomon;

			   cadranSolaireGroup.add( cadran );
			   cadranSolaireGroup.add( gnomon );
			  // cadranSolaireGroup.add( boutGnomon );

			   orienterAxedumonde()
			   PlacerLaTerre()
			   eulerCsGroup();
			   //eulerEarthGroup() 
			   
               PlacerLeSoleil();
		       PlacerLaTerre();
			   sphereEarth.rotation.y = -Math.PI*0.5;
              
 
               // helpers 
                const axesESZHelper = new THREE.AxesHelper( Math.max(cs.largeur,cs.hauteur,cs.epaisseur) );
                scene.add(axesESZHelper);
  				// 				const camHelper = new THREE.CameraHelper( light.shadow.camera );
				//              scene.add(camHelper) 
               EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9)

			   

			    const couleurMenu="#C8FAFF"
				for (let g = 0; g < gui.folders.length; g++){
									gui.folders[g].$title.style.color = couleurMenu
					              	gui.folders[g].close()
									// gui.folders[g].domElement.addEventListener("mouseover", function(){
									//         gui.folders[g].open()})
									// gui.folders[g].domElement.addEventListener("mouseout", function(){
									//         gui.folders[g].close()})
								}
				

				if (cs.typeCadran==SP) {folderGnomonBifilaireVertical.hide();
				                    	folderGnomonBifilaireGen.hide(); 
							        	ctlIncli.enable();   
										folderGnomonClassic.show()
										}
				if (cs.typeCadran==BF) {folderGnomonClassic.hide();
					                    folderGnomonBifilaireGen.hide();
							        	ctlIncli.disable();   
										folderGnomonBifilaireVertical.show()
										}
				if (cs.typeCadran==BFG) {folderGnomonClassic.hide();
										folderGnomonBifilaireVertical.hide();
							        	ctlIncli.enable();   
										folderGnomonBifilaireGen.show()
										}
			   //console.log(JSON.stringify(cs,null,2))	
			   scene.background = new THREE.Color( cs.background );					
               TracerHeuresEtArcs()
			   //console.log (window.location.href);

	//console.log (POLYHEDRA.Cube.vertex[0])	
	//ConstruirePolyHedre(POLYHEDRA.Cube);
   }//init

//  EXPORT---------------------------------------------------------------------------------

function GenererPLY(){
  const plyExporter = new PLYExporter();
  let s="";
  if(cs.typeCadran==BF){cadranSolaireGroup.remove(gnomon)}
  s= plyExporter.parse(cadranSolaireGroup)
  if(cs.typeCadran==BF){cadranSolaireGroup.add(gnomon)}
  return s
}

function GenererOBJ(){
  const objExporter = new OBJExporter();
  let s="";
  if(cs.typeCadran==BF){cadranSolaireGroup.remove(gnomon)}
  s= objExporter.parse(cadranSolaireGroup)
  if(cs.typeCadran==BF){cadranSolaireGroup.add(gnomon)}
  return s
}

function GenererSTL(){
  const stlExporter = new STLExporter();
  let s="";
  if(cs.typeCadran==BF){cadranSolaireGroup.remove(gnomon)}
  s= stlExporter.parse(cadranSolaireGroup,{binary: false })
  if(cs.typeCadran==BF){cadranSolaireGroup.add(gnomon)}
  return s
}




//--------------------------------------------------------------------------------------------------------
function RechercheParAdresse(v){
//  adrAPIOpenStreet :=
//       'http://api.opencagedata.com/geocode/v1/json?key=a110b502b29f4de9a47d95bc3b6c5e98&q='
//       + adresse + '&limit=1';
//  OpenStreetURL: String = 'https://www.openstreetmap.org/#map=15/%s/%s';

           // Create an XMLHttpRequest object
             const xhttp = new XMLHttpRequest();

           // Define a callback function
             xhttp.onload = function() {
				  // Here you can use the Data
					 let myObj = JSON.parse(this.responseText);
					 //console.log(JSON.stringify(myObj,null,2));
					 if (myObj.total_results>0) {           
					  cs.adresse=myObj.results[0].formatted;          
					  cs.lati=myObj.results[0].geometry.lat;
					  cs.longi=myObj.results[0].geometry.lng;
					  cs.urlOpenStreet=myObj.results[0].annotations.OSM.url;
					  cs.timezone=myObj.results[0].annotations.timezone.name;
					  cs.offset_sec=myObj.results[0].annotations.timezone.offset_sec;
					  cs.offset_string=myObj.results[0].annotations.timezone.offset_string;
					  cs.now_in_dst=myObj.results[0].annotations.timezone.now_in_dst;				  

					//window.open(cs.urlOpenStreet, "_blank", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
                      }else {alert('no result for '+v)}
               console.log(cs.urlOpenStreet);

             }
          // Send a request
		  try {xhttp.open("GET", "https://api.opencagedata.com/geocode/v1/json?key=a110b502b29f4de9a47d95bc3b6c5e98&q="+ v + "&limit=1",false);
			 xhttp.send();
			  
		  } catch (error) {
			 alert('no connection') 
		  }
			 
           }

//-------------------------------------------------------------------------------------------------------------

function orienterAxedumonde() {
               
               axeMonde.setDirection( new THREE.Vector3( 0, Math.sin(cs.lati*Math.PI/180),
                                                           -Math.cos(cs.lati*Math.PI/180)));
               axeMonde.setLength(Math.max(cs.largeur,cs.hauteur,cs.epaisseur),30,10);
            //   helperLight.update()
            //   axeMonde.visible=cs.voirTerre;
			  
			   axeMonde.visible=false;

             
           }

//--------------------------------------------------------------------------------------
 function PlacerLeSoleil(){
           	   const k=2*Math.max(cs.largeur,cs.hauteur,cs.epaisseur);
			   const v3=new THREE.Vector3();
			   let h,min,sec,y,m,d,dec,eqt,date,sdate,hsol;

                h=Math.floor(cs.hsol);
				min=Math.floor((cs.hsol-h)*60); 
				sec=Math.floor((cs.hsol-h-min/60)*3600);
		        //console.log(cs.hsol,sec)
				h = (h < 10) ? "0" + h : h;
                min = (min < 10) ? "0" + min : min;
				sec = (sec < 10) ? "0" + sec: sec;

				date=JULIAN.JDToCalendarGregorian(TS.jdates[cs.dayofYear-1]);
				//jde= JULIAN.CalendarGregorianToJD(cs.year, date.month, date.day); 
				dec=base.toDeg(TS.decSuns[cs.dayofYear-1]);

				dec=Math.round(dec*1000)/1000;
				//cs.decsol=dec;
				eqt=Math.round(SEXA.secFromHourAngle(TS.eqtimes[cs.dayofYear-1]));

				hsol=cs.hsol + eqt/3600 +(cs.longi/15 - cs.offset_sec/3600); //correction de l'heure
				d=Math.floor(date.day);m=date.month;y=date.month;
				d = (d < 10) ? "0" + d : d;
                m = (m < 10) ? "0" + m : m;
		        sdate=d+"/"+m+"/"+date.year;  //date JJ/MM/YYYY
				
	           sphereSun.position.z=k*Math.cos(base.toRad(dec))*Math.cos(base.toRad(-(hsol-12)*15));
			   sphereSun.position.x=k*Math.cos(base.toRad(dec))*Math.sin(base.toRad(-(hsol-12)*15));
			   sphereSun.position.y=k*Math.sin(base.toRad(dec));
	        
               sphereSun.getWorldPosition ( v3 );
			   light.position.set( v3.x,v3.y,v3.z ).normalize();
			   light.castShadow =(v3.y>0) 
		    
			   labeltime.innerHTML=h + ":" + min+':'+sec +"  "+sdate+ " dec:"+dec.toFixed(3)+"Â°  eqt:"+eqt+'s'
			    //labeldeceqt.innerHTML="dec:"+dec.toFixed(3)+"Â°  eqt:"+eqt+'s'
                //  helperLight.update()
           }

function myTimerSun() {
            cs.hsol+=cs.vrotSun/360000;
			if (cs.hsol>24) {cs.hsol=0} ;
			PlacerLeSoleil()
		    }
let temporisation=null;	
function RotationSoleil(e){
	      window.clearInterval(temporisation);
		  if (e>0) { temporisation = window.setInterval(myTimerSun,10)}; //    1/100 sec
  		}

// Terre ---------------------------------------------------------------------------------------------------
function PlacerLaTerre( ){
	            let r,l;
			    r=cs.hauteur;
	            sphereEarth.scale.x=r;sphereEarth.scale.y=r;sphereEarth.scale.z=r;
                earthGroup.position.x=0;
			    earthGroup.position.y=-(cs.hauteur/2+r)*1.2;
			    earthGroup.position.z=0;
			    earthGroup.rotation.x = -base.toRad(90-cs.lati); 
			    earthGroup.rotation.y = -base.toRad(cs.longi);
                earthGroup.visible=cs.voirTerre;			    
			    axeTerre.setLength(r*1.5,r*1.5*0.1,r*1.5*0.02);
			    l=-earthGroup.position.y-r;
			    axeLocalisation.setLength(l,0.1*l,0.02*l)
			    axeLocalisation.visible=cs.voirTerre;

			//	console.log(renderer.info)
			
}
			
//---------------------------------------------------------------------------------------------------------

function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );

			}


function animate() {

				requestAnimationFrame( animate );
               
                if (cs.vrotscene>0){scene.rotation.y +=0.001*cs.vrotscene}else{scene.rotation.y=0};

				render();
				stats.update();    
			

			}

			//

function render() {
				
				    renderer.render( scene,camera );

			}
	
// function ConstruirePolyHedre(POLY){
// //console.log (POLYHEDRA.Cube.vertex)
// const geometry = new THREE.BufferGeometry();
// // create a simple square shape. We duplicate the top left and bottom right
// // vertices because each vertex needs to appear once per triangle.
// // const vertices = new Float32Array( [
// 	// -1.0, -1.0,  1.0,
// 	//  1.0, -1.0,  1.0,
// 	//  1.0,  1.0,  1.0,
// // 
// 	//  1.0,  1.0,  1.0,
// 	// -1.0,  1.0,  1.0,
// 	// -1.0, -1.0,  1.0
// // ] );

// // itemSize = 3 because there are 3 values (components) per vertex

// const vertices = []
// console.log(POLY.face)
// for ( let f = 0; f < POLY.face.length; f ++ ) {
// 	const face=POLY.face[f]
// 	console.log(face)
// 	for ( let v = 0; v < face.length; v ++ )
// 	     {  
// 			for(let j=0;j<3;j++)
// 			{vertices.push( POLY.vertex[ face[v]][j]*100) } 
// 		 }
//     }

// console.log(vertices)
// geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
// const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
// const mesh = new THREE.Mesh( geometry, material );
// cadranSolaireGroup.visible=false

// scene.add(mesh)
// }
      
</script>      



</body>

</html>