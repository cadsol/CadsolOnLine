<!DOCTYPE html>
<html lang="en">


<head>
	<title>CadsolOnLine 3D</title>
	<link rel="icon" type="image/x-icon" href="./favicon.ico">
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0">
<!--  FICHIER CSS---------------------------------------------------------------------------------------------------------- -->
	<link type="text/css" rel="stylesheet" href="./main2023-04-10.css">
<!--  FICHIER CSS------------------------------------------------------------------------------------------------------------->
</head>

<body>
    <script src="./parser.js"></script>
	<div id="container">
		<div id="info">
			<h1>CadSolOnLine</h1>
			<div id="ver">" " </div>
			<!-- Calculation of sundials on line</br> -->
			by JL.Astre and Y.Massé<br>
			Help: <a href="https://cadsolonline.web-pages.fr" target="_blank">cadsolonline.web-pages.fr </a> <br>
			Library 3D: <a href="https://threejs.org" target="_blank" >Three.js</a> <br>
			Astronomical library: 
			<a href="https://en.wikipedia.org/wiki/Jean_Meeus" target="_blank" rel="noopener">Jean Meeus & </a>
			<a href="https://en.wikipedia.org/wiki/Sonia_Keys" target="_blank" rel="noopener">Sonia Keys</a>  <br>
            <!-- <a href="https://github.com/commenthol/astronomia" target="_blank" rel="noopener">commenthol</a></br>--> 
			<p>
				<img src="./imageMoret.jpg" alt="Image" style="max-width:100%;height:auto">
			</p>	
			<label for="jsoninput"> > Open the Sundial ...</label>
			</br></br>
			<div id="menu"> </div>
			
			<input type="file" id="jsoninput" accept=".json">
			

			<script>
				const docinputjson = document.getElementById('jsoninput');
				docinputjson.style.opacity = 0;
			</script>

		</div>

		<!-- <input type="range" min="1" max="100" value="50" class="slider" id="myRange">  -->
		<div id="time"> </div>

	</div>

	<!-- <div id="deceqt"> </div> -->

	<script type="module">
		//document.body.style.cursor = "wait"
		document.addEventListener("readystatechange", function(evt){console.log(document.readyState)})
		import * as THREE from '../build/three.module.js';  //version 149
		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/lil-gui.module.min.js';     //version 0.17.0

		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { apparentEquatorial } from '../astronomia-master/src/solar.js';
		import * as JULIAN from '../astronomia-master/src/julian.js';
		import * as base from '../astronomia-master/src/base.js';
		//   import * as EQTIME from '../astronomia-master/src/eqtime.js';	
		import * as SEXA from '../astronomia-master/src/sexagesimal.js';

		import { FontLoader } from './jsm/loaders/FontLoader.js';
		import { TextGeometry } from './jsm/geometries/TextGeometry.js';
		//import * as BUFGEOUTILS from './jsm/utils/BufferGeometryUtils.js';
		import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';
		//import { DDSLoader } from './jsm/loaders/DDSLoader.js';
		import { PLYExporter } from './jsm/exporters/PLYExporter.js';
		//import { GLTFExporter } from './jsm/exporters/GLTFExporter.js';
		import { OBJExporter } from './jsm/exporters/OBJExporter.js';
		import { STLExporter } from './jsm/exporters/STLExporter.js';
		import { PLYLoader } from './jsm/loaders/PLYLoader.js';
		import { OBJLoader } from './jsm/loaders/OBJLoader.js';
		import { ParametricGeometry } from './jsm/geometries/ParametricGeometry.js';



		document.getElementById("jsoninput").addEventListener('change', function () { loadJsonFile() });

		
		

		const HS = "solar",
			HLSA = "legal (summer autumn)", HLWS = "legal (winter spring)", 
			HA = "Antique",
			HB = 'babylonic', HI = "italic",
			HSDSA = "Sidereals (summer, autumn)", HSDWS = "Sidereals (winter, spring)";

// -----------------------------------COLVARS--------------------------------------------------------------------------------------------
		import { SP, BF, BFG, ANL,RTS, cs, TableSol, RechercheParAdresse, getLocation, eclair,HTLM } from './colvars2023-04-25.js';
// --------------------------------------------------------------------------------------------------------------------------------------	

		cs.version = "2023-04-16"
        let dateJour = new Date()
		//cs.hsol=dateJour.getHours()
		cs.year=dateJour.getFullYear()
		//console.log(dateJour)

		let CSVtext = "", SVGtext = "", CSVephemerid = ""
		let zFuncxy

		let container, stats, buttonNewSundial;
		let camera, scene, renderer;
		container = document.getElementById('container');
		
		// camera

		camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 5, 10000);
		camera.position.set(2000, 2000, 2000);
		//camera.position.set( 0, 0, 2000 );

		// scene
		scene = new THREE.Scene();
		//scene.background= new THREE.Color(cs.background)
		//console.log(localStorage.getItem("BackGround"))
		//scene.background = new THREE.Color(localStorage.getItem("BackGround"))
	

		const light = new THREE.DirectionalLight(0xffffff,1);
		light.position.set(0, 1, 1).normalize();
        let lineRay

		const ambientLight = new THREE.AmbientLight(0x252525,0.75); // soft white light
		//const ambientLight = new THREE.LightProbe(); 
		scene.add(ambientLight);

		//Set up shadow properties for the light
		light.shadow.mapSize.width = 2048 * 4; // default
		light.shadow.mapSize.height = 2048 * 4; // default
		light.shadow.camera.near = -1000; // default
		light.shadow.camera.far = 1000; // default
		light.shadow.camera.top = 1000;
		light.shadow.camera.bottom = -1000;
		light.shadow.camera.right = 1000;
		light.shadow.camera.left = -1000;

	
		light.castShadow = true; // default false
		scene.add(light);
		//const helperLight = new THREE.DirectionalLightHelper( light, 100 );
		//scene.add( helperLight );

		// renderer
		//THREE.ColorManagement.legacyMode = false;
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		//renderer.outputEncoding = THREE.RGBEncoding;
		renderer.toneMapping=THREE.LinearToneMapping;
		renderer.shadowMap.enabled = true;
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
		renderer.shadowMap.type = THREE.PCFShadowMap 
		
		renderer.toneMappingExposure = 1;
		container.appendChild(renderer.domElement);

		// renderer.setPixelRatio( window.devicePixelRatio );
		// renderer.outputEncoding = THREE.sRGBEncoding;

		// stats
		stats = new Stats();
		container.appendChild(stats.dom);

		// OrbitControls
		const controls = new OrbitControls(camera, renderer.domElement);
		controls.minDistance = 1;
		controls.maxDistance = 10000;

		//addEventListener
		window.addEventListener('resize', onWindowResize);
		controls.addEventListener('change', render);

		//Button New Sundial
		buttonNewSundial = document.createElement('button');
		buttonNewSundial.innerHTML = 'New Sundial';
		const menu = document.getElementById('menu');
		menu.appendChild(buttonNewSundial);
		const NFexemple = location.hash.substring(1)
		buttonNewSundial.addEventListener("click", function () {
			if (NFexemple.length > 0) {NouveauCadran=false} else {NouveauCadran=true}
			Info(NFexemple)
			run() });


		//
		const labeltime = document.getElementById('time');
		labeltime.innerHTML = 'Time';
		// const labeldeceqt = document.getElementById( 'deceqt' );
		// labeldeceqt.innerHTML = 'deceqt';

		const version = document.getElementById('ver');
		version.innerHTML = "Version: " + cs.version

		let cadranSolaireGroup, axeMondeGroup, earthGroup;
		let cadran, gnomon,gnomonTore, meshDevise, stylePolaire, sousStylaire, styleAnalem,styleTorique, filHorizontal, filVertical, pilierH1, pilierH2, pilierH3, pilierH4;
		let heuresSolairesGroup, heuresLegalesGroupSA, heuresLegalesGroupWS, heuresAntiquesGroup, arcsDiurnesGroup;
		let heuresBabyloniquesGroup, heuresItaliquesGroup, heuresSDSAgroup, heuresSDWSgroup,groupAxes;
		let heuresSolairesListeMesh, heuresLegalesListeMeshSA, heuresLegalesListeMeshWS, heuresAntiquesListeMesh,
			heuresBabyloniquesListeMesh,
			heuresItaliquesListeMesh,
			heuresSDSAListeMesh, heuresSDWSListeMesh,
			arcsDiurnesListeMesh,
			labelAxesListeMesh;

		let analemGroup, analemListeMesh;   // +++
		let NouveauCadran=false

		cadranSolaireGroup = new THREE.Group();
		//cadranSolaireGroup.castShadow=true;
		heuresSolairesGroup = new THREE.Group();
		heuresLegalesGroupSA = new THREE.Group();
		heuresLegalesGroupWS = new THREE.Group();
		heuresAntiquesGroup = new THREE.Group();
		heuresBabyloniquesGroup = new THREE.Group();
		heuresItaliquesGroup = new THREE.Group();
		heuresSDSAgroup = new THREE.Group();
		heuresSDWSgroup = new THREE.Group();
		arcsDiurnesGroup = new THREE.Group();
		analemGroup = new THREE.Group();///+++
		groupAxes = new THREE.Group();

		heuresSolairesListeMesh = [];
		heuresLegalesListeMeshSA = [];
		heuresLegalesListeMeshWS = [];
		heuresAntiquesListeMesh = [];
		heuresBabyloniquesListeMesh = [];
		heuresItaliquesListeMesh = [];
		heuresSDSAListeMesh = [];
		heuresSDWSListeMesh = [];

		arcsDiurnesListeMesh = [];
		labelAxesListeMesh = [];
		analemListeMesh = [];//+++

		//const texture = new THREE.TextureLoader().load( 'metaltexture.jpg' );
		// const materialCST = new THREE.MeshBasicMaterial( { map: texture } );
		const textureAcier = new THREE.TextureLoader().load('metaltexture.jpg')
		textureAcier.name='steel'
		const textureCuivre = new THREE.TextureLoader().load('metall001-new-tileable.png');
		textureCuivre.name='copper'
		const textureFruits = new THREE.TextureLoader().load('fruits.jpg')
		textureFruits.name='fruits'
		const textureAsphalt = new THREE.TextureLoader().load('asphalt.jpg')
		textureAsphalt.name='asphalt'
		const textureBois = new THREE.TextureLoader().load('./textures/hardwood2_diffuse.jpg');
		textureBois.name='wood'
		const textureEau = new THREE.TextureLoader().load('./textures/waternormals.jpg');
		textureEau.name='water'  
		const texturePierreVerte = new THREE.TextureLoader().load('./greenStone.jpg');
		texturePierreVerte.name='green stone'  
		

		const choixTextures = { 'none':null,'steel': textureAcier, 'copper': textureCuivre,'water':textureEau, 
			                        'asphalt': textureAsphalt,'wood':textureBois,'fruits': textureFruits,'green stone':texturePierreVerte}
		//let texture = textureAcier
		
		const optionsMaterial = { roughness: 0.5, metalness: 0.5, transparent: true, opacity: 1, side: THREE.DoubleSide, map: null }
		const materialHeuresSolaires = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresLegalesSA = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresLegalesWS = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresAntiques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresBabyloniques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresItaliques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresSDSA = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresSDWS = new THREE.MeshStandardMaterial(optionsMaterial);

		const materialAnalem = new THREE.MeshStandardMaterial(optionsMaterial);// +++

		const materialArcsDiurnes = new THREE.MeshStandardMaterial(optionsMaterial);

		const materialAxeX= new THREE.MeshStandardMaterial({color:0xff00ff})
		const materialAxeY= new THREE.MeshStandardMaterial({color:0xffff00})
		const materialAxeZ= new THREE.MeshStandardMaterial({color:0x00ffff})


		const materialCS = new THREE.MeshStandardMaterial(
			{ transparent: true, opacity: 0.8, roughness: 0.5,side:THREE.FrontSide/*,shadowSide:THREE.BackSide*/ });
		// const materialScaphe = new THREE.MeshStandardMaterial(
		// 	{ transparent: true, opacity: 0.8, roughness: 0.5, map: textureAcier,side:THREE.DoubleSide/*,shadowSide:THREE.BackSide */ });
		// *********************************************************************************************************************************
		
		function Info(text){
			document.getElementById("info").innerHTML = text;
		}

        
		function CercleSetting(h,e, spline, nsteps) {		
				const pipeSplineCRC = new THREE.CatmullRomCurve3(spline, false, 'chordal', 1)//, 'chordal', 1);
				const recShape = new THREE.Shape()
					.moveTo(h,e)
					.lineTo(-h,e)
					.lineTo(-h,-e)
					.lineTo(h,-e)
					.lineTo(h,e)
				const Settings = {
					steps: nsteps,
					bevelEnabled: false,
					extrudePath: pipeSplineCRC
				};
				return { forme: recShape, setting: Settings }
			}
		const CerclePath = []
				for (let index = 0; index < 101; index++) {
					const a = index * Math.PI / 100
					const r=0.5
					const p3 = new THREE.Vector3( r* Math.cos(a), 0, -r * Math.sin(a))
					CerclePath.push(p3)
				}
		const Cercle=CercleSetting (0.5,0.025,CerclePath,100)
		//console.log(CerclePath)
		const  EquatorialGeometry = new THREE.ExtrudeGeometry(Cercle.forme,Cercle.setting); 

		const geometryScaphe = new THREE.SphereGeometry(0.5,64,64,Math.PI,Math.PI );
		//radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float
		const geometryCSbox = new THREE.BoxGeometry(1, 1, 1);
	    const geometryCScyl = new THREE.CylinderGeometry(0.5,0.5, 1,64,64);
		const geometryCSsph = new THREE.SphereGeometry(0.5,64,64);
		const geometryCScone = new THREE.ConeGeometry(0.5,1,64,64);
		
		// ***********************************************************************************************************************************
		const cadranBox = new THREE.Mesh(geometryCSbox, materialCS);
		const cadranCyl = new THREE.Mesh(geometryCScyl, materialCS);
		const cadranSph = new THREE.Mesh(geometryCSsph, materialCS);
		const cadranCone = new THREE.Mesh(geometryCScone, materialCS);
		const cadranEquatorial=  new THREE.Mesh(EquatorialGeometry, materialCS);
		const cadranScaphe=  new THREE.Mesh(geometryScaphe, materialCS);

		cadran=cadranBox.clone()

		//SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)
		

		const materialGnomon = new THREE.MeshStandardMaterial(
			{ transparent: true, opacity: 1, roughness: 0.1, metalness: 0.5, side: THREE.DoubleSide, color: 0xffffff, map: textureAcier  });
		const geometryGnomon = new THREE.CylinderGeometry(1, 1, 1, 16);
		gnomon = new THREE.Mesh(geometryGnomon, materialGnomon);
		//const geometryTore = new THREE.TorusGeometry();
		//gnomonTore= new THREE.Mesh(geometryTore, materialGnomon);

		// const geometryboutGnomon= new THREE.SphereGeometry( 1, 32,32 );   
		// const boutGnomon=new THREE.Mesh( geometryboutGnomon, materialGnomon );
		//const debutGnomon=new THREE.Mesh( geometryboutGnomon, materialGnomon );
		//gnomon.add(boutGnomon)
		//gnomon.add(debutGnomon)
		// boutGnomon.visible=true
		//materialCS.depthWrite=false; 
		//materialHeuresSolaires.tramage=true; 
		//materialHeuresSolaires.precision="highp"

		// Axe de rotation de la terre
		const axeMonde = new THREE.ArrowHelper(
			new THREE.Vector3(0, Math.sin(cs.lati * Math.PI / 180), -Math.cos(cs.lati * Math.PI / 180)),
			new THREE.Vector3(0, 0, 0),
			600,
			0xffff00, 30, 15);


		axeMondeGroup = new THREE.Group();
		axeMondeGroup.add(axeMonde);
		axeMonde.visible = false;

		const textureLoader = new THREE.TextureLoader();

		const earthGeometry = new THREE.SphereGeometry(1, 32, 32);
		const earthMaterial = new THREE.MeshPhongMaterial({
			specular: 0x333333,
			emissive: "rgb(5,5,5)",
			shininess: 5,
			map: textureLoader.load('./earth_pm_2048.jpg'),
			specularMap: textureLoader.load('textures/planets/earth_specular_2048.jpg'),
			normalMap: textureLoader.load('textures/planets/earth_normal_2048.jpg'),
			normalScale: new THREE.Vector2(1, 1)
		});
		earthMaterial.tranparent = true;
		earthMaterial.opacity = 0.5;
		const sphereEarth = new THREE.Mesh(earthGeometry, earthMaterial);
		earthGroup = new THREE.Group();
		earthGroup.add(sphereEarth);

		// clouds

const materialClouds = new THREE.MeshLambertMaterial( {
map: textureLoader.load( 'textures/planets/earth_clouds_1024.png' ),
//map: textureLoader.load( 'textures/planets/earth_ligths_1024.png' ),
transparent: true
} );
const cloudsScale = 1.005
const meshClouds = new THREE.Mesh( earthGeometry, materialClouds );
earthGroup.add( meshClouds );

		//sun
		const geometrySun = new THREE.SphereGeometry(15, 32, 16);
		const materialSun = new THREE.MeshPhongMaterial({
			//color: 0xffff00, 
			//specular: 0x333333,
			emissive: "rgb(100,100,5)",
			shininess: 5,
			map: textureLoader.load('./sun.jpg')
		});
		const sphereSun = new THREE.Mesh(geometrySun, materialSun);
		axeMondeGroup.add(sphereSun);
		sphereSun.parent = axeMonde;
		//const raySun= new THREE.Ray()
		const rayCaster = new THREE.Raycaster()


		const axeTerre = new THREE.ArrowHelper(
			new THREE.Vector3(1, 1, 1),
			new THREE.Vector3(0, 0, 0),
			600,
			0xffffff, 30, 15);
		earthGroup.add(axeTerre);

	// 	scene.background = new THREE.CubeTextureLoader()
	// .setPath( './images/' )\\ds415\web\CadsolOnLine\sources\textures\cube\MilkyWay\dark-s_nx.jpg
	// .load( [
	// 	'1.jpg',
	// 	'2.jpg',
	// 	'3.jpg',
	// 	'4.jpg',
	// 	'5.jpg',
	// 	'6.jpg'
	// ] );

	// scene.background = new THREE.CubeTextureLoader()
	// .setPath( './textures/cube/MilkyWay/' ) //\\ds415\web\CadsolOnLine\sources\textures\cube\MilkyWay\dark-s_nx.jpg
	// .load( [
	// 	'dark-s_nx.jpg',
	// 	'dark-s_ny.jpg',
	// 	'dark-s_nz.jpg',
	// 	'dark-s_px.jpg',
	// 	'dark-s_py.jpg',
	// 	'dark-s_pz.jpg'
	// ] );



		const axeLocalisation = new THREE.ArrowHelper(
			new THREE.Vector3(0, -1, 0),
			new THREE.Vector3(0, 0, 0),
			600,
			0x00ff00, 20, 15);

		const axeX = new THREE.ArrowHelper(
			new THREE.Vector3(1,0,0),
			new THREE.Vector3(0, 0, 0),
			800,
			0xff00ff, 20, 5);
		const axeY = new THREE.ArrowHelper(
			new THREE.Vector3(0,1,0),
			new THREE.Vector3(0, 0, 0),
			800,
			0xffff00, 20, 5);
		const axeZ = new THREE.ArrowHelper(
			new THREE.Vector3(0,0,1),
			new THREE.Vector3(0, 0, 0),
			800,
			0x00ffff, 20, 5);

		// helpers 
		const axesESZHelper = new THREE.AxesHelper(800);
		scene.add(axesESZHelper);
	


		let TS = TableSol(cs.year)
		//  const dd=JULIAN.JDToCalendarGregorian(TS.solJuin)     
		//    console.log((JULIAN.JDToCalendarGregorian(TS.solJuin).month))
		//    console.log(JULIAN.JDToDate(TS.solJuin))
		//    console.log(Math.floor(dd.day)+"/"+dd.month+"/"+dd.day)

		let fontDevise, fontText;
		loadFontDevise();

		//let ligneDate = "";

		const plyloader = new PLYLoader();
		const objloader= new OBJLoader()

		

		//console.log(NFexemple)
		if (NFexemple.length > 0) {
			openSundial(NFexemple)
			buttonNewSundial.innerHTML = NFexemple;
		}

		//document.body.style.cursor = "auto"
		
		window.addEventListener("keypress",kPress)


		function kPress(evt){
			if ((evt.ctrlKey)&&(evt.keyCode==10)){cs.autoCloseMenu= !cs.autoCloseMenu}
			}
		

		///////////////////////////////////////////////////////////////////////////////////////////////			  

		function openSundial(NFexemple) {
			let csl
			let request = new XMLHttpRequest();
			request.open('GET', './Samples/' + NFexemple);
			request.responseType = 'text';
			request.send();
			request.onload = function () {
				//console.log(request.response);
				cadranSolaireGroup.clear()
				try { csl = JSON.parse(request.response) }
				catch (e) { console.error("Parsing error:", e) }
				//console.log(JSON.stringify(csl,null,2));
				for (var k in csl) { cs[k] = csl[k] }
				//console.log(JSON.stringify(cs,null,2));
				TS = TableSol(cs.year);
				NouveauCadran=false
			};

			

		}

		//-----------------------------------------------------------------------------------------------------				          
		function run() {
		    document.body.style.cursor = "wait"
			init();

			animate();
			document.body.style.cursor = "default"
		}

		function ligneCSV(texte, x0, y0, z0) {
				const s ="  "+ cs.separateurCSV+"  "
				const nd=3
				const xg = x0 - cs.xgnomon
				const yg = y0 - cs.ygnomon
				if (cs.typeCadran == RTS) {
					CSVtext += texte + s + x0.toFixed(nd) + s + y0.toFixed(nd) + s + z0.toFixed(nd) + s + "   " + s + xg.toFixed(nd) + s + yg.toFixed(nd) + "\n"
				} else {
					CSVtext += texte + s + x0.toFixed(nd) + s + y0.toFixed(nd) + s +         "   " + s + "   " + s + xg.toFixed(nd) + s + yg.toFixed(nd) + "\n"
				}
			}

		function initCSVtext() {
			let s=cs.separateurCSV
			CSVtext = "CadsolOnLine      " + s + "   XO   " + s + "  YO  " +s+"   ZO   "+s+"       "+s+"  XG  "+s+"  YG   \n\n";
			CSVtext += " Version: " + cs.version + "\n\n"
			CSVtext +=" XO YO  ZO  origin : center of the sundial \n"
			CSVtext +=" XG YG      origin : foot of the gnomon \n"
			CSVtext += "\n\n";
			CSVtext += "Sundial: "+cs.nameFile
			CSVtext += "\n\n";
			CSVtext+="Type of sundial : " +cs.typeCadran+"\n"
			if(cs.typeCadran==RTS){CSVtext+="Form : "+cs.typeForme}
			CSVtext += "\n\n";

		}


		function initSVGtext(unit) {
			SVGtext =
				`<?xml version="1.0" standalone="no"?>
<svg 
`
			if (unit == "auto") { SVGtext += `width="100%" height="auto"` }
			else { SVGtext += `width="${cs.largeur.toString() + unit}" height="${cs.hauteur.toString() + unit}"` }

			SVGtext += ` viewBox="0 0 ${cs.largeur.toString()} ${cs.hauteur.toString()}" preserveAspectRatio="xMinYMin meet"
  xmlns="http://www.w3.org/2000/svg">

  <desc> 

  CadsolOnLine  ${cs.version}
  
  </desc>

  <rect x="0" y="0" width="${cs.largeur.toString()}" height="${cs.hauteur.toString()}" 
   fill="${cs.colorCS}" stroke="black" stroke-width="1px" />
 
  
`

			// <rect x="0" y="0" width="${cs.largeur.toString()}" height="${cs.hauteur.toString()}"
			//         fill="none" stroke="black" stroke-width="1"/>
			//   width="${cs.largeur.toString()+cs.unitSVG}" height="${cs.hauteur.toString()+cs.unitSVG}"
			//height="auto"
		}

		function closeSVGtext() {
			SVGtext += '</svg>';
			// console.log(SVGtext)
		}





		//----------------------------------------------------------------------------
		function loadFontDevise() {
			const loader = new FontLoader();
			loader.load('./fonts/helvetiker_regular.typeface.json', function (response) {
				fontDevise = response
			});
			loader.load('./fonts/helvetiker_regular.typeface.json', function (response) {
				fontText = response
			});

		}

		// Ecritures------------------------------------------------------------  
		function EcrireDevise(texte, x, y) {
			if (cs.deviseSize == 0) return;
			const fontGeometry = new TextGeometry(texte, {
				font: fontDevise,
				size: 10 * cs.deviseSize,             //ajuster sur largeur
				height: 2 * cs.deviseSize,           //ajuster sur largeur
				curveSegments: 4,
				bevelEnabled: true,
				bevelThickness: 0.5 * cs.deviseSize, //ajuster sur largeur
				bevelSize: 0.5 * cs.deviseSize,      //ajuster sur largeur
				bevelOffset: 0,
				bevelSegments: 1
			});

			if (typeof (meshDevise) !== "undefined") { cadranSolaireGroup.remove(meshDevise) };
			meshDevise = new THREE.Mesh(fontGeometry, materialGnomon);
			cadranSolaireGroup.add(meshDevise);
			meshDevise.position.x = x;
			meshDevise.position.y = y;
			meshDevise.position.z = cs.epaisseur / 2

			if (SVGtext.length > 0) {
				//	${materialGnomon.color.getStyle()}
				x = x + cs.largeur / 2; y = -y + cs.hauteur / 2;
				SVGtext += `<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.deviseSize * 10).toString()}" font-family='Courier New'  stroke="black" > ${cs.devise}</text>
           `
			}
		}

		function EcrireTexte(texte, x, y,z, material, group, listeMesh, gauche = false) {
			if (cs.hoursTextSize == 0) return;

			let mesh
			const fontGeometry = new TextGeometry(texte, {
				font: fontText,
				size: 7 * cs.hoursTextSize,             //ajuster sur largeur
				height: 1 * cs.hoursTextSize,           //ajuster sur largeur
				curveSegments: 4,
				bevelEnabled: true,
				bevelThickness: 0.25 * cs.hoursTextSize, //ajuster sur largeur
				bevelSize: 0.25 * cs.hoursTextSize,      //ajuster sur largeur
				bevelOffset: 0,
				bevelSegments: 1
			});


			mesh = new THREE.Mesh(fontGeometry, material);

			group.add(mesh);
			listeMesh.push(mesh);
			if (gauche) { x = x - (texte.length - 1) * 7 * cs.hoursTextSize }//else{x=x+7*cs.hoursTextSize}
			if ((x + 7 * cs.hoursTextSize) > (cs.largeur / 2 - 5)) { x -= 14 * cs.hoursTextSize }
			if ((y + 7 * cs.hoursTextSize) > (cs.hauteur / 2 - 5)) { y -= 14 * cs.hoursTextSize }
			mesh.position.x = x;
			mesh.position.y = y;
			mesh.position.z = z;

			if (SVGtext.length > 0) {
				x = x + cs.largeur / 2; y = -y + cs.hauteur / 2;
				//if (gauche) {texte=texte+"  "}else{texte="  "+texte}
				SVGtext += `<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.hoursTextSize * 10).toString()}" font-family="Courier New" stroke="${material.color.getStyle()}"> ${texte}</text>
           `
			}

		}


		//-----------------------------------------------------------------------------------------------------
		function Ephemerid(year) {
			let d, s;

			CSVephemerid = " DATE" + cs.separateurCSV + "TIME EQUATION (s)" + cs.separateurCSV + "SUN DECLINATION (°)" + cs.separateurCSV + "Julian Day" + "\n"
			CSVephemerid += " \n";
			CSVephemerid += "Ephemerids year:  " + cs.year + "\n\n";
			CSVephemerid += "CadsolOnLine  Version:" + cs.version + "\n\n";
			CSVephemerid += "(c) Jean Meeus \n* Chapter 28 Equation of time \n* Chapter 25  Solar Coordinates ...\n\n";
			CSVephemerid += " \n";
			//   const TS=TableSol(cs.year);
			for (let i = 0; i < TS.decSuns.length; i++) {
				d = JULIAN.JDToCalendarGregorian(TS.jdates[i]);
				CSVephemerid += d.day + "/" + d.month + "/" + d.year + cs.separateurCSV;  //date JJ/MM/YYYY
				s = Math.round(SEXA.secFromHourAngle(TS.eqtimes[i]));	// equation du temps en secondes	
				CSVephemerid += s.toFixed(0) + '     ' + cs.separateurCSV;
				s = base.toDeg(TS.decSuns[i]);  //dec soleil en degres
				CSVephemerid += s.toFixed(4);
				if (i == TS.jdecSunMin) { CSVephemerid += "  Winter Solstice " }
				if (i == TS.jdecSunMax) { CSVephemerid += "  Summer Solstice " }
				CSVephemerid += cs.separateurCSV
				CSVephemerid += TS.jdates[i];
				CSVephemerid += "\n"
			}
		}

		//------------------------------------------------------------------------------------------------------------
		function TracerHeuresEtArcs() {		
			document.body.style.cursor = 'wait'
			initCSVtext()
			if (cs.typeCadran == ANL) {
				TracerAnalem();
				EcrirelesDates()
			} else {
				if (cs.heuresSolaires) { TracerHeuresSolaires() }
				if (cs.heuresLegalesWinterSpring) { TracerHeuresLegalesWS() }
				if (cs.heuresLegalesSummerAutums) { TracerHeuresLegalesSA() }
				if (cs.heuresAntiques) { TracerHeuresAntiques() }
				if (cs.heuresBabyloniques) { TracerHeuresBabyloniques() }
				if (cs.heuresItaliques) { TracerHeuresItaliques() }
				if (cs.heuresSideralesSA) { TracerHeuresSDSA() }
				if (cs.heuresSideralesWS) { TracerHeuresSDWS() }
			//	if(typeof (Lucymesh)!=="undefined") {Lucymesh.geometry.computeVertexNormals()}
				TracerArcsDiurnes()
			}
			TracerStyle()
			PlacerLeSoleil()
			document.body.style.cursor = 'auto'
		}



		function Rot(x, y, r) {
			r *= Math.PI / 180;
			return [Math.cos(r) * x + Math.sin(r) * y, -Math.sin(r) * x + Math.cos(r) * y];
		}

		function EtoC(x, y, z) {             // Changement de coordonnées équatoriales --> cadran
			[z, x] = Rot(z, x, 90 - cs.lati);  // ... dans le repère local
			[x, y] = Rot(x, y, cs.decli);
			[z, x] = Rot(z, x, cs.incli);      // ... dans le repère cadran
			return [x, y, z];
		}


		let xd = 0, yd = 0, zd = 1    // Direction Gnomon analemmatique  Modif AJL 
		function Proj([x, y, z]) {            // Projection sur le cadran avec mise à la dimension R
			return new Point(cs.Ranalem * (y - z * xd / zd), cs.Ranalem * (-x - z * yd / zd),0);
		}

		function TracerAnalem() {
			cs.hoursTextSize = cs.textSizeANL
			effacelisteMesh(analemListeMesh, analemGroup)
			//CSVtext += "\n\n"
			//CSVtext += 'Solar hours'+"\n\n"

			var frh = 1, cl = 0, fh = 0; // Pour 
			var al = eclair();	// Angles horaires limites
			var hd = Math.floor(Math.round(2 * frh * (al[0] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var h1 = Math.ceil(Math.round(2 * frh * (al[1] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var h2 = Math.floor(Math.round(2 * frh * (al[2] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var hf = Math.ceil(Math.round(2 * frh * (al[3] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			if (hf >= hd + 24) hf = hd + 24;

			var ob = .4091;		// Obliquité de l'écliptique
			var prp = 50;			// Rapport des longueurs de l'échelle des dates et des tirets
			var nsg = 4;			// Nombre de segment par heure
			var x, y, z;
			// Ligne horaire
			var pths = [];
			for (let hv = hd * nsg; hv <= hf * nsg; hv++) {
				[x, y] = Rot(1, 0, 15 * hv / nsg);    // Direction du point horaire dans le repère polaire
				pths.push(Proj(EtoC(x, y, 0)));
			}
			CSVtext+= "Ellipse \n\n"
			traceAnalem(pths, cs.egnomon, 100);  //+++ Tracé de l'ellipse
			CSVtext+= "\n\n"
			// pths.splice(0, pths.length);		// Vide le tableau
			// [x, y] = Rot(1, 0, 15*(cs.hsol - 0.05));    // Direction du point horaire dans le repère polaire
			// pths.push(Proj(EtoC(x, y, 0)));
			// [x, y] = Rot(1, 0, 15*(cs.hsol + 0.05));    // Direction du point horaire dans le repère polaire
			// pths.push(Proj(EtoC(x, y, 0)));
			// traceAnalem(pths,3*cs.egnomon,10);  //+++ Trace pour cs.hsol
			for (let hv = hd; hv <= hf; hv++) {
				pths.splice(0, pths.length);		// Vide le tableau
				[x, y] = Rot(1, 0, 15 * (hv - 0.05));    // Direction du point horaire dans le repère polaire
				pths.push(Proj(EtoC(x, y, 0)));
				[x, y] = Rot(1, 0, 15 * (hv + 0.05));    // Direction du point horaire dans le repère polaire
				pths.push(Proj(EtoC(x, y, 0)));
				CSVtext+= "hour: " +hv.toString()+ " H \n"
				traceAnalem(pths, 3 * cs.egnomon, 10);  //+++ Trace pour cs.hsol
				[x, y] = Rot(1, 0, 15 * hv)
				// [x, y]=Proj(EtoC(x, y, 0))
				EcrireTexte(hv.toString(),
					Proj(EtoC(x, y, 0)).x + cs.xgnomon,
					Proj(EtoC(x, y, 0)).y + cs.ygnomon,
					cs.epaisseur / 2,
					materialAnalem, analemGroup, analemListeMesh)

			}

			CSVtext+= "\n\n"
			pths.splice(0, pths.length);		// Vide le tableau
			// Ligne des dates
			CSVtext+= "Line for the date \n"
			pths.push(Proj(EtoC(0, 0, Math.tan(-ob))));
			pths.push(Proj(EtoC(0, 0, Math.tan(ob))));
			//dx, dy = (y2 - y1)/prp, (x1 - x2)/prp;
			traceAnalem(pths, cs.egnomon / 2, 10);  //+++ Tracé de la ligne des dates

			cadranSolaireGroup.add(analemGroup);
		}

		function traceAnalem(points, eptrait, npoints) {
			let tubeGeometry, mesh, xp, yp, zp, pipeSpline, pipeSplineCRC, xs, ys;
			pipeSpline = [];
			if (SVGtext.length > 0) {
				SVGtext += ` 
		          <polyline fill="none" stroke="${materialAnalem.color.getStyle()}" stroke-width="${eptrait}"
		           points= " `
			}
			for (let p = 0; p < points.length; p++) {
				xp = points[p].x + cs.xgnomon;
				yp = points[p].y + cs.ygnomon;
				zp = (cs.epaisseur + cs.egnomon) / 2;
				pipeSpline.push(new THREE.Vector3(xp, yp, zp));
				//CSVtext += "point: " + cs.separateurCSV + xp.toFixed(2) + cs.separateurCSV + yp.toFixed(2) + "\n";
				ligneCSV("point",xp,yp,zp)
				if (SVGtext.length > 0) {
					xs = xp + cs.largeur / 2; ys = -yp + cs.hauteur / 2;
					SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
				}
			}
			if (SVGtext.length > 0) { SVGtext += `" />` }
			if (pipeSpline.length > 1) {
				pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline, false, 'chordal', 1);
				tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, npoints, eptrait, npoints, false);
				mesh = new THREE.Mesh(tubeGeometry, materialAnalem);
				//mesh.receiveShadow = true;
				analemListeMesh.push(mesh);
				analemGroup.add(mesh);
			}
		}

		// --------------------------------------------------------------------------------------------------------
		function pointDansCadran(x, y) {
			return (cs.typeCadran==RTS) || ((Math.abs(x) <= (cs.largeur / 2)) && (Math.abs(y) <= (cs.hauteur / 2)))
		}
		//---------------------------------------------------------------------------------------------------------
		let g1, g2, k1, k2;
		function calculg1g2k1k2() {

			const a = cs.hfilHorizontal
			const b = cs.hfilVertical
			const e = b - a
			const [sinj1, cosj1] = base.sincos(base.toRad(cs.anglefilHorizontal))
			const [sinj2, cosj2] = base.sincos(base.toRad(cs.anglefilVertical))
			const sinj1mj2 = Math.sin(base.toRad(cs.anglefilHorizontal - cs.anglefilVertical))
			g1 = (b * sinj2 * cosj1 - a * sinj1 * cosj2) / sinj1mj2
			g2 = (b * sinj1 * cosj2 - a * sinj2 * cosj1) / sinj1mj2
			k1 = e * cosj1 * cosj2 / sinj1mj2
			k2 = e * sinj1 * sinj2 / sinj1mj2
		}

		function ligneSVG(xg, yg, xp, yp) {
			if (SVGtext.length > 0) {
				xg = xg + cs.largeur / 2; yg = -yg + cs.hauteur / 2
				xp = xp + cs.largeur / 2; yp = -yp + cs.hauteur / 2
				SVGtext += `
			<line x1="${xg.toFixed(3)}" y1="${yg.toFixed(3)}" x2="${xp.toFixed(3)}" y2="${yp.toFixed(3)}"
			stroke="black" stroke-width="1"/>
			`}
		}

		function croixSVG(x, y) {
			ligneSVG(x - 3, y - 3, x + 3, y + 3)
			ligneSVG(x - 3, y + 3, x + 3, y - 3)
		}


		function EcrirelesDates() {
			let pg, xp, yp, j, jde, ae, agauche, js, ms, mm, jj,gradGeo=[],gradMesh=[]
			//cs.hoursTextSize*=0.5
			CSVtext+="\n\n"
			CSVtext+="Date for the style \n\n"
			for (let m = 1; m < 13; m++) {
				// if (typeof (gradGeo[m-1]) !== "undefined") { gradGeo[m-1].geometry.dispose() };
				// cadranSolaireGroup.remove(gradMesh[m-1]);
				j = cs.dateAnalem
				jde = JULIAN.CalendarGregorianToJD(cs.year, m, j);
				mm = JULIAN.JDToCalendarGregorian(jde).month
				jj = JULIAN.JDToCalendarGregorian(jde).day
				ae = apparentEquatorial(jde);
				pg = Proj(EtoC(0, 0, Math.tan(ae.dec)));
				xp = pg.x + cs.xgnomon; yp = pg.y + cs.ygnomon
				gradGeo.push(new THREE.CylinderGeometry())
				gradMesh.push(new THREE.Mesh(gradGeo[m-1],materialAnalem))
				cadranSolaireGroup.add(gradMesh[m-1])
				gradMesh[m-1].position.set(xp,yp,cs.epaisseur/2)
				gradMesh[m-1].scale.set(cs.egnomon,4*cs.egnomon,cs.egnomon)
				gradMesh[m-1].rotateZ(Math.PI/2) 
				//debutGnomon.position.x=xp;	debutGnomon.position.y=yp ; debutGnomon.position.z= (cs.egnomon+cs.epaisseur)/2
				if ((jde > TS.solJuin) && (jde < TS.solDecembre)) { agauche = true } else { agauche = false }
				js = jj.toString()
				ms = mm.toString(); if (m < 10) { ms = '0' + ms }
				if (agauche) {
					gradMesh[m-1].position.set(xp-4,yp,cs.epaisseur/2)
					EcrireTexte(js + "/" + ms + " ", xp, yp,cs.epaisseur / 2, materialAnalem, analemGroup, analemListeMesh, true)
					ligneSVG(xp - 5, yp, xp, yp)
				}
				else {
					gradMesh[m-1].position.set(xp+4,yp,cs.epaisseur/2)
					EcrireTexte(js + "/" + ms, xp + 7, yp,cs.epaisseur / 2, materialAnalem, analemGroup, analemListeMesh, false)
					ligneSVG(xp, yp, xp + 4, yp)
				}
				ligneCSV(js + "/" + ms + " : ",xp,yp)
				analemListeMesh.push(gradMesh[m-1]);
				analemGroup.add(gradMesh[m-1]);
			}
			//cs.hoursTextSize*=2
		}

		function TracerStyle() {
			let v10, v20, v30, v40, xg, yg, xp, yp, OK = true;

			function TracerFil(alpha, hfil1, hfil2) {
				let x1, y1, x2, y2, x3, y3, x4, y4, x10, y10, x20, y20;
				let coordFil = [];
				const a = Math.tan(alpha / 180 * Math.PI)
				const b = cs.ygnomon - a * cs.xgnomon
				const h = cs.hauteur / 2; const l = cs.largeur / 2;
				x1 = (h - b) / a; y1 = h; if (pointDansCadran(x1, y1)) { coordFil.push([x1, y1]) }
				x2 = l; y2 = l * a + b; if (pointDansCadran(x2, y2)) { coordFil.push([x2, y2]) }
				x3 = (-h - b) / a; y3 = -h; if (pointDansCadran(x3, y3)) { coordFil.push([x3, y3]) }
				x4 = -l; y4 = (-l) * a + b; if (pointDansCadran(x4, y4)) { coordFil.push([x4, y4]) }
				OK = (coordFil.length == 2)
				if (OK) {
					x10 = coordFil[0][0]; y10 = coordFil[0][1]
					v10 = new THREE.Vector3(x10, y10, (cs.epaisseur / 2 + hfil1))
					x20 = coordFil[1][0]; y20 = coordFil[1][1]
					v20 = new THREE.Vector3(x20, y20, (cs.epaisseur / 2 + hfil2))
				}
				return OK
			}



			if (typeof (stylePolaire) !== "undefined") { stylePolaire.geometry.dispose() };
			if (typeof (sousStylaire) !== "undefined") { stylePolaire.geometry.dispose() };
			if (typeof (styleAnalem) !== "undefined") { styleAnalem.geometry.dispose() };
			cadranSolaireGroup.remove(stylePolaire);
			cadranSolaireGroup.remove(sousStylaire);
			cadranSolaireGroup.remove(styleAnalem);
			if (typeof (filHorizontal) !== "undefined") { filHorizontal.geometry.dispose() };
			if (typeof (filVertical) !== "undefined") { filVertical.geometry.dispose() };
			cadranSolaireGroup.remove(filHorizontal);
			cadranSolaireGroup.remove(filVertical);
			if (typeof (pilierH1) !== "undefined") { pilierH1.geometry.dispose() };
			if (typeof (pilierH2) !== "undefined") { pilierH2.geometry.dispose() };
			if (typeof (pilierH3) !== "undefined") { pilierH3.geometry.dispose() };
			if (typeof (pilierH4) !== "undefined") { pilierH4.geometry.dispose() };
			cadranSolaireGroup.remove(pilierH1);
			cadranSolaireGroup.remove(pilierH2);
			cadranSolaireGroup.remove(pilierH3);
			cadranSolaireGroup.remove(pilierH4);

			if (typeof (styleTorique) !== "undefined") { styleTorique.geometry.dispose() };
			cadranSolaireGroup.remove(styleTorique);

			if (cs.typeCadran == RTS){
				const k=Math.max(cs.egnomon,1)
				const geoTore= new THREE.TorusGeometry(k*5,k,32,32)
			    styleTorique= new THREE.Mesh(geoTore, materialSun);
				cadranSolaireGroup.add(styleTorique);
				styleTorique.position.set(cs.xgnomon,cs.ygnomon,cs.zgnomon)
				styleTorique.castShadow = true;	
				cadran.castShadow=true			
			}


			if (cs.typeCadran == SP) {
				if (cs.angleStyleSousstylaire > 0.4) {
					//  Si l'angle Style polaire-SousStylaire> 0.4°
					const v1 = new THREE.Vector3(cs.xPole + cs.xgnomon, cs.yPole + cs.ygnomon, (cs.epaisseur + cs.egnomon) / 2);
					const v2 = new THREE.Vector3(cs.xgnomon, cs.ygnomon, cs.hgnomon + (cs.epaisseur + cs.egnomon) / 2);
					const tubeGeometrySP = new THREE.TubeGeometry(new THREE.LineCurve3(v1, v2), 16, cs.egnomon, 8);
					stylePolaire = new THREE.Mesh(tubeGeometrySP, materialGnomon);
					stylePolaire.castShadow = true;
					cadranSolaireGroup.add(stylePolaire);
					//stylePolaire.visible = cs.vstyle;
					// Sous-stylaire
					const v3 = new THREE.Vector3(cs.xPole + cs.xgnomon, cs.yPole + cs.ygnomon, (cs.epaisseur + cs.egnomon) / 2);
					const v4 = new THREE.Vector3(cs.xgnomon, cs.ygnomon, (cs.epaisseur + cs.egnomon) / 2);
					const tubeGeometrySS = new THREE.TubeGeometry(new THREE.LineCurve3(v3, v4), 16, cs.egnomon, 8);
					sousStylaire = new THREE.Mesh(tubeGeometrySS, materialGnomon);
					sousStylaire.castShadow = true;
					cadranSolaireGroup.add(sousStylaire);
					//sousStylaire.visible = cs.vsousstyle

					cadranSolaireGroup.add(gnomon)

					//	boutGnomon.visible= cs.vgnomon	||cs.vstyle
					//	boutGnomon.visible= cs.vsousstyle || cs.vstyle
					//	debutGnomon.visible=cs.vstyle||cs.vsousstyle


					//	boutGnomon.position.x=v2.x;debutGnomon.position.y=v2.y;debutGnomon.position.z=v2.z
					//	debutGnomon.position.x=v1.x;debutGnomon.position.y=v1.y;debutGnomon.position.z=v1.z


					ligneSVG(v3.x, v3.y, v4.x, v4.y)
					croixSVG(v4.x, v4.y)
					//console.log(SVGtext)

				}// sinon style polaire parallele au plan  ${cs.egnomon.toFixed(2)}
			}

			if (cs.typeCadran == BF) {
				calculg1g2k1k2()
				if (cs.anglefilVertical == 90) {
					v10 = new THREE.Vector3(cs.xgnomon, -cs.hauteur / 2, (cs.epaisseur / 2 + cs.hfilVertical));
					v20 = new THREE.Vector3(cs.xgnomon, cs.hauteur / 2, (cs.epaisseur / 2 + cs.hfilVertical))
				}
				else TracerFil(cs.anglefilVertical, cs.hfilVertical, cs.hfilVertical);
				cs.xB1 = v10.x; cs.yB1 = v10.y; cs.xB2 = v20.x; cs.yB2 = v20.y;
				const tubeGeometryFV = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 16);
				filVertical = new THREE.Mesh(tubeGeometryFV, materialGnomon);
				filVertical.castShadow = true;
				cadranSolaireGroup.add(filVertical);

				if (cs.anglefilHorizontal == 0) {
					v10 = new THREE.Vector3(-cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hfilHorizontal));
					v20 = new THREE.Vector3(cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hfilHorizontal))
				}
				else TracerFil(cs.anglefilHorizontal, cs.hfilHorizontal, cs.hfilHorizontal);
				cs.xA1 = v10.x; cs.yA1 = v10.y; cs.xA2 = v20.x; cs.yA2 = v20.y;
				const tubeGeometryFH = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 16);
				filHorizontal = new THREE.Mesh(tubeGeometryFH, materialGnomon);
				filHorizontal.castShadow = true;
				cadranSolaireGroup.add(filHorizontal)

				gnomon.visible = false;
				cadranSolaireGroup.remove(gnomon)
				croixSVG(cs.xA1, cs.yA1); croixSVG(cs.xA2, cs.yA2); croixSVG(cs.xB1, cs.yB1); croixSVG(cs.xB2, cs.yB2)
				croixSVG(cs.xgnomon, cs.ygnomon)
				//console.log(g1,g2,k1,k2)

			}

			if (cs.typeCadran == BFG) {

				if (cs.anglefilVertical == 90) {
					v10 = new THREE.Vector3(cs.xgnomon, -cs.hauteur / 2, (cs.epaisseur / 2 + cs.hB1));
					v20 = new THREE.Vector3(cs.xgnomon, cs.hauteur / 2, (cs.epaisseur / 2 + cs.hB2))
				}
				else TracerFil(cs.anglefilVertical, cs.hB1, cs.hB2);
				cs.xB1 = v10.x; cs.yB1 = v10.y; cs.xB2 = v20.x; cs.yB2 = v20.y;
				const tubeGeometryFV = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 8);
				filVertical = new THREE.Mesh(tubeGeometryFV, materialGnomon);
				filVertical.castShadow = true;
				cadranSolaireGroup.add(filVertical);
				v30 = new THREE.Vector3(v10.x, v10.y, -cs.epaisseur / 2)
				const tubeGeometryH1 = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v30), 16, cs.egnomon, 8);
				pilierH1 = new THREE.Mesh(tubeGeometryH1, materialGnomon);
				v40 = new THREE.Vector3(v20.x, v20.y, -cs.epaisseur / 2)
				const tubeGeometryH2 = new THREE.TubeGeometry(new THREE.LineCurve3(v20, v40), 16, cs.egnomon, 8);
				pilierH2 = new THREE.Mesh(tubeGeometryH2, materialGnomon);
				cadranSolaireGroup.add(pilierH1); cadranSolaireGroup.add(pilierH2);

				if (cs.anglefilHorizontal == 0) {
					v10 = new THREE.Vector3(-cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hA1));
					v20 = new THREE.Vector3(cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hA2))
				}
				else TracerFil(cs.anglefilHorizontal, cs.hA1, cs.hA2);
				cs.xA1 = v10.x; cs.yA1 = v10.y; cs.xA2 = v20.x; cs.yA2 = v20.y;
				const tubeGeometryFH = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 8);
				filHorizontal = new THREE.Mesh(tubeGeometryFH, materialGnomon);
				filHorizontal.castShadow = true;
				cadranSolaireGroup.add(filHorizontal)
				v30 = new THREE.Vector3(v10.x, v10.y, -cs.epaisseur / 2)
				const tubeGeometryH3 = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v30), 16, cs.egnomon, 8);
				pilierH3 = new THREE.Mesh(tubeGeometryH3, materialGnomon);
				v40 = new THREE.Vector3(v20.x, v20.y, -cs.epaisseur / 2)
				const tubeGeometryH4 = new THREE.TubeGeometry(new THREE.LineCurve3(v20, v40), 16, cs.egnomon, 8);
				pilierH4 = new THREE.Mesh(tubeGeometryH4, materialGnomon);
				cadranSolaireGroup.add(pilierH3); cadranSolaireGroup.add(pilierH4);

				croixSVG(cs.xA1, cs.yA1); croixSVG(cs.xA2, cs.yA2); croixSVG(cs.xB1, cs.yB1); croixSVG(cs.xB2, cs.yB2)
				croixSVG(cs.xgnomon, cs.ygnomon)
				gnomon.visible = false;
				//cadranSolaireGroup.remove(gnomon)

				//console.log(g1,g2,k1,k2)

			}

			if (cs.typeCadran == ANL) {
				xd = zd * Math.tan(base.toRad(cs.xdirect))
				yd = zd * Math.tan(base.toRad(cs.ydirect))
				const pg = Proj(EtoC(0, 0, Math.tan(TS.decSuns[cs.dayofYear - 1])));
				const xp = pg.x + cs.xgnomon, yp = pg.y + cs.ygnomon, zp = cs.epaisseur / 2;
				// const v1 = new THREE.Vector3(xp, yp, zp);
				// const k = cs.Hanalem/Math.sqrt(cs.xdirect*cs.xdirect + cs.ydirect*cs.ydirect + cs.zdirect*cs.zdirect);
				// const v2 = new THREE.Vector3(xp + k*cs.xdirect, yp + k*cs.ydirect, zp + k*cs.zdirect);
				const v1 = new THREE.Vector3(xp, yp, zp);
				const k = cs.Hanalem / Math.sqrt(xd * xd + yd * yd + zd * zd);
				const v2 = new THREE.Vector3(xp + k * xd, yp + k * yd, zp + k * zd);
				const tubeGeometrySP = new THREE.TubeGeometry(new THREE.LineCurve3(v1, v2), 16, cs.egnomon, 32);
				styleAnalem = new THREE.Mesh(tubeGeometrySP, materialGnomon);
				styleAnalem.castShadow = true;
				cadranSolaireGroup.add(styleAnalem);
				//EcrirelesDates()
				//if (ligneDate.length>0) {EcrireTexte(ligneDate,xp,yp,materialAnalem,analemGroup,analemListeMesh)}
			}
		}  //Tracer Style

		//------------------------------------------------------------------------------------------------------
		function ExtrudeSetting(c, spline, nsteps) {
			const squareShape = new THREE.Shape()
				.moveTo(0, c)
				//	.lineTo(  -c,c )
				.lineTo(-2 * c, 0)
				//	.lineTo(  -c, -c)
				.lineTo(0, -c)
				.lineTo(0, c);
			const Settings = {
				steps: nsteps,
				bevelEnabled: false,
				extrudePath: spline
			};
			return { forme: squareShape, setting: Settings }
		}
		// const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,200)
		// tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 
		// mesh = new THREE.Mesh( tubeGeometry, material);
		//---------------------------------------------------------------------------------------------------------
		function effacelisteMesh(listeMesh, group) {
			//Effacement des lignes existantes
			const lm = listeMesh.length;
			let mesh;
			for (let i = 0; i < lm; i++) {
				mesh = listeMesh[i];
				mesh.geometry.dispose();
				group.remove(mesh);
				mesh.clear
			}
			listeMesh = [];
			//group.clear
			cadranSolaireGroup.remove(group);
		}
		//-----------------------------------------------------------------------------------------------------------------------
		function traceLignes(sunDial, listeMesh, group, material) {
			let tubeGeometry, mesh, xp, yp, zp, pipeSpline, pipeSplineCRC, longLigne, xs, ys, eptrait,hd,h,min;
			// tracé des nouvelles lignes
			for (let i = 0; i < sunDial.lines.length; i++) {
				longLigne = sunDial.lines[i].points.length
				if (longLigne > 1) {
					hd=sunDial.lines[i].hour;
					h = Math.floor(hd);
					min = Math.round((hd - h) * 60);
					CSVtext += "Heure: " + h.toString()+":"+min.toString() + "\n";
					pipeSpline = [];
					if (presqueEntier(sunDial.lines[i].hour)) { eptrait = cs.egnomon } else { eptrait = cs.egnomon / 2 }
					if (SVGtext.length > 0) {
						SVGtext += ` 
				          <polyline fill="none" stroke="${material.color.getStyle()}" stroke-width="${eptrait}"
				           points= " ` }

					for (let p = 0; p < sunDial.lines[i].points.length; p++) {
						xp = sunDial.lines[i].points[p].x + cs.xgnomon;
						yp = sunDial.lines[i].points[p].y + cs.ygnomon;
						zp = sunDial.lines[i].points[p].z + cs.egnomon / 2;

						pipeSpline.push(new THREE.Vector3(xp, yp, zp));
						ligneCSV("point:",xp,yp,zp)
						//CSVtext += "point: " + cs.separateurCSV + xp.toFixed(2) + cs.separateurCSV + yp.toFixed(2) + "\n";
						if (SVGtext.length > 0) {
							xs = xp + cs.largeur / 2; ys = -yp + cs.hauteur / 2
							SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
						}
					};
					if (SVGtext.length > 0) { SVGtext += `" />` }
					if (pipeSpline.length > 1) {
						pipeSplineCRC = [];
						pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline, false, 'chordal', 1);


						tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, 180, eptrait, 8, false);

						//const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,180)
						//tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 

						mesh = new THREE.Mesh(tubeGeometry, material);
						mesh.receiveShadow = true;
						listeMesh.push(mesh);
						group.add(mesh);						
					}
					cadranSolaireGroup.add(group)
				}
			}
			//   TracerStyle()
		}
		// const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,200)
		// tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 
		// mesh = new THREE.Mesh( tubeGeometry, material);

		// const lineGeometry = new THREE.BufferGeometry().setFromPoints( pipeSplineCRC );				   
		// const lineMaterial = new THREE.LineBasicMaterial( {color:0x0000FF});
		// mesh = new THREE.Mesh( lineGeometry, lineMaterial);		 

		//---------------------------------------------------------------------------------------------------------
		function TracerHeuresSolaires() {
			cs.hoursTextSize = cs.textSizeHS
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HS, heuresSolairesGroup, materialHeuresSolaires, heuresSolairesListeMesh);
			//console.log(CSVtext)
			CSVtext += "\n\n"
			CSVtext += 'Solar hours' + "\n\n"
			
			traceLignes(sunDial, heuresSolairesListeMesh, heuresSolairesGroup, materialHeuresSolaires)

		}

		//-------------------------------------------------------------------------------------------------------
		function TracerHeuresLegalesSA() {
			cs.hoursTextSize = cs.textSizeSA
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HLSA, heuresLegalesGroupSA, materialHeuresLegalesSA, heuresLegalesListeMeshSA);
			CSVtext += "\n\n"
			CSVtext += 'Legal hours (Summer and Autumn)' + "\n\n"
			
			traceLignes(sunDial, heuresLegalesListeMeshSA, heuresLegalesGroupSA, materialHeuresLegalesSA)

		}

		function TracerHeuresLegalesWS() {

			cs.hoursTextSize = cs.textSizeWS
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax + 1, HLWS, heuresLegalesGroupWS, materialHeuresLegalesWS, heuresLegalesListeMeshWS);
			CSVtext += "\n\n"
			CSVtext += 'Legal hours (Winter and Spring)' + "\n\n"

			traceLignes(sunDial, heuresLegalesListeMeshWS, heuresLegalesGroupWS, materialHeuresLegalesWS)

		}

		//------------------------------------------------------------------------------------------------
		function TracerHeuresAntiques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Unequal hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresAntiquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHA
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HA, heuresAntiquesGroup, materialHeuresAntiques, heuresAntiquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Antic hours' + "\n\n"

			traceLignes(sunDial, heuresAntiquesListeMesh, heuresAntiquesGroup, materialHeuresAntiques)
		}
		//-----------------------------------------------------------------------------------------------------
		function TracerHeuresBabyloniques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Babylonics hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresBabyloniquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHB;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HB, heuresBabyloniquesGroup, materialHeuresBabyloniques, heuresBabyloniquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Babylonics hours' + "\n\n"

			traceLignes(sunDial, heuresBabyloniquesListeMesh, heuresBabyloniquesGroup, materialHeuresBabyloniques)

		}
		//-----------------------------------------------------------------------------------------------------
		function TracerHeuresItaliques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Italic hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresItaliquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHI;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HI, heuresItaliquesGroup, materialHeuresItaliques, heuresItaliquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Italic hours' + "\n\n"

			traceLignes(sunDial, heuresItaliquesListeMesh, heuresItaliquesGroup, materialHeuresItaliques)

		}

		//------------------------------------------------------------------------------------------------------
		function TracerHeuresSDSA() {
			cs.hoursTextSize = cs.textSizeSDSA;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HSDSA, heuresSDSAgroup, materialHeuresSDSA, heuresSDSAListeMesh);
			CSVtext += "\n\n"
			CSVtext += HSDSA + "\n\n"

			traceLignes(sunDial, heuresSDSAListeMesh, heuresSDSAgroup, materialHeuresSDSA)
		}

		function TracerHeuresSDWS() {
			cs.hoursTextSize = cs.textSizeSDWS;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HSDWS, heuresSDWSgroup, materialHeuresSDWS, heuresSDWSListeMesh);
			CSVtext += "\n\n"
			CSVtext += HSDWS + "\n\n"
			
			traceLignes(sunDial, heuresSDWSListeMesh, heuresSDWSgroup, materialHeuresSDWS)

		}
	
		//---------------------------------------------------------------------------------------------------------
		function TracerArcsDiurnes() {
			let tubeGeometry, mesh, xp, yp, zp, lm, pipeSpline, pipeSplineCRC, xs, ys;

			effacelisteMesh(arcsDiurnesListeMesh, arcsDiurnesGroup)

			const sunDial = arcsDiurnes
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, arcsDiurnesGroup, materialArcsDiurnes, arcsDiurnesListeMesh);


			CSVtext += "\n\n";
			CSVtext += "Diurnial arcs" + "\n\n";

			//traceLignes(sunDial,arcsDiurnesListeMesh,arcsDiurnesGroup,materialArcsDiurnes)
			// tracé des nouvelles lignes
			for (let i = 0; i < sunDial.lines.length; i++) {
				if (sunDial.lines[i].points.length > 1) {
					CSVtext += "Date: " + sunDial.lines[i].date[0].toString() + "\n";
					pipeSpline = [];
					if (SVGtext.length > 0) {
						SVGtext += ` 
				          <polyline fill="none" stroke="${materialArcsDiurnes.color.getStyle()}" stroke-width="${cs.egnomon}"
				           points= " ` }

					for (let p = 0; p < sunDial.lines[i].points.length; p++) {
						xp = sunDial.lines[i].points[p].x + cs.xgnomon;
						yp = sunDial.lines[i].points[p].y + cs.ygnomon;
						zp = sunDial.lines[i].points[p].z + cs.egnomon / 2;
						pipeSpline.push(new THREE.Vector3(xp, yp, zp));
						ligneCSV( "point: ",xp,yp,zp)
						//CSVtext += "point: " + cs.separateurCSV + xp.toFixed(2) + cs.separateurCSV + yp.toFixed(2) + "\n"
						if (SVGtext.length > 0) {
							xs = xp + cs.largeur / 2; ys = -yp + cs.hauteur / 2
							SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
						}
					};
					if (SVGtext.length > 0) { SVGtext += `" />` }
					if (pipeSpline.length > 1) {
						pipeSplineCRC = [];
						pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline, false, 'chordal', 1);
						tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, 200, cs.egnomon, 8, false);
						mesh = new THREE.Mesh(tubeGeometry, materialArcsDiurnes);
						mesh.receiveShadow = true;
						arcsDiurnesListeMesh.push(mesh);
						arcsDiurnesGroup.add(mesh);
					}
				}
			}
			//TracerStyle(sunDial)
			cadranSolaireGroup.add(arcsDiurnesGroup);

		}

		/**
		 * Point return type represents a point to be used in constructing the sundial.
		 */
		function Point(x, y, z) {
			this.x = x || 0
			this.y = y || 0
			this.z = z || 0
		}

		/**
		 * Line holds data to draw an hour line on the sundial.
		 */
		function LigneHoraire(hour, points) {
			this.hour = hour // 0 to 24
			this.points = points || [] // One or more points corresponding to the hour.
		}

		function LigneArc(date, points) {
			this.date = date
			this.points = points || [] // One or more points corresponding to the date.
		}

		/**
		 * General computes data for the general case of a planar sundial.
		 *
		 * Argument φ is geographic latitude at which the sundial will be located.
		 * D is gnomonic declination, the azimuth of the perpendicular to the plane
		 * of the sundial, measured from the southern meridian towards the west.
		 * Argument a is the length of a straight stylus perpendicular to the plane
		 * of the sundial, z is zenithal distance of the direction defined by the
		 * stylus.  Angles φ, D, and z are in radians.  Units of stylus length a
		 * are arbitrary.
		 *
		 * Results consist of a set of lines, a center point, u, the length of a
		 * polar stylus, and ψ, the angle which the polar stylus makes with the plane
		 * of the sundial.  The center point, the points defining the hour lines, and
		 * u are in units of a, the stylus length.  ψ is in radians.
		 */

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////
		function Correction(H0, j) {
			let c = 0
			c = TS.eqtimes[j] + (cs.longi / 15 - cs.offset_sec / 3600) * Math.PI / 12;
			return (H0 + c);  //angle horaire en radians, de -pi à +pi
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////
		function coordOmbre(sH, cH, sD, cD, sz, cz, sφ, cφ, tδ, Q,H,dec) {

			if (cs.typeCadran == SP) {
				const Nx = cD * sH - sD * (sφ * cH - cφ * tδ)
				const Ny = cz * sD * sH - (cφ * sz - sφ * cz * cD) * cH - (sφ * sz + cφ * cz * cD) * tδ
				return {
					xo: cs.hgnomon * Nx / Q,
					yo: cs.hgnomon * Ny / Q,
					zo: cs.epaisseur / 2,
					ok: true
				}
			}
			if (cs.typeCadran == BF) {
				const Dn = sD * sH + cD * (sφ * cH - cφ * tδ)
				const Nx = (g1 * (cD * sH - sD * (sφ * cH - cφ * tδ)) + k1 * (sφ * tδ + cφ * cH)) / Dn
				const Ny = (g2 * (sφ * tδ + cφ * cH) + k2 * (cD * sH - sD * (sφ * cH - cφ * tδ))) / Dn
				return {
					xo: -Nx,
					yo: -Ny,
					zo: cs.epaisseur / 2,
					ok: true
				}
			}
			if (cs.typeCadran == BFG) {
				const Nx = cD * sH - sD * (sφ * cH - cφ * tδ)
				const Ny = cz * sD * sH - (cφ * sz - sφ * cz * cD) * cH - (sφ * sz + cφ * cz * cD) * tδ
				const xA1 = cs.hA1 * Nx / Q + cs.xA1  //algorythme Hugo: coord des points d'ombre des supports
				const yA1 = cs.hA1 * Ny / Q + cs.yA1
				const xA2 = cs.hA2 * Nx / Q + cs.xA2
				const yA2 = cs.hA2 * Ny / Q + cs.yA2
				const xB1 = cs.hB1 * Nx / Q + cs.xB1
				const yB1 = cs.hB1 * Ny / Q + cs.yB1
				const xB2 = cs.hB2 * Nx / Q + cs.xB2
				const yB2 = cs.hB2 * Ny / Q + cs.yB2
				const a = yA2 - yA1; const b = -xA2 + xA1;    //coefs droite A1A2: a x + b y =c
				const c = xA1 * (yA2 - yA1) - yA1 * (xA2 - xA1)
				const ap = yB2 - yB1; const bp = -xB2 + xB1;  //coefs droite B1B2: ap x + bp y = cp
				const cp = xB1 * (yB2 - yB1) - yB1 * (xB2 - xB1)
				let det = a * bp - ap * b
				const xombre = (bp * c - b * cp) / det
				const yombre = (a * cp - ap * c) / det
				const kxA = (xombre - xA1) / (xA2 - xA1)
				const kxB = (xombre - xB1) / (xB2 - xB1)
				if ((kxA < 0) || (kxA > 1) || (kxB < 0) || (kxB > 1)) { det = 0 }
				if (!(pointDansCadran(xombre, yombre))) { det = 0 }
				if (Math.abs(det) > 1) {
					return {
						xo: xombre - cs.xgnomon,
						yo: yombre - cs.ygnomon,
						zo: cs.epaisseur / 2,
						ok: true
					}
				} else {
					return {						
						xo: 0,
						yo: 0,
						zo: 0,
						ok: false
					}
				}
			}
			if (cs.typeCadran == RTS) {
				const Coord = CoordRayTracing(H, dec)
				if (Coord.ok) {
					return {
						xo: Coord.x-cs.xgnomon,
						yo: Coord.y-cs.ygnomon,
						zo: Coord.z,
						ok: Coord.ok
					}
				} else {
					return {
						xo: 0,
						yo: 0,
						zo: 0,
						ok: false
					}
				}			
			}
		}


		function presqueEntier(x) {
			return (Math.abs(Math.round(x) - x) < 0.001)
		}

		function generalAJL(φ, D, a, z, debut, fin, TypeHeure, group, material, listeMesh) {
			// (φ, D, a, z float64)  (lines []LigneHoraire, center Point, u, ψ float64)
			let l
			let coupe = false
			effacelisteMesh(listeMesh, group)
			let H, xp, yp,zp, xm, ym, zm, chiffreH = 0, sHeure = "";
			if (φ * 180 / Math.PI > 89.999999) { φ = 89.999999 * Math.PI / 180 }
			const [sφ, cφ] = base.sincos(φ)
			const tφ = sφ / cφ
			const [sD, cD] = base.sincos(D)
			const [sz, cz] = base.sincos(z)
			const P = sφ * cz - cφ * sz * cD
			const tan23p44 = Math.tan(23.44 / 180 * Math.PI)
			const lines = []
			for (let i = 0; i <= 24; i += cs.subDivisions) {
				l = new LigneHoraire(i)
				const Hi = (i - 12) * 15 * Math.PI / 180

				let j = debut;
				while (j !== fin + 1) {
					//if((Math.abs(j-TS.jdecSunMin)<5)||(Math.abs(j-TS.jdecSunMax)<5)){j++}else{j+=cs.precisionHours}
					j++
					if (j >= TS.decSuns.length) { j = 0 }
					if ((j % cs.precisionHours == 0) || (Math.abs(j - TS.jdecSunMin) <= 7) || (Math.abs(j - TS.jdecSunMax) <= 7)) {
						coupe = false
						const tδ = Math.tan(TS.decSuns[j])
						const cosH0 = -tφ * tδ
						let H0 = Math.acos(cosH0)    //half day length 
						if (cosH0 > 1) { H0 = -Math.PI }   //nuit polaire
						if (cosH0 <= -1) { H0 = Math.PI }  //j0ur polaire

						if (TypeHeure == HS) { H = Hi; chiffreH = i }     // Heures solaires
						if ((TypeHeure == HLSA) || (TypeHeure == HLWS)) { H = Correction(Hi, j); chiffreH = i }   //légales
						if (TypeHeure == HA) { H = H0 / 6 * (i - 12); chiffreH = i - 6 }  // heures antiques
						if (TypeHeure == HB) { H = i * 15 / 180 * Math.PI - H0; chiffreH = i }  //heures babyloniques
						if (TypeHeure == HI) { H = (i - 24) * 15 / 180 * Math.PI + H0; chiffreH = i }  //heures italiquesiques
						if (TypeHeure == HSDSA) {
							const RA = Math.PI - Math.asin(tδ / tan23p44) //heures sidérales
							H = i * 15 / 180 * Math.PI - RA
							chiffreH = i
						}
						if (TypeHeure == HSDWS) {
							const RA = Math.asin(tδ / tan23p44) //heures sidérales
							H = (i - 12) * 15 / 180 * Math.PI - RA
							if ((i - 12) < 0) { chiffreH = i + 12 } else { chiffreH = i - 12 }
						}
						const aH = Math.abs(H)
						const [sH, cH] = base.sincos(H)
						if (aH < H0) { // sun above horizon
							const Q = sD * sz * sH + (cφ * cz + sφ * sz * cD) * cH + P * tδ
							if ((Q > 0)||(cs.typeCadran==RTS)) { // sun above plane of sundial         
								const coor = coordOmbre(sH, cH, sD, cD, sz, cz, sφ, cφ, tδ, Q, H,TS.decSuns[j])       // Calcul des coordonnées de l'ombre
								if (coor.ok == true) {
									xp = coor.xo; yp = coor.yo;zp=coor.zo;
									if (pointDansCadran(xp + cs.xgnomon, yp + cs.ygnomon)) {
										if (coupe) {
											if (l.points.length > 0) { lines.push(l) }
											l = new LigneHoraire(i); coupe = false
										}
										l.points.push(new Point(xp, yp,zp)); xm = xp + cs.xgnomon; ym = yp + cs.ygnomon; zm=zp
									} else { coupe = true }
								}
							}
						}

					}
				}
				if (presqueEntier(chiffreH)) { sHeure = Math.round(chiffreH).toString() } else { sHeure = "" };
				if (l.points.length > 0) {
					lines.push(l);
					EcrireTexte(sHeure, xm, ym, zm, material, group, listeMesh)
				}
			}
			const center = new Point()
			center.x = a / P * cφ * sD
			center.y = -a / P * (sφ * sz + cφ * cz * cD)
			const aP = Math.abs(P)
			const u = a / aP
			const ψ = Math.asin(aP)
			cs.xPole = center.x; cs.yPole = center.y; cs.angleStyleSousstylaire = ψ * 180 / Math.PI;
			//console.log (lines)
			return {
				lines: lines,
				center: center,
				length: u,
				angle: ψ
			}
		}


		function arcsDiurnes(φ, D, a, z, debut, fin, group, material, listeMesh) {
			// (φ, D, a, z float64)  (lines []LigneHoraire, center Point, u, ψ float64)
			let H, xp, yp,zp, xm, ym, s, coupe, l;

			if (φ * 180 / Math.PI > 89.999999) { φ = 89.999999 * Math.PI / 180 }
			const [sφ, cφ] = base.sincos(φ)
			const tφ = sφ / cφ
			const [sD, cD] = base.sincos(D)
			const [sz, cz] = base.sincos(z)
			const P = sφ * cz - cφ * sz * cD

			const lines = []

			for (const d of cs.datesArcsDiurnes) {
				l = new LigneArc(d)
				coupe = false
				for (let i = 0; i < 24 * 60; i += cs.precisionArcs) {
					const H = (i - 12 * 60) / 60 * 15 * Math.PI / 180 
					const aH = Math.abs(H)
					const [sH, cH] = base.sincos(H)
					const tδ = Math.tan(d[1])
					const cosH0 = -tφ * tδ
					let H0 = Math.acos(cosH0)
					if (cosH0 > 1) { H0 = -Math.PI }  //nuit polaire
					if (cosH0 <= -1) { H0 = Math.PI }  //jour polaire
					if (aH < H0) { // sun above horizon
						const Q = sD * sz * sH + (cφ * cz + sφ * sz * cD) * cH + P * tδ
						if ((Q > 0)||(cs.typeCadran==RTS)) { // sun above plane of sundial         
							const coord = coordOmbre(sH, cH, sD, cD, sz, cz, sφ, cφ, tδ, Q, H,d[1])
							if (coord.ok == true) {
								xp = coord.xo; yp = coord.yo;zp=coord.zo
								if (pointDansCadran(xp + cs.xgnomon, yp + cs.ygnomon)) {
									if (coupe) {
										if (l.points.length > 0) { lines.push(l) }
										l = new LigneArc(d); coupe = false
									}
									l.points.push(new Point(xp, yp, zp));
									xm = xp + cs.xgnomon; ym = yp + cs.ygnomon; coupe = false
								} else { coupe = true }
							}
						}
					}
				}
				if (l.points.length > 0) { lines.push(l) }
			}
			const center = new Point()
			center.x = a / P * cφ * sD
			center.y = -a / P * (sφ * sz + cφ * cz * cD)
			const aP = Math.abs(P)
			const u = a / aP
			const ψ = Math.asin(aP)
			cs.xPole = center.x; cs.yPole = center.y; cs.angleStyleSousstylaire = ψ * 180 / Math.PI;
			return {
				lines: lines,
				center: center,
				length: u,
				angle: ψ
			}
		}

		//-----------------------------------------------------------------------------------------------------
		function loadJsonFile() {
				let csl;
				const [file] = document.querySelector('input[type=file]').files;
				
				const reader = new FileReader();
				reader.addEventListener("load", () => {
					try { csl = JSON.parse(reader.result) }
					catch (e) { console.error("Parsing error:", e) }
					//console.log(JSON.stringify(csl,null,2));
					for (var k in csl) { cs[k] = csl[k] }
					Info(cs.nameFile)
					TS = TableSol(cs.year);
					NouveauCadran=false
					
					run();
				}, false);
				
				if (file) {
					reader.readAsText(file);
				}

				//console.log(file)

				return reader.result;
			}
		


		//--------------------------------------------------------------------------------------------------------
		//function saveString    Ecrit la chaine de caracteres text dans le fichier texte de nom filename 
		//saveString('mon texte','Bidon.txt');
		const link = document.createElement('a');
		link.style.display = 'none';
		document.body.appendChild(link); // Firefox workaround, see #6594
		function save(blob, filename) {
			link.href = URL.createObjectURL(blob);
			link.download = filename;
			link.click();
		}
		function saveString(text, filename) {
			save(new Blob([text], { type: 'text/plain' }), filename);
			// console.log(text)
		}

		// ---------------------------------------------------------------------------------------------------
		function eulerCsGroup() {
			const a = new THREE.Euler((cs.incli - 90) / 180 * Math.PI, cs.decli / 180 * Math.PI, cs.rot / 180 * Math.PI, 'YXZ');
			cadranSolaireGroup.setRotationFromEuler(a);
		}

		// ---------------------------------------------------------------------------------------------------
		//   function 	eulerEarthGroup() 
		//   {
		//   	const a = new THREE.Euler( (cs.lati-90)/180*Math.PI, 0*Math.PI,-cs.longi/180*Math.PI, 'YZX' );
		// 	earthGroup.setRotationFromEuler(a); 	
		//   }

		function MiseEnPlaceCadranEtGnomon(){
			cadran.scale.x = cs.largeur;
			cadran.scale.y = cs.hauteur;
			cadran.scale.z = cs.epaisseur;
			
			cadran.receiveShadow = true;
			
			gnomon.position.x = cs.xgnomon;
			gnomon.position.y = cs.ygnomon;
			gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2;
			

			gnomon.scale.y = cs.hgnomon;
			gnomon.scale.x = cs.egnomon;
			gnomon.scale.z = cs.egnomon;
			gnomon.rotation.x = Math.PI * 0.5;
			gnomon.castShadow = true; //default is false			
			}
		////
		function EcrireXYZ(){
			const ht=cs.hoursTextSize
			cs.hoursTextSize = 3      
			effacelisteMesh(labelAxesListeMesh,groupAxes)
			if (cs.axesXYZ == true) {
					EcrireTexte(' x', 850, 0, 0, materialAxeX, groupAxes, labelAxesListeMesh)
					EcrireTexte(' y', 0, 850, 0, materialAxeY, groupAxes, labelAxesListeMesh)
					EcrireTexte('z', 0, 0, 810, materialAxeZ, groupAxes, labelAxesListeMesh)
					cadranSolaireGroup.add(groupAxes)
				} else {effacelisteMesh(labelAxesListeMesh,groupAxes)}
			cs.hoursTextSize=ht
		}

		function TracerMesh(mesh) {    //maillage pour cadran 
				cadran = mesh.clone()
				cadranSolaireGroup.add(cadran)
				cadran.receiveShadow = true
				cadran.scale.x = cs.largeur;
				cadran.scale.y = cs.hauteur;
				cadran.scale.z = cs.epaisseur;
				//eulerCsGroup()
				//EcrireXYZ()
				cs.typeForme = "?"
				TracerStyle()
				PlacerLeSoleil()
				effacelisteMesh(labelAxesListeMesh, groupAxes)
				axesESZHelper.visible= cs.axesESZ
				EcrireXYZ()
				TracerHeuresEtArcs()
				render()
				//console.log(cs)
			}
		
		//---------------------------------------------------------------------------------------------------------
		function init() {
			//Info("...")

			//Effacement de toute la page d'introduction  

			//document.getElementById("info").innerHTML = "";

			// dat.GUI ///////////////////////////////////////////////////////////////////////////////////////parallelepiped
			
		//
		
			function TracerCadranRTS(v) {
				// const plyloader = new PLYLoader();
				// const objloader= new OBJLoader()

				function TracerSolide() {
					if (NouveauCadran == true) {
						if (cs.typeForme=="parallelepiped"){cs.epaisseur = 30;cs.largeur=600}else{cs.epaisseur = 400;cs.largeur = 400}
						cs.hauteur =400;
						cs.xgnomon = 0; cs.ygnomon = cs.hauteur / 4;
						cs.zgnomon = cs.epaisseur / 2 + cs.hgnomon
						if (cs.typeForme=="cone"){cs.ygnomon = 5;cs.zgnomon=145}
						cs.decli=0;cs.incli=90	
					}
					
					cadran.scale.x = cs.largeur;
					cadran.scale.y = cs.hauteur;
					cadran.scale.z = cs.epaisseur
					// folderDimensionsSundial.show()
					// folderOrientationSundial.show()
					cadranSolaireGroup.add(cadran);	
					eulerCsGroup()	
					TracerStyle()		
					TracerHeuresEtArcs()				
					render()
					//console.log(NouveauCadran,cs.decli)
				}
				function TracerCadranEquatorial(){
					    cadranSolaireGroup.add(cadran);
						// folderDimensionsSundial.show()
						// folderOrientationSundial.show()
						//axeMondeGroup.add(cadran)
						if(NouveauCadran==true){
						cs.epaisseur = 300; cs.hauteur =300;cs.largeur=300
					    cs.xgnomon = 0; cs.ygnomon = 0;cs.zgnomon = 0
						cs.decli=0;cs.incli=cs.lati}
						cadran.scale.x = cs.largeur;
						cadran.scale.y = cs.hauteur;
						cadran.scale.z = cs.epaisseur						
						eulerCsGroup()						
						TracerStyle()
						TracerHeuresEtArcs()
						render()
				}

				function TracerCadranScaphe(){
					    materialCS.side=THREE.DoubleSide
					    cadranSolaireGroup.add(cadran);
						// folderDimensionsSundial.show()
						// folderOrientationSundial.show()
						//axeMondeGroup.add(cadran)
						if(NouveauCadran==true){
						   cs.epaisseur = 300; cs.hauteur =300;cs.largeur=300
					   	   cs.xgnomon = 0; cs.ygnomon = 0;cs.zgnomon = 0
						   cs.decli=0;cs.incli=cs.lati
						}
						cadran.scale.x = cs.largeur;
						cadran.scale.y = cs.hauteur;
						cadran.scale.z = cs.epaisseur;				
						eulerCsGroup()						
						TracerStyle()
					    TracerHeuresEtArcs()						
						render()						
						}
				
				function TracerFichier() {
					var fileInput = document.createElement('input');
					
					fileInput.type = 'file';
					fileInput.multiple = false;
					fileInput.accept = ".ply,.obj"
					fileInput.addEventListener('change', function () {
						const reader = new FileReader();
						const file = fileInput.files[0]
						const NF = file.name.toLowerCase()
						reader.readAsDataURL(file)
						reader.addEventListener("load", () => {
								cs.dataURL=reader.result							
								if (NF.lastIndexOf('.obj') > 0) {
									cs.typedataURL='.obj'
									objloader.load(cs.dataURL, function (Lucymesh) {TracerMesh(Lucymesh)})
								}
								if (NF.lastIndexOf('.ply') > 0) {
									cs.typedataURL='.ply'
									plyloader.load(cs.dataURL, function (LucyGeom) {									
									const Lucymesh = new THREE.Mesh(LucyGeom, materialCS)
									Lucymesh.geometry.computeVertexNormals()
									TracerMesh(Lucymesh)})
								}
								if (NouveauCadran == true) {
									cs.xgnomon = 0; cs.ygnomon = 100; cs.zgnomon = 100
									cs.epaisseur = 1; cs.hauteur = 1; cs.largeur = 1
									cs.decli = 0; cs.incli = 90; cs.rot = 0
								}
								eulerCsGroup()
								EcrireXYZ()
								cs.typeForme = "?"
							}
							, false);
					});
					document.body.appendChild(fileInput);
					fileInput.click();
					cs.typeForme='?'
				}
				
				function TracerCadranParam() {
					//gui.domElement.style.color = 'green';
					materialCS.side = THREE.DoubleSide
					gzfxy.enable()
					zFuncxy = Parser.parse(cs.zfxy).toJSFunction(['x', 'y']) 
					//catch (err) { console.log("Formule incorrecte"); return }
					let funcxyz = (u, v, target) => {
						const xf = (u - 0.5)
						const yf = (v - 0.5)					
						const zf = zFuncxy(xf, yf)/2
						target.set(xf, yf, zf)
					}
					const  geometryCSParam= new ParametricGeometry(funcxyz, 128, 128)
					geometryCSParam.computeVertexNormals() 
					const cadranParam = new THREE.Mesh(geometryCSParam, materialCS);
					cadranParam.castShadow=true
					cadranParam.receiveShadow = true
					cadran = cadranParam.clone()
					
					if (NouveauCadran == true) {
						cs.epaisseur = 10; cs.hauteur = 300; cs.largeur = 300
						cs.xgnomon = 0; cs.ygnomon = 0; cs.zgnomon = 50
						cs.decli = 0; cs.incli = 90
					}
					cadran.scale.x = cs.largeur;
					cadran.scale.y = cs.hauteur;
					cadran.scale.z = cs.epaisseur
					cadranSolaireGroup.add(cadran);
					eulerCsGroup()
					TracerStyle()
					TracerHeuresEtArcs()
					//gui.domElement.style.cursor = "wait";
					//gui.domElement.style.backgroundColor = "black" 
					//render()
					//gui.domElement.style.color = 'white';
				}
				//document.body.style.backgroundColor = "green" 
				//gui.domElement.style.cursor = "wait";
				//gui.domElement.style.backgroundColor = "green" ;
				// gui.domElement.style.cursor = "wait";
				gzfxy.disable()
				cadranSolaireGroup.clear()
				cadranSolaireGroup.add(axeX)
				cadranSolaireGroup.add(axeY)
				cadranSolaireGroup.add(axeZ)
				materialCS.side = THREE.FrontSide
				if (v == "parallelepiped") { cadran = cadranBox.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur }
				if (v == "cylinder") { cadran = cadranCyl.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur }
				if (v == "cone") { cadran = cadranCone.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur }
				if (v == "sphere") { cadran = cadranSph.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur; cs.hauteur = cs.largeur }
				if (v == "equatorial") { cadran = cadranEquatorial.clone(); TracerCadranEquatorial() }
				if (v == "scaphe") { cadran = cadranScaphe.clone(); TracerCadranScaphe() }
				if (v == "file PLY, OBJ...") { TracerFichier() }
				if (v == "parametric") { TracerCadranParam() }
				cadran.receiveShadow = true
				cadran.castShadow=true
				gnomon.visible = false
				eulerCsGroup()
				TracerStyle()
				TracerHeuresEtArcs()
				PlacerLeSoleil()
				render()
				EcrireXYZ()
				
				//gui.domElement.style.backgroundColor = "black" 
				
			
			}
				


			function initMenu(e) {
				//console.log('Debut InitMenu')
				cadranSolaireGroup.clear();		
				cadran=cadranBox.clone()
				if (NouveauCadran == true) {					
					cs.largeur = 600
					cs.hauteur = 400
					cs.epaisseur = 30
					cs.decli = 0
					cs.incli = 90
					cs.hgnomon = 50
					cs.egnomon = 1
					cs.xgnomon = 0
					cs.ygnomon = 100
					cs.zgnomon = 70
					cs.rot=0
					cs.hoursTextSize=1
					cs.dataURL=""
					//cs=csInitial
				}
				
				
				
				MiseEnPlaceCadranEtGnomon()
				cadranSolaireGroup.add(cadran);
				folderDimensionsSundial.show()
				folderOrientationSundial.show()
				gtypeForme.disable()
				if (cs.typeForme=="parametric"){gzfxy.enable()}else{gzfxy.disable()}
				zPosController.disable()
				ctlRot.disable()
				eulerCsGroup()
				PlacerLaTerre()
				PlacerLeSoleil()
				groupAxes.add(axeX)
			    groupAxes.add(axeY)			
			    groupAxes.add(axeZ)
				// cadranSolaireGroup.add(axeX)
				// cadranSolaireGroup.add(axeY)
				// cadranSolaireGroup.add(axeZ)
				cadranSolaireGroup.add(groupAxes)
				EcrireXYZ()
				render

				if (e == SP) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					folderGnomonClassic.show();
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = SP;
					cs.vgnomon = true;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
					gnomon.visible = true
					TracerHeuresEtArcs();				
				};
				if (e == BF) {
					folderGnomonClassic.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.setValue(90);
					cs.incli = 90;
					ctlIncli.disable();
					folderGnomonBifilaireVertical.show()
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = BF;
					calculg1g2k1k2()
					TracerHeuresEtArcs();
				};
				if (e == BFG) {
					folderGnomonClassic.hide();
					folderGnomonBifilaireVertical.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					cs.typeCadran = BFG;
					folderGnomonBifilaireGen.show();
					folderHours.show();
					folderArcs.show();
					TracerHeuresEtArcs()
				}

				if (e == ANL) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderGnomonClassic.hide();
					folderHours.hide();
					folderArcs.hide();
					cadranSolaireGroup.remove(heuresSolairesGroup);
					cadranSolaireGroup.remove(heuresLegalesGroupSA);
					cadranSolaireGroup.remove(heuresLegalesGroupWS);
					cadranSolaireGroup.remove(heuresAntiquesGroup);
					cadranSolaireGroup.remove(heuresBabyloniquesGroup);
					cadranSolaireGroup.remove(heuresItaliquesGroup);
					cadranSolaireGroup.remove(heuresSDSAgroup);
					cadranSolaireGroup.remove(heuresSDWSgroup);
					cadranSolaireGroup.remove(arcsDiurnesGroup);
					gnomon.visible = false;
					ctlIncli.enable();
					//cs.incli=0;eulerCsGroup();
					folderAnalem.show();
					TracerHeuresEtArcs();
				}
				if (e == RTS) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					folderGnomonClassic.hide()
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = RTS;
					TracerCadranRTS(cs.typeForme)
					//TracerHeuresEtArcs();
					gtypeForme.enable()
					zPosController.enable()
					ctlRot.enable()
					if (cs.typeForme=="parametric"){gzfxy.enable()}else{gzfxy.disable()}
				}

				//console.log('Fin InitMenu')
			}


			//let csInitial=cs

			const gui = new GUI(
				{ width: Math.min(Math.round(window.innerWidth / 2), 280), title: "Edit sundial...",closeFolders:true  }
			);
			const sp = "☼ "
			gui.$title.style.color = 'yellow'

			function helpGui(g, textHelp) {
				g.domElement.addEventListener("mouseover", function () {
					//document.getElementById("info").innerHTML=textHelp
					gui.title(textHelp)
				})
				g.domElement.addEventListener("mouseout", function () {
					gui.title("Edit sundial...")
				})
			}


			const guihsol = gui.add(cs, "hsol", 0, 24, 0.01)
				.name("Hour  (0-24)")
				.onChange(function () { PlacerLeSoleil() });
			helpGui(guihsol, 'Decimal hour')

			const guiday = gui.add(cs, "dayofYear", 1, 365, 1)
				.name("Day (1-365))")
				.onChange(function () {
					PlacerLeSoleil();
					if (cs.typeCadran == ANL) TracerStyle();
				});
			helpGui(guiday, 'Day of the year')

			const guiyear = gui.add(cs, "year")
				.name("Year")
				.onFinishChange(function () {
					TS = TableSol(cs.year)
					TracerHeuresEtArcs();
				});

			gui.add(cs, "typeCadran", [SP, BF, BFG, ANL, RTS]).name("type of sundial") ///+++
				.onChange(function (e) {
					NouveauCadran=true
					initMenu(e)
				});

			const gtypeForme = gui.add(cs, "typeForme", ["parallelepiped", "cylinder", "cone", "sphere","equatorial","scaphe","file PLY, OBJ...","parametric"])
			                    .name("form of sundial") ///+++
								.onFinishChange(function(v){TracerCadranRTS(v);gtypeForme.updateDisplay()} )
								.listen()
      
			const gzfxy= gui.add(cs,"zfxy").name("z=f(x,y)")
							.onFinishChange(function(v){
								try{zFuncxy = Parser.parse(cs.zfxy).toJSFunction(['x', 'y']) 
								    TracerCadranRTS("parametric")}
					           catch (err) { alert("Formule incorrecte") }
								})

			const Button2D = {
				function2D() {
					let w; // window
					initSVGtext("auto");
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
					TracerHeuresEtArcs()
					closeSVGtext();
					w = window.open()
					w.name = cs.nameFile
					w.document.write(`					
					<!DOCTYPE html>
					<html lang="en">
  			    	<head>					
					<meta charset="utf-8" />
	                <title>CadsolOnLine 2D ${cs.nameFile}</title>
					</head>
					<body>
					`)
					w.document.write(SVGtext)
					w.document.write(`
					</body>
					</html>
	                `)
					w.document.close()
				}
			}
			gui.add(Button2D, 'function2D').name('2D View');

			const nameW = "List params"
			const ButtonFiche = {
				functionFiche() {
					let w; // window
					//w = window.open("",nameW, "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
					w = window.open()
					w.name = nameW + ":" + cs.nameFiles
					w.document.write(HTLM(cs))
					w.document.close()
				}
			}
			//const fiche = gui.add(ButtonFiche, 'functionFiche').name(nameW);


			//// GEOLOCALISATION
			const folderGeoSundial = gui.addFolder(sp+"Geolocation")
			//folderGeoSundial.domElement.addEventListener
			folderGeoSundial.add(cs, "lati", -90, 90, 0.001)
				.name("Latitude")
				.onChange(() => { orienterAxedumonde(); PlacerLaTerre() })
				.onFinishChange(() => {
					orienterAxedumonde();
					PlacerLaTerre();//eulerEarthGroup()
					PlacerLeSoleil(); TracerHeuresEtArcs()
					if((cs.typeCadran==RTS)&&(cs.typeForme=="equatorial")){TracerCadranRTS("equatorial")}
					if((cs.typeCadran==RTS)&&(cs.typeForme=="scaphe")){TracerCadranRTS("scaphe")}
				})
				.listen();
			folderGeoSundial.add(cs, "longi", -180, 180, 0.001)
				.name("Longitude")
				.onChange(() => {
					PlacerLaTerre()
					cs.offset_sec = Math.trunc(cs.longi / 15) * 3600
				})
				.onFinishChange(() => {
					PlacerLaTerre();//eulerEarthGroup():
					TracerHeuresEtArcs()
				})
				.listen();
			
			

			const folderViewParam = {
				functionViewMap() {
					if (cs.adresse.length > 0) {
						RechercheParAdresse(cs.adresse);
						TracerHeuresEtArcs();
						orienterAxedumonde();
						PlacerLaTerre();
						TracerHeuresEtArcs()
						window.open(cs.urlOpenStreet, "OSM", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
					}
				}
			}
			folderGeoSundial.add(folderViewParam, "functionViewMap")
				.name('Seek by adress')
				
			folderGeoSundial.add(cs, "adresse")
				.name("postal adress")
				.onFinishChange(() => {
					if (cs.adresse.length > 0) {
						RechercheParAdresse(cs.adresse);
						TracerHeuresEtArcs();
						orienterAxedumonde();
						PlacerLaTerre();
						TracerHeuresEtArcs()
						window.open(cs.urlOpenStreet, "OSM", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
					}
				})

			folderGeoSundial.add(cs, "timezone")
				.name("Time zone")
				.listen();
			
			folderGeoSundial.add(cs, "offset_sec", -43200, 43200, 60)
				.name("offset from UTC (sec)")
				.onFinishChange(function (v) {
					cs.offset_sec = v;
					TracerHeuresEtArcs()
				})
				.listen();
			const ofStr=folderGeoSundial.add(cs,"offset_string")
			    .name("+/- HHMM")
			    .listen()
			ofStr.disable()
			//console.log(cs)
			folderGeoSundial.add(cs, "autoLocation")
				.name("auto")
				.onFinishChange(function (v) {
					if (v) {
						getLocation()
						TracerHeuresEtArcs(); orienterAxedumonde();
						PlacerLaTerre()
					}
				})

			//   folderGeoSundial.add(cs,"offset_string") 
			//        .name(" offset (HHMM)");
			//   folderGeoSundial.add(cs,"now_in_dst") 
			//        .name("summer time (H)");

		const folderSundial = gui.addFolder(sp + 'Geometry ');

		
			//// ORIENTATION				
			const folderOrientationSundial = folderSundial.addFolder("Orientation...");
			folderOrientationSundial.add(cs, "decli", -180, 180, 0.1)
				.name("Declinaison °")
				.onChange(() => { eulerCsGroup() })
				.onFinishChange(() => { TracerHeuresEtArcs() })
				.listen()
			const ctlIncli = folderOrientationSundial.add(cs, "incli", -180, 180, 0.1)
				.name("Inclinaison °")
				.onChange(() => { eulerCsGroup() })
				.onFinishChange(() => { TracerHeuresEtArcs() })
				.listen()
			const ctlRot = folderOrientationSundial.add(cs, "rot", -180, 180, 0.1)
				.name("Rotation °")
				.onChange(function (v) {
					eulerCsGroup()
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
				.listen()

			//// DIMENTIONS
			const folderDimensionsSundial = folderSundial.addFolder("Dimensions...");
			folderDimensionsSundial.add(cs, "largeur", 1, 1000, 0.1)
				.name("Width")
				.onChange(() => {
					cadran.scale.x = cs.largeur;
					meshDevise.position.x = -cs.largeur / 2 * 0.9
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
				.listen()
			folderDimensionsSundial.add(cs, "hauteur", 1, 1000, 0.1)
				.name("Height")
				.onChange(function (v) {
					cs.hauteur = v; cadran.scale.y = cs.hauteur;
					meshDevise.position.y = -cs.hauteur / 2 * 0.9;
					PlacerLaTerre()
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
				.listen()
			folderDimensionsSundial.add(cs, "epaisseur", 1, 1000, 0.1)
				.name("Depth")
				.onChange(function (v) {
					cs.epaisseur = v;
					cadran.scale.z = cs.epaisseur;
					meshDevise.position.z = cs.epaisseur / 2;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
				.listen();

			//// STYLE

			const folderGnomon = folderSundial.addFolder('Shadow by ...');

			//// ANALEMMATIQUE  +++

			const folderAnalem = folderGnomon.addFolder("Analematic gnomon");
			folderAnalem.add(cs, "xdirect", -89, 89, 0.1)
				.name("← → °")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderAnalem.add(cs, "ydirect", -89, 89, 0.1)
				.name("↑ ↓ °")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			//folderAnalem.add(cs, "zdirect", -500, 500, 0.1)
			//	.name("Alt")
			//	.onChange(function () {TracerStyle()})
			//	.onFinishChange(function () {TracerHeuresEtArcs()});
			folderAnalem.add(cs, "Hanalem", 1, 500, 0.1)
				.name("Gnomon length")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderAnalem.add(cs, "Ranalem", 1, 500, 0.1)
				.name("elliptical radius")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			//folderAnalem.add(cs, "Canalem")
			//	.name("Central projection")
			folderAnalem.addColor(cs, "colorAnalem")
				.name("Color")
				.onChange(function (e) {
					materialAnalem.color = new THREE.Color(e);
					cs.colorAnalem = materialAnalem.color.getStyle();
				});
			folderAnalem.add(cs, "textSizeANL", 0, 5, 0.1)
				.name("Font size")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderAnalem.add(cs, "dateAnalem", 1, 31, 1)
				.name("date (1..31)")
				.onFinishChange(function () {
					TracerStyle()
					TracerHeuresEtArcs()
				});




			/// Style droit ou polaire
			const folderGnomonClassic = folderGnomon.addFolder('Straight or polar style...');
			folderGnomonClassic.add(cs, "hgnomon", 1, 1000, 0.1)
				.name("Length straight style")
				.onChange(function (e) {
					cs.hgnomon = e;
					gnomon.scale.y = cs.hgnomon;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
				
				})	
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonClassic.add(cs, "vgnomon")
				.name("straight style visible")
				.onChange(function (e) {
					cs.vgnomon = e
					gnomon.visible = e
				
				})
			folderGnomonClassic.add(cs, "vstyle")
				.name("polar style visible")
				.onChange(function (e) {
					//TracerHeuresEtArcs()				    
					stylePolaire.visible = e
				})
			folderGnomonClassic.add(cs, "vsousstyle")
				.name("under style visible")
				.onChange(function (e) {
					//TracerHeuresEtArcs()			    
					sousStylaire.visible = e
				})


			// filaire vertical

			const folderGnomonBifilaireVertical = folderGnomon.addFolder('Wires...');
			folderGnomonBifilaireVertical.add(cs, "anglefilHorizontal", 0, 180, 0.1)
				.name("angle  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "anglefilVertical", 0, 180, 0.1)
				.name("angle  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "hfilHorizontal", 1, 500, 0.1)
				.name("height  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "hfilVertical", 1, 500, 0.1)
				.name("height  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })




			// filaire gen	        

			const folderGnomonBifilaireGen = folderGnomon.addFolder('Wires...');

			folderGnomonBifilaireGen.add(cs, "anglefilHorizontal", 0, 180, 0.1)
				.name("angle  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "anglefilVertical", 0, 180, 0.1)
				.name("angle  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hA1", 0, 1000, 0.1)
				.name("height A1")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hA2", 0, 1000, 0.1)
				.name("height A2")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hB1", 0, 1000, 0.1)
				.name("height B1")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hB2", 0, 1000, 0.1)
				.name("height B2")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })


			const folderGnomonPosition = folderGnomon.addFolder('Position ...');

			folderGnomonPosition.add(cs, "xgnomon", -1000, 1000, 0.1)
				.name("← xOx →")
				.onChange(function () {
					gnomon.position.x = cs.xgnomon;
					TracerStyle()
					gnomon.visible = cs.vgnomon && (cs.typeCadran == SP)//||(cs.typeCadran == RTS))
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
				.listen()
			folderGnomonPosition.add(cs, "ygnomon", -1000, 1000, 0.1)
				.name("↑  yOy  ↓")
				.onChange(function () {
					gnomon.position.y = cs.ygnomon;
					TracerStyle()
					gnomon.visible = cs.vgnomon && (cs.typeCadran == SP)//||(cs.typeCadran == RTS))
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
				.listen()
			const zPosController=folderGnomonPosition.add(cs, "zgnomon", -1000, 1000, 0.1)
				.name("/  zOz  /")
				.onChange(function () {
					TracerStyle()
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
				.listen()

			folderGnomon.add(cs, "egnomon", 0.1, 5, 0.01)
				.name("Thickness")
				.onChange(function () {
					TracerStyle()
				})
				.onFinishChange(function () {
					gnomon.scale.x = cs.egnomon;
					gnomon.scale.z = cs.egnomon;
					TracerHeuresEtArcs()
				});






			//// COLOR             
			const folderColorsSundial = gui.addFolder(sp+"Color and texture");
			materialCS.color.setStyle(cs.colorCS);
			materialCS.emissive.setStyle(cs.emissiveCS);
			// materialCS.specular.setStyle(cs.specularCS); 
			materialCS.metalness = cs.metalness;
			materialCS.transparent = true;
			materialCS.opacity = cs.opaciteCS;
			materialCS.map=choixTextures[cs.nameTexture] 
			folderColorsSundial.addColor(cs, 'colorCS').name('reflection').onChange(function (e) {
				materialCS.color = new THREE.Color(e);
				cs.colorCS = materialCS.color.getStyle();
			});
			folderColorsSundial.addColor(cs, 'emissiveCS').name('emition').onChange(function (e) {
				materialCS.emissive = new THREE.Color(e);
				cs.emissiveCS = materialCS.emissive.getStyle();
			});
			folderColorsSundial.add(materialCS, 'metalness', 0, 1, 0.01)
				.onChange(function(e) {cs.metalness= materialCS.metalness})
				
			folderColorsSundial.add(materialCS, 'roughness', 0, 1, 0.01)
				.onChange(function(e) {cs.roughness= materialCS.metalness})
			//   folderColorsSundial.addColor(controlCS, 'specular').onChange(function (e) {
			//        materialCS.specular = new THREE.Color(e);
			//        cs.specularCS=materialCS.specular.getStyle();
			//        });
			//   folderColorsSundial.add(materialCS, 'shininess', 0, 100, )              
			folderColorsSundial.add(cs, 'opaciteCS', 0, 1, 0.01)
				.name('opacity').onChange(function (e) {
					materialCS.transparent = true;
					cs.opaciteCS = e;
					materialCS.opacity = e
				});
			folderColorsSundial.add(materialCS, 'wireframe')
				.onChange(function (v) {
					cs.wireframe=v
					materialGnomon.wireframe = v;
					materialHeuresSolaires.wireframe = v;
					materialHeuresLegalesSA.wireframe = v;
					materialHeuresLegalesWS.wireframe = v;
					materialArcsDiurnes.wireframe = v
				});

			
			// folderColorsSundial.add(choixTextures, 'steel', choixTextures).name('Texture')
			// 	.onChange(function (t) {
			// 		materialCS.map = t
			// 		materialCS.needsUpdate=true
			// 	});

			folderColorsSundial.add(cs, 'nameTexture', choixTextures).name('Texture')
				.onChange(function (t) {
					materialCS.map = t
					materialCS.needsUpdate=true
					if (t==null) {cs.name='none'}else{cs.nameTexture=t.name}
				});

			//let  heure= {nom:"Solar (local true time)",trace:true,couleur:cs.colorHS,tailleFonte:cs.textSizeHS}     

			const folderHours = gui.addFolder(sp + 'Hours');
			materialHeuresSolaires.color.setStyle(cs.colorHS);
			materialHeuresLegalesSA.color.setStyle(cs.colorHLSummerAutums);
			materialHeuresLegalesWS.color.setStyle(cs.colorHLWinterSpring);
			materialHeuresAntiques.color.setStyle(cs.colorHeuresAntiques);
			materialHeuresBabyloniques.color.setStyle(cs.colorHeuresBabyloniques);
			materialHeuresItaliques.color.setStyle(cs.colorHeuresItaliques);
			materialHeuresSDSA.color.setStyle(cs.colorHeuresSDSA);
			materialHeuresSDWS.color.setStyle(cs.colorHeuresSDWS);
			materialAnalem.color.setStyle(cs.colorAnalem);


			folderHours.add(cs, 'heuresSolaires')
				.name(HS)
				.onChange(function (e) {
					//cs.heuresSolaires=e;
					if (e) { cs.textSizeHS = cs.hoursTextSize; TracerHeuresSolaires() } else { cadranSolaireGroup.remove(heuresSolairesGroup) }
				});
			folderHours.addColor(cs, 'colorHS')
				.name('      color-> ')
				.onChange(function (e) {
					materialHeuresSolaires.color = new THREE.Color(e);
					cs.colorHS = materialHeuresSolaires.color.getStyle()
				});
			folderHours.add(cs, 'heuresLegalesSummerAutums')
				.name(HLSA)
				.onChange(function (e) {
					if (e) { cs.textSizeSA = cs.hoursTextSize; TracerHeuresLegalesSA() } else { cadranSolaireGroup.remove(heuresLegalesGroupSA) }
				});
			folderHours.addColor(cs, 'colorHLSummerAutums')
				.name('      color-> ')
				.onChange(function (e) {
					materialHeuresLegalesSA.color = new THREE.Color(e);
					cs.colorHLSummerAutums = materialHeuresLegalesSA.color.getStyle()
				});
			folderHours.add(cs, 'heuresLegalesWinterSpring')
				.name(HLWS)
				.onChange(function (e) {
					if (e) { cs.textSizeWS = cs.hoursTextSize; TracerHeuresLegalesWS() } else { cadranSolaireGroup.remove(heuresLegalesGroupWS) }
				});
			folderHours.addColor(cs, 'colorHLWinterSpring')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresLegalesWS.color = new THREE.Color(e);
					cs.colorHLWinterSpring = materialHeuresLegalesWS.color.getStyle()
				});
			folderHours.add(cs, 'heuresAntiques')
				.name(HA)
				.onChange(function (e) {
					if (e) { cs.textSizeHA = cs.hoursTextSize; TracerHeuresAntiques() } else { cadranSolaireGroup.remove(heuresAntiquesGroup) }
				});
			folderHours.addColor(cs, 'colorHeuresAntiques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresAntiques.color = new THREE.Color(e);
					cs.colorHeuresAntiques = materialHeuresAntiques.color.getStyle()
				});
			folderHours.add(cs, 'heuresBabyloniques')
				.name(HB)
				.onChange(function (e) {
					if (e) { cs.textSizeHB = cs.hoursTextSize; TracerHeuresBabyloniques() } else { cadranSolaireGroup.remove(heuresBabyloniquesGroup) }
				});
			folderHours.addColor(cs, 'colorHeuresBabyloniques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresBabyloniques.color = new THREE.Color(e);
					cs.colorHeuresBayloniques = materialHeuresBabyloniques.color.getStyle()
				});
			folderHours.add(cs, 'heuresItaliques')
				.name(HI)
				.onChange(function (e) {
					if (e) { cs.textSizeHI = cs.hoursTextSize; TracerHeuresItaliques() } else { cadranSolaireGroup.remove(heuresItaliquesGroup) }
				});
			folderHours.addColor(cs, 'colorHeuresItaliques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresItaliques.color = new THREE.Color(e);
					cs.colorHeuresItaliques = materialHeuresItaliques.color.getStyle()
				});
			folderHours.add(cs, 'heuresSideralesSA')
				.name(HSDSA)
				.onChange(function (e) {
					if (e) { cs.textSizeSDSA = cs.hoursTextSize; TracerHeuresSDSA() } else { cadranSolaireGroup.remove(heuresSDSAgroup) }
				});
			folderHours.addColor(cs, 'colorHeuresSDSA')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresSDSA.color = new THREE.Color(e);
					cs.colorHeuresSDSA = materialHeuresSDSA.color.getStyle()
				});
			folderHours.add(cs, 'heuresSideralesWS')
				.name(HSDWS)
				.onChange(function (e) {
					if (e) { cs.textSizeSDWS = cs.hoursTextSize; TracerHeuresSDWS() } else { cadranSolaireGroup.remove(heuresSDWSgroup) }
				});
			folderHours.addColor(cs, 'colorHeuresSDWS')
				.name("      color->  ")
				.onFinishChange(function (e) {
					materialHeuresSDWS.color = new THREE.Color(e);
					cs.colorHeuresSDWS = materialHeuresSDWS.color.getStyle()
				});
			const folderHoursOptions = folderHours.addFolder("Options (choose before tracing)")
			folderHoursOptions.add(cs, 'hoursTextSize', 0, 5, 0.1).name('Font size')

			const subDiv = {
				"meridienne":12,
				"1 heure": 1,
				"30 min": 0.5,
				"15 min": 0.25,
				"10 min": 1 / 6,
				" 5 min": 1 / 12
			}
			folderHoursOptions.add(cs, "subDivisions", subDiv)
				.name('Subdivisions')
				.onChange(TracerHeuresEtArcs())

			const precisionH = {
				"one day": 1,
				"2 days": 2,
				"5 days": 5,
				"10 days":10
			}
			folderHoursOptions.add(cs, "precisionHours", precisionH)
				.name('precision (days)')
				.onChange(TracerHeuresEtArcs())



			///// ARCS



			let dateArc = { day: 1, month: 1, function1() { tracerArc() }, function2() { effaceArcs() } };
			const folderArcs = gui.addFolder(sp+'Diurnials arcs...');
			//  const folderDate= folderArcs.addFolder('Date')
			folderArcs.add(dateArc, "day", 1, 31, 1)
				.name("Day of the month")
			//  .onChange(function(v){dateArc.trace=false});
			folderArcs.add(dateArc, "month", 1, 12, 1)
				.name("Month of the year")
			//  .onChange(function(v){dateArc.trace=false});						  
			folderArcs.add(dateArc, 'function1')
				.name("trace one arc");
			folderArcs.add(dateArc, 'function2')
				.name("delete all arcs");
			function tracerArc() {
				let j = 0, s = "";
				j = JULIAN.DayOfYearGregorian(cs.year, dateArc.month, dateArc.day)
				s = dateArc.day + '/' + dateArc.month + '/' + cs.year
				cs.datesArcsDiurnes.push([s, TS.decSuns[j]])
				TracerArcsDiurnes()
			}
			function effaceArcs() {
				// cs.datesArcsDiurnes=cs.datesArcsDiurnes.filter(
				// function(d){return((d[0]=='so.')||(d[0]=='eq.'))})	
				// TracerArcsDiurnes()	
				cs.datesArcsDiurnes = [[]]
				cs.equinoxeAndSolstices = false
				TracerArcsDiurnes()
			}

			folderArcs.add(cs, 'equinoxeAndSolstices')
				.name('Equinoxe and solstices')
				.onChange(function (v) {
					cs.equinoxeAndSolstices = v;
					if (v) {
						cs.datesArcsDiurnes.unshift(['solstice', base.toRad(-23.44)])
						cs.datesArcsDiurnes.unshift(['solstice', base.toRad(23.44)])
						cs.datesArcsDiurnes.unshift(['equinoxe', 0])
					}
					else {
						cs.datesArcsDiurnes = cs.datesArcsDiurnes.filter(function (d) {
							return ((d[0] !== 'solstice') && (d[0] !== 'equinoxe'))
						})
					}
					//cs.datesArcsDiurnes=[];
					TracerArcsDiurnes()
					//console.log(cs.datesArcsDiurnes)
				})
				.listen();

			materialArcsDiurnes.color.setStyle(cs.colorequinoxeAndSolstice);
			folderArcs.addColor(cs, 'colorequinoxeAndSolstice')
				.name("color ")
				.onChange(function (e) {
					materialArcsDiurnes.color = new THREE.Color(e);
					cs.colorequinoxeAndSolstice = materialArcsDiurnes.color.getStyle()
				});

			const precisionA = {
				"one minute": 1,
				" 5 min": 5,
				"10 min": 15,
				"30 min": 30,
				"60 min": 60
			}
			folderArcs.add(cs, "precisionArcs", precisionA)
				.name('precision (min)')
				.onChange(TracerHeuresEtArcs());





			///// Displays and animations


			const folderView = gui.addFolder(sp + 'Displays and animations');



			folderView.add(cs, "axesESZ").name("East,South,Zenith")
				.onChange(function (e) { cs.axesESZ = e; axesESZHelper.visible = e });
			
			folderView.add(cs, "axesXYZ").name("axes X,Y,Z")
				.onChange(function (e) {
					axeX.visible = e; axeY.visible = e; axeZ.visible = e
					if (e == true) {EcrireXYZ()}else{ effacelisteMesh(labelAxesListeMesh,groupAxes) }
				});

			folderView.add(cs, "voirTerre").name("Earth")
				.onChange(function (e) {
					cs.voirTerre = e; PlacerLaTerre()
				});


			const Vsun = {
				"0": 0,
				"1sec  /sec": 1,
				"1min  /sec": 60,
				"10min /sec": 600,
				"20min /sec": 1200,
				"30min /sec": 1800,
				"1h    /sec": 3600
			}
			folderView.add(cs, "vrotSun", Vsun)
				.name('Rotation of sun')
				.onChange(function (e) { RotationSoleil(e) });

			folderView.add(cs, "vrotscene", 0, 10, 1)
				.name('Rotation of the scene')
				.listen;


			///// DEVISE
			const folderDevise = folderView.addFolder('Motto ...');
			folderDevise.add(cs, 'devise').name('text')
				.onChange(function (v) {
					cs.devise = v;
					
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				});
			folderDevise.add(cs, 'deviseSize', 0, 5, 0.1).name('font size')
				.onChange(function (v) {
					cs.deviseSize = v;
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				});
			folderDevise.add(cs, "positionDevisex", -500, 500, 0.1)
				.name("← →")
				.onChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.onFinishChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.listen
			folderDevise.add(cs, "positionDevisey", -500, 500, 0.1)
				.name("↑ ↓")
				.onChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.onFinishChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})

			//// backGround
			//console.log(cs.background)
			folderView.addColor(cs,'background')
				.name('wallpaper')
				.onChange(function () {
					scene.background = new THREE.Color(cs.background)
				})
			//	.onFinishChange(function () {localStorage.setItem("BackGround",cs.background)})
			/// link
			folderView.add(cs, "linkMedia").name("link web")
			const btnMedia = { lireMedia() { if (cs.linkMedia.length > 0) { window.open(cs.linkMedia) } } }
			folderView.add(btnMedia, "lireMedia").name("open link")


			///// EXPORT
			const folderFiles = gui.addFolder(sp + 'Export');
			const ButtonDownload = {
				functionDownload() {
					effacelisteMesh(labelAxesListeMesh,groupAxes)
					let e = cs.export
					if (e == "Sundial(.JSON)") { saveString(JSON.stringify(cs, null, 2), cs.nameFile + '.json') };
					if (e == "Spreadsheet(.CSV)") {
						initCSVtext(); TracerHeuresEtArcs();
						saveString(CSVtext, cs.nameFile + '.csv')
					};
					if (e == "Ephemeris(.CSV)") { Ephemerid(cs.year); saveString(CSVephemerid, 'Ephemerid' + cs.year + '.csv') };
					if (e == "3D(.PLY)") { saveString(GenererPLY(), cs.nameFile + ".PLY") };
					if (e == "3D(.OBJ)") { saveString(GenererOBJ(), cs.nameFile + ".OBJ") };
					if (e == "3D(.STL)") { saveString(GenererSTL(), cs.nameFile + ".STL") };
					if (e == "Scal.Vect.Graph.(.SVG)") {
						initSVGtext(cs.unitSVG);
						EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
						TracerHeuresEtArcs()
						closeSVGtext();
						saveString(SVGtext, cs.nameFile + '.svg')
					    };
					if (e =="Params (.HTML)"){saveString(HTLM(cs), cs.nameFile + '.html')}
					EcrireXYZ()
				}
			}


//			

			folderFiles.add(ButtonDownload, 'functionDownload').name('Download');
			folderFiles.add(cs, "nameFile").name("File name")

			folderFiles.add(cs, "export",
				["Sundial(.JSON)", "Spreadsheet(.CSV)", "3D(.PLY)", "3D(.OBJ)", "3D(.STL)", 
				"Ephemeris(.CSV)", "Scal.Vect.Graph.(.SVG)", "Params (.HTML)"])
				.name('Type of file')
				.onChange(function (e) {
					if (e == "Scal.Vect.Graph.(.SVG)") { unitsSVG.enable() } else { unitsSVG.disable() };
					if (e == "Spreadsheet(.CSV)") { sepCSV.enable() } else { sepCSV.disable() }
				});


			const absoluteUnits = {
				"millimeters": "mm",
				"quarters-millimeters(0.25mm)": "Q",
				"centimeters": "cm",
				"inches (2.54cm)": "in",
				"pixels": "px",
				"auto": "auto"
			}
			const unitsSVG = folderFiles.add(cs, "unitSVG", absoluteUnits)
				.name('SVG units')
			//   .onChange(function(e){});

			

			const separateurCSV = {
				"semicolon": ";",
				"comma ": ",",
				"espace": " "
			}
			const sepCSV = folderFiles.add(cs, "separateurCSV", separateurCSV)
				.name('CSV separator')
			//   .onChange(function(e){});

			unitsSVG.disable();
			sepCSV.disable()
			unitsSVG.disable();

			// // Exemples --------------------------------------------------------------------------------------

			const folderSamples = gui.addFolder(sp+"Exemples")
			let urlServeur = location.href
			function newSundial(nf) {
				if (urlServeur.indexOf("#") > 0) { urlServeur = urlServeur.substring(0, urlServeur.indexOf("#")) }
				window.open(urlServeur + "#" + nf)
			}
			let objEx = {
				myEx1: function () { newSundial('Bab&Ita-DSavoie-p278.json') },
				myEx2: function () { newSundial('Antiques-DSavoie-p301.json') },
				myEx3: function () { newSundial('Sideral-DSavoie-p291.json') },
				myEx4: function () { newSundial('CollinEx1.json') },
				myEx5: function () { newSundial('CollinEx4.json') },
				myEx6: function () { newSundial('LambertAustral.json') },
				myEx7: function () { newSundial('LambertBoreal.json') },
				myEx8: function () { newSundial('ParentOccidental.json') },
				myEx9: function () { newSundial('CadranHerstmonceux.json') },
				myEx10: function () { newSundial('BifilaireOslo.json') },
				myEx11: function () { newSundial('HorizontalCusco.json') },
				myEx12: function () { newSundial('SpheriqueOeilleton.json') },
				myEx13: function () { newSundial('PolaireCylindrique.json') },
				myEx14: function () { newSundial('ConeDeclinant.json') },
				myEx15: function () { newSundial('Liberty.json') },
				myEx16: function () { newSundial('ToleOndulee.json') },
				myEx17: function () { newSundial('Paraboloid.json') }
			}
			const CadPolairesEx = folderSamples.addFolder('Polar or straigth style');
			CadPolairesEx.add(objEx, 'myEx1').name("Bab&Ita-D.Savoie-p278");
			CadPolairesEx.add(objEx, 'myEx2').name("Hours antics-D.Savoie p301")
			CadPolairesEx.add(objEx, 'myEx3').name('Sideral-DSavoie-p291');
			CadPolairesEx.add(objEx, 'myEx11').name('Horizontal Cusco (Perou)');

			const BifilairesEx = folderSamples.addFolder('Bifilar');
			BifilairesEx.add(objEx, 'myEx4').name("D.Collin Ex1");
			BifilairesEx.add(objEx, 'myEx5').name("D.Collin Ex4");
			BifilairesEx.add(objEx, 'myEx10').name("Generalised Bifilar Oslo");

			const AnalemEx = folderSamples.addFolder('Analemmatic');
			AnalemEx.add(objEx, 'myEx6').name("Lambert austral");
			AnalemEx.add(objEx, 'myEx7').name("Lambert boreal");
			AnalemEx.add(objEx, 'myEx8').name("Parent Occidental");
			AnalemEx.add(objEx, 'myEx9').name("Herstmonceux");

			const RayTracingEx = folderSamples.addFolder('Ray Tracing');
			RayTracingEx.add(objEx, 'myEx12').name("Spheric with oeilleton");
			RayTracingEx.add(objEx, 'myEx13').name("Polar cylindric sundial");
			RayTracingEx.add(objEx, 'myEx14').name("Declining Cone");
			RayTracingEx.add(objEx, 'myEx15').name("Lyberty");
			RayTracingEx.add(objEx, 'myEx16').name("Corrugated sheet");
			RayTracingEx.add(objEx, 'myEx17').name("Paraboloid");



			//generateGeometry;   

			scene.add(axeLocalisation);
			scene.add(cadranSolaireGroup);
			scene.add(axeMondeGroup);
			scene.add(earthGroup);

			MiseEnPlaceCadranEtGnomon()
			
			cadranSolaireGroup.add(cadran);
			//    cadranSolaireGroup.add( gnomon );
			//    cadranSolaireGroup.add( boutGnomon );
			//    cadranSolaireGroup.add( debutGnomon );
			// cadranSolaireGroup.add( boutGnomon );

			orienterAxedumonde()
			PlacerLaTerre()
			eulerCsGroup();
			//eulerEarthGroup() 

			PlacerLeSoleil();
			PlacerLaTerre();
			sphereEarth.rotation.y = -Math.PI * 0.5;


			//cs.autoCloseMenu=true
			

			const couleurMenu = "#C8FAFF"
			for (let g = 0; g < gui.folders.length; g++) {
				gui.folders[g].$title.style.color = couleurMenu
				gui.folders[g].close()
				if (cs.autoCloseMenu) {
					gui.folders[g].domElement.addEventListener("mouseleave", function () {
						gui.folders[g].close()
					})
					gui.folders[g].domElement.addEventListener("mouseenter", function () {
						gui.folders[g].open()
					})
				}
			}


			CadPolairesEx.close()
			BifilairesEx.close()
			AnalemEx.close()
			RayTracingEx.close()


			initMenu(cs.typeCadran)
			scene.background = new THREE.Color(cs.background);
			materialCS.opacity = cs.opaciteCS
			materialCS.metalness = cs.metalness
			materialCS.wireframe = cs.wireframe
			materialCS.map = choixTextures[cs.nameTexture]
			//console.log( cs.nameTexture,choixTextures[cs.nameTexture])
			materialCS.needsUpdate = true
			if (cs.typeCadran == RTS) { TracerCadranRTS(cs.typeForme) }
			EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
			if (cs.typedataURL == '.obj') {
				objloader.load(cs.dataURL, function (Lucymesh) {
					TracerMesh(Lucymesh)
					TracerHeuresEtArcs()
				})
			}
			if (cs.typedataURL == '.ply') {
				plyloader.load(cs.dataURL, function (LucyGeom) {
					const Lucymesh = new THREE.Mesh(LucyGeom, materialCS)
					Lucymesh.geometry.computeVertexNormals()
					TracerMesh(Lucymesh)
					TracerHeuresEtArcs()
				})
			}
			TracerHeuresEtArcs()
			
			EcrireXYZ()
	
		}//end init



		//  EXPORT---------------------------------------------------------------------------------

		function GenererPLY() {
			const plyExporter = new PLYExporter();
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			s = plyExporter.parse(cadranSolaireGroup,data => {}, { binary: false})
			console.log(s)
			//exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}

		function GenererOBJ() {
			const objExporter = new OBJExporter();
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			s = objExporter.parse(cadranSolaireGroup)
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}

		function GenererSTL() {
			const stlExporter = new STLExporter();
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			s = stlExporter.parse(cadranSolaireGroup, { binary: false })
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}






		//-------------------------------------------------------------------------------------------------------------

		function orienterAxedumonde() {

			axeMonde.setDirection(new THREE.Vector3(0, Math.sin(cs.lati * Math.PI / 180),
				-Math.cos(cs.lati * Math.PI / 180)));
			axeMonde.setLength(600, 30, 10);
			//   helperLight.update()
			//   axeMonde.visible=cs.voirTerre;
			//   axeMonde.visible=false;

		}

		//--------------------------------------------------------------------------------------
		function PlacerLeSoleil() {
			const k = 2 * 600;
			const v3 = new THREE.Vector3();
			
			let h, he, min, sec, y, m, d, dec, eqt, date, sdate, hsol;

			h = Math.floor(cs.hsol);
			min = Math.floor((cs.hsol - h) * 60);
			sec = Math.floor((cs.hsol - h - min / 60) * 3600);
			//console.log(cs.hsol,sec)
			h = (h < 10) ? "0" + h : h;
			min = (min < 10) ? "0" + min : min;
			sec = (sec < 10) ? "0" + sec : sec;

			date = JULIAN.JDToCalendarGregorian(TS.jdates[cs.dayofYear - 1]);
			//jde= JULIAN.CalendarGregorianToJD(cs.year, date.month, date.day); 
			dec = base.toDeg(TS.decSuns[cs.dayofYear - 1]);

			dec = Math.round(dec * 1000) / 1000;

			eqt = Math.round(SEXA.secFromHourAngle(TS.eqtimes[cs.dayofYear - 1]));
			//hsol=cs.hsol + eqt/3600 +(cs.longi/15 - cs.offset_sec/3600); //correction de l'heure
			hsol = cs.hsol + eqt / 3600   // correction eq. du temps
			if (cs.typeCadran != ANL) { hsol += cs.longi / 15 - cs.offset_sec / 3600 }   // pas d'heure légale avec un analemmatique
			//console.log(cs.typeCadran,ANL,cs.typeCadran!=ANL)
			d = Math.floor(date.day); m = date.month; y = date.month;
			d = (d < 10) ? "0" + d : d;
			m = (m < 10) ? "0" + m : m;
			sdate = d + "/" + m + "/" + date.year;  //date JJ/MM/YYYY

			sphereSun.position.z = k * Math.cos(base.toRad(dec)) * Math.cos(base.toRad(-(hsol - 12) * 15));
			sphereSun.position.x = k * Math.cos(base.toRad(dec)) * Math.sin(base.toRad(-(hsol - 12) * 15));
			sphereSun.position.y = k * Math.sin(base.toRad(dec));

			sphereSun.getWorldPosition(v3);
			light.position.set(v3.x, v3.y, v3.z).normalize();
			light.castShadow = (v3.y > 0)  // le soleil dit être au dessus de l'horizon	
			
			labeltime.innerHTML = h + ":" + min + ':' + sec + "  " + sdate + " dec:" + dec.toFixed(3) + "°  eqt:" + eqt + 's'
			//labeldeceqt.innerHTML="dec:"+dec.toFixed(3)+"°  eqt:"+eqt+'s'
			//  helperLight.update()
			
			if (cs.typeCadran == RTS) {
				if (lineRay != undefined) {
					lineRay.geometry.dispose()
					cadranSolaireGroup.remove(lineRay)
				}
				if (v3.y > 0) { CoordRayTracing((hsol - 12) / 12 * Math.PI, TS.decSuns[cs.dayofYear - 1], true) }
			}
		}

		function myTimerSun() {
			cs.hsol += cs.vrotSun / 360000;
			if (cs.hsol > 24) { cs.hsol = 0 };
			PlacerLeSoleil()
		}
		let temporisation = null;
		function RotationSoleil(e) {
			window.clearInterval(temporisation);
			if (e > 0) { temporisation = window.setInterval(myTimerSun, 10) }; //    1/100 sec
		}

		
		
		// -------------------------------------------------------------------------------------------------------
		function CoordRayTracing(hrad, dec, trace = false) {   // hrad: angle horaire en radians de -Pi a Pi   dec: declinaison du soleil en radians
			    const [sh, ch] = base.sincos(-hrad)
				const [sd, cd] = base.sincos(dec)
				let rayOrigin = new THREE.Vector3();    // origine du rayon lumineux virtuel : centre du tore de coord. cs.xgnomon,  cs.ygnomon cs.zgnomon
				// en cord. locales, liées au cadran, les axes x, y et z sont visibles sur l'écran
				let rayDirection = new THREE.Vector3();   // direction rayon (vecteur de norme 1)
				let coordRayCaster = new THREE.Vector3();   // coord. de l'ombre tore sur le cadran en coord. locales (c'est le pont 3D à trouver)
				let intersects

				const k = 1200;  //constante arbitraire

				rayOrigin.set(cs.xgnomon / cadran.scale.x, cs.ygnomon / cadran.scale.y, cs.zgnomon / cadran.scale.z)  // ces facteur d'echelle sont liés au dimensions du cadran
				cadran.localToWorld(rayOrigin)   // changement de repere, il faut passer des coord. locales aux coord. globales

				// sphereSun.position.z = k * Math.cos(dec) * Math.cos(-hrad);   // calcul des coord. du soleil virtuel
				// sphereSun.position.x = k * Math.cos(dec) * Math.sin(-hrad);
				// sphereSun.position.y = k * Math.sin(dec);
				sphereSun.position.z = k * cd*ch   // calcul des coord. du soleil virtuel
				sphereSun.position.x = k * cd*sh
				sphereSun.position.y = k * sd
				sphereSun.getWorldPosition(rayDirection)   //memorisation dans le vecteur 3D rayDirection
				rayDirection.normalize();  // normalisation
				rayCaster.set(rayOrigin, rayDirection)
				intersects = rayCaster.intersectObject(cadran)  //le tore est-il à l'ombre du cadran?
				if (intersects.length > 0) {
					return {              // tore à l'ombre, ok=false
						x: 0,
						y: 0,
						z: 0,
						ok: false
					}
				} else {
					rayDirection.negate();  // changement de sens, le vecteur point vers l'origine du repère global
					rayCaster.set(rayOrigin, rayDirection)  // l'objet rayCaster a été initialisé au début du code par : const rayCaster = new THREE.Raycaster()  (variable globale)
					// rayCaster virtualise le rayon lumineux ayant direction du soleil (rayDirection) et passant par de centre du tore (rayOrigin) 
					intersects = rayCaster.intersectObject(cadran); // c'esi la ligne la plus importante du code: recherche de l'intersection du rayon et du cadran
					// le cadran est modélisé par un maillage de trangles
					if (intersects.length > 0) {                          // s'il ya au moins une intersection, les coord. du point sont dans intersects[0].point
						coordRayCaster = cadran.worldToLocal(intersects[0].point)   // on revient aux coord.locales
						coordRayCaster.set(coordRayCaster.x * cadran.scale.x, coordRayCaster.y * cadran.scale.y, coordRayCaster.z * cadran.scale.z)// il reste à remettre à l'échelle
						if (trace == true) {
							cadran.worldToLocal(rayOrigin)
							rayOrigin.set(rayOrigin.x * cadran.scale.x, rayOrigin.y * cadran.scale.y, rayOrigin.z * cadran.scale.z)
							const geometryRay = new THREE.BufferGeometry().setFromPoints([rayOrigin, coordRayCaster]);
							const materialRay = new THREE.LineBasicMaterial({ color: 0xffffff });//ligne blanche
							lineRay = new THREE.Line(geometryRay, materialRay);
							cadranSolaireGroup.add(lineRay);
						}

						return {
							x: coordRayCaster.x,   //retour des coord de l'ombre, en coord locales, ok=true
							y: coordRayCaster.y,
							z: coordRayCaster.z,
							ok: true
						}
					}
					else return {              // si pas d'ombre, ok=false
						x: 0,
						y: 0,
						z: 0,
						ok: false
					}
				}
				
			}
		
		// Terre ---------------------------------------------------------------------------------------------------
		function PlacerLaTerre() {
			let r, l;
			r = cs.hauteur;
			if (r<100){r=100}
			sphereEarth.scale.x = r; sphereEarth.scale.y = r; sphereEarth.scale.z = r;
			meshClouds.scale.set(sphereEarth.scale.x*cloudsScale, sphereEarth.scale.y*cloudsScale, sphereEarth.scale.z*cloudsScale);
			earthGroup.position.x = 0;
			earthGroup.position.y = -(cs.hauteur / 2 + r) * 1.2;
			earthGroup.position.z = 0;
			earthGroup.rotation.x = -base.toRad(90 - cs.lati);
			earthGroup.rotation.y = -base.toRad(cs.longi);
			earthGroup.visible = cs.voirTerre;
			axeTerre.setLength(r * 1.5, r * 1.5 * 0.1, r * 1.5 * 0.02);
			l = -earthGroup.position.y - r;
			axeLocalisation.setLength(l, 0.1 * l, 0.02 * l)
			axeLocalisation.visible = cs.voirTerre;

			//	console.log(renderer.info)

		}

		//---------------------------------------------------------------------------------------------------------

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);

		}


		function animate() {
	
			requestAnimationFrame(animate);

			if (cs.vrotscene > 0) { scene.rotation.y += 0.001 * cs.vrotscene } else { scene.rotation.y = 0 };
			meshClouds.rotation.y += 0.00001;
			render();
			stats.update();

			//document.body.style.cursor = "auto"
		}

		//

		function render() {

			renderer.render(scene, camera);

		}
		
	</script>
	

</body>

</html>