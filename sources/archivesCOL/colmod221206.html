<!DOCTYPE html>
<html lang="en">


<head>
	<title>CadsolOnLine 3D</title>
	<link rel="icon" type="image/x-icon" href="./favicon.ico">
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0">
	<link type="text/css" rel="stylesheet" href="./main221130.css">
</head>

<body>

	<div id="container">
		<div id="info">
			<h1>CadSolOnLine</h1>
			<div id="ver">" " </div>
			<!-- Calculation of sundials on line</br> -->
			by JL.Astre and Y.Mass√©<br>
			Help: <a href="https://cadsolonline.web-pages.fr" target="_blank">cadsolonline.web-pages.fr </a> <br>
			Library 3D: <a href="https://threejs.org" target="_blank" >Three.js</a> <br>
			Astronomical library: 
			<a href="https://en.wikipedia.org/wiki/Jean_Meeus" target="_blank" rel="noopener">Jean Meeus & </a>
			<a href="https://en.wikipedia.org/wiki/Sonia_Keys" target="_blank" rel="noopener">Sonia Keys</a>  <br>
            <!-- <a href="https://github.com/commenthol/astronomia" target="_blank" rel="noopener">commenthol</a></br>--> 
			<p>
				<img src="./imageMoret.jpg" alt="Image" style="max-width:100%;height:auto">
			</p>	
			<label for="jsoninput"> > Open the Sundial ...</label>
			</br></br>
			<div id="menu"> </div>
			
			<input type="file" id="jsoninput" accept=".json">
			

			<script>
				const docinputjson = document.getElementById('jsoninput');
				docinputjson.style.opacity = 0;
			</script>

		</div>

		<!-- <input type="range" min="1" max="100" value="50" class="slider" id="myRange">  -->
		<div id="time"> </div>

	</div>

	<!-- <div id="deceqt"> </div> -->

	<script type="module">
		document.body.style.cursor = "wait"

		import * as THREE from '../build/three.module.js';  //146dev
		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/lil-gui.module.min.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { apparentEquatorial } from '../astronomia-master/src/solar.js';
		import * as JULIAN from '../astronomia-master/src/julian.js';
		import * as base from '../astronomia-master/src/base.js';
		//   import * as EQTIME from '../astronomia-master/src/eqtime.js';	
		import * as SEXA from '../astronomia-master/src/sexagesimal.js';

		import { FontLoader } from './jsm/loaders/FontLoader.js';
		import { TextGeometry } from './jsm/geometries/TextGeometry.js';
		import * as BUFGEOUTILS from './jsm/utils/BufferGeometryUtils.js';
		import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';
		//import { DDSLoader } from './jsm/loaders/DDSLoader.js';
		import { PLYExporter } from './jsm/exporters/PLYExporter.js';
		//import { GLTFExporter } from './jsm/exporters/GLTFExporter.js';
		import { OBJExporter } from './jsm/exporters/OBJExporter.js';
		import { STLExporter } from './jsm/exporters/STLExporter.js';



		document.getElementById("jsoninput").addEventListener('change', function () { loadJsonFile() });



		const HS = "solar",
			HLSA = "legal (summer autumn)",
			HLWS = "legal (winter spring)", HA = "Antique",
			HB = 'babylonic', HI = "italic",
			HSDSA = "Sidereals (summer, autumn)",
			HSDWS = "Sidereals (winter, spring)";

		import { SP, BF, BFG, ANL,RTS, cs, TableSol, RechercheParAdresse, getLocation, eclair,HTLM } from './colvars.js';
	

		cs.version = "2022/11/30"


		let CSVtext = "", SVGtext = "", CSVephemerid = ""


		let container, stats, buttonNewSundial;
		let camera, scene, renderer;
		container = document.getElementById('container');

		// camera

		camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 5, 10000);
		camera.position.set(2000, 2000, 2000);
		//camera.position.set( 0, 0, 2000 );

		// scene
		scene = new THREE.Scene();
		scene.background = new THREE.Color(cs.background);
		//scene.fog = new THREE.Fog( 0xaaaaaa, 10, 10000 );
		// light

		const light = new THREE.DirectionalLight(0xffffff);
		light.position.set(0, 1, 1).normalize();

		const ambientLight = new THREE.AmbientLight(0x303030); // soft white light
		//const ambientLight = new THREE.LightProbe(); 
		scene.add(ambientLight);

		//Set up shadow properties for the light
		light.shadow.mapSize.width = 2048 * 4; // default
		light.shadow.mapSize.height = 2048 * 4; // default
		light.shadow.camera.near = -1000; // default
		light.shadow.camera.far = 1000; // default
		light.shadow.camera.top = 1000;
		light.shadow.camera.bottom = -1000;
		light.shadow.camera.right = 1000;
		light.shadow.camera.left = -1000;


		light.castShadow = true; // default false
		scene.add(light);
		//const helperLight = new THREE.DirectionalLightHelper( light, 100 );
		//scene.add( helperLight );

		// renderer

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		//renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.shadowMap.enabled = true;
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
		renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
		//renderer.toneMapping=THREE.LinearToneMapping;
		container.appendChild(renderer.domElement);

		// renderer.setPixelRatio( window.devicePixelRatio );
		// renderer.outputEncoding = THREE.sRGBEncoding;

		// stats
		stats = new Stats();
		container.appendChild(stats.dom);

		// OrbitControls
		const controls = new OrbitControls(camera, renderer.domElement);
		controls.minDistance = 1;
		controls.maxDistance = 10000;

		//addEventListener
		window.addEventListener('resize', onWindowResize);
		controls.addEventListener('change', render);

		//Button New Sundial
		buttonNewSundial = document.createElement('button');
		buttonNewSundial.innerHTML = 'New Sundial';
		const menu = document.getElementById('menu');
		menu.appendChild(buttonNewSundial);
		buttonNewSundial.addEventListener("click", function () { run() });


		//
		const labeltime = document.getElementById('time');
		labeltime.innerHTML = 'Time';
		// const labeldeceqt = document.getElementById( 'deceqt' );
		// labeldeceqt.innerHTML = 'deceqt';

		const version = document.getElementById('ver');
		version.innerHTML = "Version: " + cs.version

		let cadranSolaireGroup, axeMondeGroup, earthGroup;
		let cadran, gnomon, meshDevise, stylePolaire, sousStylaire, styleAnalem, filHorizontal, filVertical, pilierH1, pilierH2, pilierH3, pilierH4;
		let heuresSolairesGroup, heuresLegalesGroupSA, heuresLegalesGroupWS, heuresAntiquesGroup, arcsDiurnesGroup;
		let heuresBabyloniquesGroup, heuresItaliquesGroup, heuresSDSAgroup, heuresSDWSgroup;
		let heuresSolairesListeMesh, heuresLegalesListeMeshSA, heuresLegalesListeMeshWS, heuresAntiquesListeMesh,
			heuresBabyloniquesListeMesh,
			heuresItaliquesListeMesh,
			heuresSDSAListeMesh, heuresSDWSListeMesh,
			arcsDiurnesListeMesh;

		let analemGroup, analemListeMesh;   // +++


		cadranSolaireGroup = new THREE.Group();

		heuresSolairesGroup = new THREE.Group();
		heuresLegalesGroupSA = new THREE.Group();
		heuresLegalesGroupWS = new THREE.Group();
		heuresAntiquesGroup = new THREE.Group();
		heuresBabyloniquesGroup = new THREE.Group();
		heuresItaliquesGroup = new THREE.Group();
		heuresSDSAgroup = new THREE.Group();
		heuresSDWSgroup = new THREE.Group();
		arcsDiurnesGroup = new THREE.Group();

		analemGroup = new THREE.Group();///+++

		heuresSolairesListeMesh = [];
		heuresLegalesListeMeshSA = [];
		heuresLegalesListeMeshWS = [];
		heuresAntiquesListeMesh = [];
		heuresBabyloniquesListeMesh = [];
		heuresItaliquesListeMesh = [];
		heuresSDSAListeMesh = [];
		heuresSDWSListeMesh = [];

		arcsDiurnesListeMesh = [];

		analemListeMesh = [];//+++

		//const texture = new THREE.TextureLoader().load( 'metaltexture.jpg' );
		// const materialCST = new THREE.MeshBasicMaterial( { map: texture } );
		const textureAcier = new THREE.TextureLoader().load('metaltexture.jpg')
		const textureCuivre = new THREE.TextureLoader().load('metall001-new-tileable.png');
		const textureFruits = new THREE.TextureLoader().load('fruits.jpg');
		const textureAsphalt = new THREE.TextureLoader().load('asphalt.jpg');
		let texture = textureAcier
		const optionsMaterial = { roughness: 0.5, metalness: 0.5, transparent: true, opacity: 1, side: THREE.DoubleSide, map: texture }
		const materialHeuresSolaires = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresLegalesSA = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresLegalesWS = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresAntiques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresBabyloniques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresItaliques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresSDSA = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresSDWS = new THREE.MeshStandardMaterial(optionsMaterial);

		const materialAnalem = new THREE.MeshStandardMaterial(optionsMaterial);// +++

		const materialArcsDiurnes = new THREE.MeshStandardMaterial(optionsMaterial);


		const materialCS = new THREE.MeshStandardMaterial(
			{ transparent: true, opacity: 0.8, roughness: 0.5, map: textureAcier });
		const geometryCS = new THREE.BoxGeometry(1, 1, 1);
		//const geometryCS = new THREE.SphereGeometry(1,32,32);
		cadran = new THREE.Mesh(geometryCS, materialCS);

		const materialGnomon = new THREE.MeshStandardMaterial(
			{ transparent: true, opacity: 1, roughness: 0.1, metalness: 0.5, side: THREE.DoubleSide, color: 0xffffff, map: textureAcier });
		const geometryGnomon = new THREE.CylinderGeometry(1, 1, 1, 16);
		gnomon = new THREE.Mesh(geometryGnomon, materialGnomon);

		// const geometryboutGnomon= new THREE.SphereGeometry( 1, 32,32 );   
		// const boutGnomon=new THREE.Mesh( geometryboutGnomon, materialGnomon );
		//const debutGnomon=new THREE.Mesh( geometryboutGnomon, materialGnomon );
		//gnomon.add(boutGnomon)
		//gnomon.add(debutGnomon)
		// boutGnomon.visible=true
		//materialCS.depthWrite=false; 
		//materialHeuresSolaires.tramage=true; 
		//materialHeuresSolaires.precision="highp"

		// Axe de rotation de la terre
		const axeMonde = new THREE.ArrowHelper(
			new THREE.Vector3(0, Math.sin(cs.lati * Math.PI / 180), -Math.cos(cs.lati * Math.PI / 180)),
			new THREE.Vector3(0, 0, 0),
			Math.max(cs.largeur, cs.hauteur, cs.epaisseur),
			0xffff00, 30, 15);


		axeMondeGroup = new THREE.Group();
		axeMondeGroup.add(axeMonde);
		axeMonde.visible = false;

		const textureLoader = new THREE.TextureLoader();

		const earthGeometry = new THREE.SphereGeometry(1, 32, 32);
		const earthMaterial = new THREE.MeshPhongMaterial({
			specular: 0x333333,
			emissive: "rgb(5,5,5)",
			shininess: 5,
			map: textureLoader.load('./earth_pm_2048.jpg'),
			specularMap: textureLoader.load('textures/planets/earth_specular_2048.jpg'),
			normalMap: textureLoader.load('textures/planets/earth_normal_2048.jpg'),
			normalScale: new THREE.Vector2(1, 1)
		});
		earthMaterial.tranparent = true;
		earthMaterial.opacity = 0.5;
		const sphereEarth = new THREE.Mesh(earthGeometry, earthMaterial);
		earthGroup = new THREE.Group();
		earthGroup.add(sphereEarth);


		const geometrySun = new THREE.SphereGeometry(15, 32, 16);
		const materialSun = new THREE.MeshPhongMaterial({
			//color: 0xffff00, 
			//specular: 0x333333,
			emissive: "rgb(100,100,5)",
			shininess: 5,
			map: textureLoader.load('./sun.jpg')
		});
		const sphereSun = new THREE.Mesh(geometrySun, materialSun);
		axeMondeGroup.add(sphereSun);
		sphereSun.parent = axeMonde;
		//const raySun= new THREE.Ray()
		const rayCaster = new THREE.Raycaster()


		const axeTerre = new THREE.ArrowHelper(
			new THREE.Vector3(1, 1, 1),
			new THREE.Vector3(0, 0, 0),
			Math.max(cs.largeur, cs.hauteur, cs.epaisseur),
			0xffffff, 30, 15);
		earthGroup.add(axeTerre);


		const axeLocalisation = new THREE.ArrowHelper(
			new THREE.Vector3(0, -1, 0),
			new THREE.Vector3(0, 0, 0),
			Math.max(cs.largeur, cs.hauteur, cs.epaisseur),
			0x00ff00, 30, 15);


		let TS = TableSol(cs.year)
		//  const dd=JULIAN.JDToCalendarGregorian(TS.solJuin)     
		//    console.log((JULIAN.JDToCalendarGregorian(TS.solJuin).month))
		//    console.log(JULIAN.JDToDate(TS.solJuin))
		//    console.log(Math.floor(dd.day)+"/"+dd.month+"/"+dd.day)

		let fontDevise, fontText;
		loadFontDevise();

		//let ligneDate = "";



		const NFexemple = location.hash.substring(1)

		console.log(NFexemple)
		if (NFexemple.length > 0) {
			openSundial(NFexemple)
			buttonNewSundial.innerHTML = NFexemple;
		}

		document.body.style.cursor = "auto"
		
		window.addEventListener("keypress",kPress)

		function kPress(evt){
			if ((evt.ctrlKey)&&(evt.keyCode==10)){cs.autoCloseMenu= !cs.autoCloseMenu}
			}
		

		///////////////////////////////////////////////////////////////////////////////////////////////			  

		function openSundial(NFexemple) {
			let csl
			let request = new XMLHttpRequest();
			request.open('GET', './Samples/' + NFexemple);
			request.responseType = 'text';
			request.onload = function () {
				//console.log(request.response);
				cadranSolaireGroup.clear()
				try { csl = JSON.parse(request.response) }
				catch (e) { console.error("Parsing error:", e) }
				//console.log(JSON.stringify(csl,null,2));
				for (var k in csl) { cs[k] = csl[k] }
				//console.log(JSON.stringify(cs,null,2));
				TS = TableSol(cs.year);
			};

			request.send();

		}

		//-----------------------------------------------------------------------------------------------------				          
		function run() {
			document.body.style.cursor = "wait"
			init();

			animate();

		}

		function ligneCSV(texte,x0,y0){
			const s=cs.separateurCSV
			const xg=x0-cs.xgnomon
			const yg=y0-cs.ygnomon
			CSVtext+=texte+s+x0.toFixed(2)+s+y0.toFixed(2)+s+"  "+s+xg.toFixed(2)+s+yg.toFixed(2)+"\n"
		}

		function initCSVtext() {
			let s=cs.separateurCSV
			CSVtext = "CadsolOnLine      " + s + "   XO   " + s + "  YO  " +s+"       "+s+"  XG  "+s+"  YG   \n\n";
			CSVtext += " Version: " + cs.version + "\n\n"
			CSVtext +=" XO YO  origin : center of the sundial \n"
			CSVtext +=" XG YG  origin : foot of the gnomon \n"
			CSVtext += "\n\n";
			CSVtext += "Sundial: "+cs.nameFile
			CSVtext += "\n\n";

		}


		function initSVGtext(unit) {
			SVGtext =
				`<?xml version="1.0" standalone="no"?>
<svg 
`
			if (unit == "auto") { SVGtext += `width="100%" height="auto"` }
			else { SVGtext += `width="${cs.largeur.toString() + unit}" height="${cs.hauteur.toString() + unit}"` }

			SVGtext += ` viewBox="0 0 ${cs.largeur.toString()} ${cs.hauteur.toString()}" preserveAspectRatio="xMinYMin meet"
  xmlns="http://www.w3.org/2000/svg">

  <desc> 

  CadsolOnLine  ${cs.version}
  
  </desc>

  <rect x="0" y="0" width="${cs.largeur.toString()}" height="${cs.hauteur.toString()}" 
   fill="${cs.colorCS}" stroke="black" stroke-width="1px" />
 
  
`

			// <rect x="0" y="0" width="${cs.largeur.toString()}" height="${cs.hauteur.toString()}"
			//         fill="none" stroke="black" stroke-width="1"/>
			//   width="${cs.largeur.toString()+cs.unitSVG}" height="${cs.hauteur.toString()+cs.unitSVG}"
			//height="auto"
		}

		function closeSVGtext() {
			SVGtext += '</svg>';
			// console.log(SVGtext)
		}





		//----------------------------------------------------------------------------
		function loadFontDevise() {
			const loader = new FontLoader();
			loader.load('./fonts/helvetiker_regular.typeface.json', function (response) {
				fontDevise = response
			});
			loader.load('./fonts/helvetiker_regular.typeface.json', function (response) {
				fontText = response
			});

		}

		// Ecritures------------------------------------------------------------  
		function EcrireDevise(texte, x, y) {
			if (cs.deviseSize == 0) return;
			const fontGeometry = new TextGeometry(texte, {
				font: fontDevise,
				size: 10 * cs.deviseSize,             //ajuster sur largeur
				height: 2 * cs.deviseSize,           //ajuster sur largeur
				curveSegments: 4,
				bevelEnabled: true,
				bevelThickness: 0.5 * cs.deviseSize, //ajuster sur largeur
				bevelSize: 0.5 * cs.deviseSize,      //ajuster sur largeur
				bevelOffset: 0,
				bevelSegments: 1
			});

			if (typeof (meshDevise) !== "undefined") { cadranSolaireGroup.remove(meshDevise) };
			meshDevise = new THREE.Mesh(fontGeometry, materialGnomon);
			cadranSolaireGroup.add(meshDevise);
			meshDevise.position.x = x;
			meshDevise.position.y = y;
			meshDevise.position.z = cs.epaisseur / 2

			if (SVGtext.length > 0) {
				//	${materialGnomon.color.getStyle()}
				x = x + cs.largeur / 2; y = -y + cs.hauteur / 2;
				SVGtext += `<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.deviseSize * 10).toString()}" font-family='Courier New'  stroke="black" > ${cs.devise}</text>
           `
			}
		}

		function EcrireTexte(texte, x, y, material, group, listeMesh, gauche = false) {
			if (cs.hoursTextSize == 0) return;

			let mesh
			const fontGeometry = new TextGeometry(texte, {
				font: fontText,
				size: 7 * cs.hoursTextSize,             //ajuster sur largeur
				height: 1 * cs.hoursTextSize,           //ajuster sur largeur
				curveSegments: 4,
				bevelEnabled: true,
				bevelThickness: 0.25 * cs.hoursTextSize, //ajuster sur largeur
				bevelSize: 0.25 * cs.hoursTextSize,      //ajuster sur largeur
				bevelOffset: 0,
				bevelSegments: 1
			});


			mesh = new THREE.Mesh(fontGeometry, material);

			group.add(mesh);
			//if (listeMesh){listeMesh.push(mesh)};
			listeMesh.push(mesh);
			if (gauche) { x = x - (texte.length - 1) * 7 * cs.hoursTextSize }//else{x=x+7*cs.hoursTextSize}
			if ((x + 7 * cs.hoursTextSize) > (cs.largeur / 2 - 5)) { x -= 14 * cs.hoursTextSize }
			if ((y + 7 * cs.hoursTextSize) > (cs.hauteur / 2 - 5)) { y -= 14 * cs.hoursTextSize }
			mesh.position.x = x;
			mesh.position.y = y;
			mesh.position.z = cs.epaisseur / 2;

			if (SVGtext.length > 0) {
				x = x + cs.largeur / 2; y = -y + cs.hauteur / 2;
				//if (gauche) {texte=texte+"  "}else{texte="  "+texte}
				SVGtext += `<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.hoursTextSize * 10).toString()}" font-family="Courier New" stroke="${material.color.getStyle()}"> ${texte}</text>
           `
			}

		}


		//-----------------------------------------------------------------------------------------------------
		function Ephemerid(year) {
			let d, s;

			CSVephemerid = " DATE" + cs.separateurCSV + "TIME EQUATION (s)" + cs.separateurCSV + "SUN DECLINATION (¬∞)" + cs.separateurCSV + "Julian Day" + "\n"
			CSVephemerid += " \n";
			CSVephemerid += "Ephemerids year:  " + cs.year + "\n\n";
			CSVephemerid += "CadsolOnLine  Version:" + cs.version + "\n\n";
			CSVephemerid += "(c) Jean Meeus \n* Chapter 28 Equation of time \n* Chapter 25  Solar Coordinates ...\n\n";
			CSVephemerid += " \n";
			//   const TS=TableSol(cs.year);
			for (let i = 0; i < TS.decSuns.length; i++) {
				d = JULIAN.JDToCalendarGregorian(TS.jdates[i]);
				CSVephemerid += d.day + "/" + d.month + "/" + d.year + cs.separateurCSV;  //date JJ/MM/YYYY
				s = Math.round(SEXA.secFromHourAngle(TS.eqtimes[i]));	// equation du temps en secondes	
				CSVephemerid += s.toFixed(0) + '     ' + cs.separateurCSV;
				s = base.toDeg(TS.decSuns[i]);  //dec soleil en degres
				CSVephemerid += s.toFixed(4);
				if (i == TS.jdecSunMin) { CSVephemerid += "  Winter Solstice " }
				if (i == TS.jdecSunMax) { CSVephemerid += "  Summer Solstice " }
				CSVephemerid += cs.separateurCSV
				CSVephemerid += TS.jdates[i];
				CSVephemerid += "\n"
			}
		}

		//------------------------------------------------------------------------------------------------------------
		function TracerHeuresEtArcs() {
			//document.body.style.cursor="wait"
			initCSVtext()
			if (cs.typeCadran == ANL) {
				TracerAnalem();
				EcrirelesDates()
			} else {
				if (cs.heuresSolaires) { TracerHeuresSolaires() }
				if (cs.heuresLegalesWinterSpring) { TracerHeuresLegalesWS() }
				if (cs.heuresLegalesSummerAutums) { TracerHeuresLegalesSA() }
				if (cs.heuresAntiques) { TracerHeuresAntiques() }
				if (cs.heuresBabyloniques) { TracerHeuresBabyloniques() }
				if (cs.heuresItaliques) { TracerHeuresItaliques() }
				if (cs.heuresSideralesSA) { TracerHeuresSDSA() }
				if (cs.heuresSideralesWS) { TracerHeuresSDWS() }
				TracerArcsDiurnes()
			}
			TracerStyle()
			//document.body.style.cursor="auto"
		}



		function Rot(x, y, r) {
			r *= Math.PI / 180;
			return [Math.cos(r) * x + Math.sin(r) * y, -Math.sin(r) * x + Math.cos(r) * y];
		}

		function EtoC(x, y, z) {             // Changement de coordonn√©es √©quatoriales --> cadran
			[z, x] = Rot(z, x, 90 - cs.lati);  // ... dans le rep√®re local
			[x, y] = Rot(x, y, cs.decli);
			[z, x] = Rot(z, x, cs.incli);      // ... dans le rep√®re cadran
			return [x, y, z];
		}


		let xd = 0, yd = 0, zd = 1    // Direction Gnomon analemmatique  Modif AJL 
		function Proj([x, y, z]) {            // Projection sur le cadran avec mise √† la dimension R
			return new Point(cs.Ranalem * (y - z * xd / zd), cs.Ranalem * (-x - z * yd / zd));
		}

		function TracerAnalem() {
			cs.hoursTextSize = cs.textSizeANL
			effacelisteMesh(analemListeMesh, analemGroup)
			//CSVtext += "\n\n"
			//CSVtext += 'Solar hours'+"\n\n"

			var frh = 1, cl = 0, fh = 0; // Pour 
			var al = eclair();	// Angles horaires limites
			var hd = Math.floor(Math.round(2 * frh * (al[0] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var h1 = Math.ceil(Math.round(2 * frh * (al[1] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var h2 = Math.floor(Math.round(2 * frh * (al[2] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var hf = Math.ceil(Math.round(2 * frh * (al[3] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			if (hf >= hd + 24) hf = hd + 24;

			var ob = .4091;		// Obliquit√© de l'√©cliptique
			var prp = 50;			// Rapport des longueurs de l'√©chelle des dates et des tirets
			var nsg = 4;			// Nombre de segment par heure
			var x, y, z;
			// Ligne horaire
			var pths = [];
			for (let hv = hd * nsg; hv <= hf * nsg; hv++) {
				[x, y] = Rot(1, 0, 15 * hv / nsg);    // Direction du point horaire dans le rep√®re polaire
				pths.push(Proj(EtoC(x, y, 0)));
			}
			CSVtext+= "Ellipse \n\n"
			traceAnalem(pths, cs.egnomon, 100);  //+++ Trac√© de l'ellipse
			CSVtext+= "\n\n"
			// pths.splice(0, pths.length);		// Vide le tableau
			// [x, y] = Rot(1, 0, 15*(cs.hsol - 0.05));    // Direction du point horaire dans le rep√®re polaire
			// pths.push(Proj(EtoC(x, y, 0)));
			// [x, y] = Rot(1, 0, 15*(cs.hsol + 0.05));    // Direction du point horaire dans le rep√®re polaire
			// pths.push(Proj(EtoC(x, y, 0)));
			// traceAnalem(pths,3*cs.egnomon,10);  //+++ Trace pour cs.hsol
			for (let hv = hd; hv <= hf; hv++) {
				pths.splice(0, pths.length);		// Vide le tableau
				[x, y] = Rot(1, 0, 15 * (hv - 0.05));    // Direction du point horaire dans le rep√®re polaire
				pths.push(Proj(EtoC(x, y, 0)));
				[x, y] = Rot(1, 0, 15 * (hv + 0.05));    // Direction du point horaire dans le rep√®re polaire
				pths.push(Proj(EtoC(x, y, 0)));
				CSVtext+= "hour: " +hv.toString()+ " H \n"
				traceAnalem(pths, 3 * cs.egnomon, 10);  //+++ Trace pour cs.hsol
				[x, y] = Rot(1, 0, 15 * hv)
				// [x, y]=Proj(EtoC(x, y, 0))
				EcrireTexte(hv.toString(),
					Proj(EtoC(x, y, 0)).x + cs.xgnomon,
					Proj(EtoC(x, y, 0)).y + cs.ygnomon,
					materialAnalem, analemGroup, analemListeMesh)

			}

			CSVtext+= "\n\n"
			pths.splice(0, pths.length);		// Vide le tableau
			// Ligne des dates
			CSVtext+= "Line for the date \n"
			pths.push(Proj(EtoC(0, 0, Math.tan(-ob))));
			pths.push(Proj(EtoC(0, 0, Math.tan(ob))));
			//dx, dy = (y2 - y1)/prp, (x1 - x2)/prp;
			traceAnalem(pths, cs.egnomon / 2, 10);  //+++ Trac√© de la ligne des dates

			cadranSolaireGroup.add(analemGroup);
		}

		function traceAnalem(points, eptrait, npoints) {
			let tubeGeometry, mesh, xp, yp, zp, pipeSpline, pipeSplineCRC, xs, ys;
			pipeSpline = [];
			if (SVGtext.length > 0) {
				SVGtext += ` 
		          <polyline fill="none" stroke="${materialAnalem.color.getStyle()}" stroke-width="${eptrait}"
		           points= " `
			}
			for (let p = 0; p < points.length; p++) {
				xp = points[p].x + cs.xgnomon;
				yp = points[p].y + cs.ygnomon;
				zp = (cs.epaisseur + cs.egnomon) / 2;
				pipeSpline.push(new THREE.Vector3(xp, yp, zp));
				//CSVtext += "point: " + cs.separateurCSV + xp.toFixed(2) + cs.separateurCSV + yp.toFixed(2) + "\n";
				ligneCSV("point",xp,yp)
				if (SVGtext.length > 0) {
					xs = xp + cs.largeur / 2; ys = -yp + cs.hauteur / 2;
					SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
				}
			}
			if (SVGtext.length > 0) { SVGtext += `" />` }
			if (pipeSpline.length > 1) {
				pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline, false, 'chordal', 1);
				tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, npoints, eptrait, npoints, false);
				mesh = new THREE.Mesh(tubeGeometry, materialAnalem);
				//mesh.receiveShadow = true;
				analemListeMesh.push(mesh);
				analemGroup.add(mesh);
			}
		}

		// --------------------------------------------------------------------------------------------------------
		function pointDansCadran(x, y) {
			return ((Math.abs(x) <= (cs.largeur / 2)) && (Math.abs(y) <= (cs.hauteur / 2)))
		}
		//---------------------------------------------------------------------------------------------------------
		let g1, g2, k1, k2;
		function calculg1g2k1k2() {

			const a = cs.hfilHorizontal
			const b = cs.hfilVertical
			const e = b - a
			const [sinj1, cosj1] = base.sincos(base.toRad(cs.anglefilHorizontal))
			const [sinj2, cosj2] = base.sincos(base.toRad(cs.anglefilVertical))
			const sinj1mj2 = Math.sin(base.toRad(cs.anglefilHorizontal - cs.anglefilVertical))
			g1 = (b * sinj2 * cosj1 - a * sinj1 * cosj2) / sinj1mj2
			g2 = (b * sinj1 * cosj2 - a * sinj2 * cosj1) / sinj1mj2
			k1 = e * cosj1 * cosj2 / sinj1mj2
			k2 = e * sinj1 * sinj2 / sinj1mj2
		}

		function ligneSVG(xg, yg, xp, yp) {
			if (SVGtext.length > 0) {
				xg = xg + cs.largeur / 2; yg = -yg + cs.hauteur / 2
				xp = xp + cs.largeur / 2; yp = -yp + cs.hauteur / 2
				SVGtext += `
			<line x1="${xg.toFixed(3)}" y1="${yg.toFixed(3)}" x2="${xp.toFixed(3)}" y2="${yp.toFixed(3)}"
			stroke="black" stroke-width="1"/>
			`}
		}

		function croixSVG(x, y) {
			ligneSVG(x - 3, y - 3, x + 3, y + 3)
			ligneSVG(x - 3, y + 3, x + 3, y - 3)
		}


		function EcrirelesDates() {
			let pg, xp, yp, j, jde, ae, agauche, js, ms, mm, jj
			//cs.hoursTextSize*=0.5
			CSVtext+="\n\n"
			CSVtext+="Date for the style \n\n"
			for (let m = 1; m < 13; m++) {
				j = cs.dateAnalem
				jde = JULIAN.CalendarGregorianToJD(cs.year, m, j);
				mm = JULIAN.JDToCalendarGregorian(jde).month
				jj = JULIAN.JDToCalendarGregorian(jde).day
				ae = apparentEquatorial(jde);
				pg = Proj(EtoC(0, 0, Math.tan(ae.dec)));
				xp = pg.x + cs.xgnomon; yp = pg.y + cs.ygnomon
				// const gradGeo=new THREE.ConeGeometry();const gradMesh=new THREE.Mesh(gradGeo,materialAnalem)
				// cadranSolaireGroup.add(gradMesh)
				// gradMesh.position.set(xp,yp,cs.epaisseur/2)
				// gradMesh.scale.set(cs.egnomon,cs.egnomon,cs.egnomon)
				// gradMesh.rotateX(Math.PI/2) 
				//debutGnomon.position.x=xp;	debutGnomon.position.y=yp ; debutGnomon.position.z= (cs.egnomon+cs.epaisseur)/2
				if ((jde > TS.solJuin) && (jde < TS.solDecembre)) { agauche = true } else { agauche = false }
				js = jj.toString()
				ms = mm.toString(); if (m < 10) { ms = '0' + ms }
				if (agauche) {
					EcrireTexte(js + "/" + ms + " ", xp, yp, materialAnalem, analemGroup, analemListeMesh, true)
					ligneSVG(xp - 4, yp, xp, yp)
				}
				else {
					EcrireTexte(js + "/" + ms, xp + 4, yp, materialAnalem, analemGroup, analemListeMesh, false)
					ligneSVG(xp, yp, xp + 4, yp)
				}
				ligneCSV(js + "/" + ms + " : ",xp,yp)
			}
			//cs.hoursTextSize*=2
		}

		function TracerStyle() {
			let v10, v20, v30, v40, xg, yg, xp, yp, OK = true;

			function TracerFil(alpha, hfil1, hfil2) {
				let x1, y1, x2, y2, x3, y3, x4, y4, x10, y10, x20, y20;
				let coordFil = [];
				const a = Math.tan(alpha / 180 * Math.PI)
				const b = cs.ygnomon - a * cs.xgnomon
				const h = cs.hauteur / 2; const l = cs.largeur / 2;
				x1 = (h - b) / a; y1 = h; if (pointDansCadran(x1, y1)) { coordFil.push([x1, y1]) }
				x2 = l; y2 = l * a + b; if (pointDansCadran(x2, y2)) { coordFil.push([x2, y2]) }
				x3 = (-h - b) / a; y3 = -h; if (pointDansCadran(x3, y3)) { coordFil.push([x3, y3]) }
				x4 = -l; y4 = (-l) * a + b; if (pointDansCadran(x4, y4)) { coordFil.push([x4, y4]) }
				OK = (coordFil.length == 2)
				if (OK) {
					x10 = coordFil[0][0]; y10 = coordFil[0][1]
					v10 = new THREE.Vector3(x10, y10, (cs.epaisseur / 2 + hfil1))
					x20 = coordFil[1][0]; y20 = coordFil[1][1]
					v20 = new THREE.Vector3(x20, y20, (cs.epaisseur / 2 + hfil2))
				}
				return OK
			}



			if (typeof (stylePolaire) !== "undefined") { stylePolaire.geometry.dispose() };
			if (typeof (sousStylaire) !== "undefined") { stylePolaire.geometry.dispose() };
			if (typeof (styleAnalem) !== "undefined") { styleAnalem.geometry.dispose() };
			cadranSolaireGroup.remove(stylePolaire);
			cadranSolaireGroup.remove(sousStylaire);
			cadranSolaireGroup.remove(styleAnalem);
			if (typeof (filHorizontal) !== "undefined") { filHorizontal.geometry.dispose() };
			if (typeof (filVertical) !== "undefined") { filVertical.geometry.dispose() };
			cadranSolaireGroup.remove(filHorizontal);
			cadranSolaireGroup.remove(filVertical);
			if (typeof (pilierH1) !== "undefined") { pilierH1.geometry.dispose() };
			if (typeof (pilierH2) !== "undefined") { pilierH2.geometry.dispose() };
			if (typeof (pilierH3) !== "undefined") { pilierH3.geometry.dispose() };
			if (typeof (pilierH4) !== "undefined") { pilierH4.geometry.dispose() };
			cadranSolaireGroup.remove(pilierH1);
			cadranSolaireGroup.remove(pilierH2);
			cadranSolaireGroup.remove(pilierH3);
			cadranSolaireGroup.remove(pilierH4);





			if (cs.typeCadran == SP) {
				if (cs.angleStyleSousstylaire > 0.4) {
					//  Si l'angle Style polaire-SousStylaire> 0.4¬∞
					const v1 = new THREE.Vector3(cs.xPole + cs.xgnomon, cs.yPole + cs.ygnomon, (cs.epaisseur + cs.egnomon) / 2);
					const v2 = new THREE.Vector3(cs.xgnomon, cs.ygnomon, cs.hgnomon + (cs.epaisseur + cs.egnomon) / 2);
					const tubeGeometrySP = new THREE.TubeGeometry(new THREE.LineCurve3(v1, v2), 16, cs.egnomon, 8);
					stylePolaire = new THREE.Mesh(tubeGeometrySP, materialGnomon);
					stylePolaire.castShadow = true;
					cadranSolaireGroup.add(stylePolaire);
					stylePolaire.visible = cs.vstyle;
					// Sous-stylaire
					const v3 = new THREE.Vector3(cs.xPole + cs.xgnomon, cs.yPole + cs.ygnomon, (cs.epaisseur + cs.egnomon) / 2);
					const v4 = new THREE.Vector3(cs.xgnomon, cs.ygnomon, (cs.epaisseur + cs.egnomon) / 2);
					const tubeGeometrySS = new THREE.TubeGeometry(new THREE.LineCurve3(v3, v4), 16, cs.egnomon, 8);
					sousStylaire = new THREE.Mesh(tubeGeometrySS, materialGnomon);
					sousStylaire.castShadow = true;
					cadranSolaireGroup.add(sousStylaire);
					sousStylaire.visible = cs.vsousstyle

					cadranSolaireGroup.add(gnomon)

					//	boutGnomon.visible= cs.vgnomon	||cs.vstyle
					//	boutGnomon.visible= cs.vsousstyle || cs.vstyle
					//	debutGnomon.visible=cs.vstyle||cs.vsousstyle


					//	boutGnomon.position.x=v2.x;debutGnomon.position.y=v2.y;debutGnomon.position.z=v2.z
					//	debutGnomon.position.x=v1.x;debutGnomon.position.y=v1.y;debutGnomon.position.z=v1.z


					ligneSVG(v3.x, v3.y, v4.x, v4.y)
					croixSVG(v4.x, v4.y)
					//console.log(SVGtext)

				}// sinon style polaire parallele au plan  ${cs.egnomon.toFixed(2)}
			}

			if (cs.typeCadran == BF) {
				calculg1g2k1k2()
				if (cs.anglefilVertical == 90) {
					v10 = new THREE.Vector3(cs.xgnomon, -cs.hauteur / 2, (cs.epaisseur / 2 + cs.hfilVertical));
					v20 = new THREE.Vector3(cs.xgnomon, cs.hauteur / 2, (cs.epaisseur / 2 + cs.hfilVertical))
				}
				else TracerFil(cs.anglefilVertical, cs.hfilVertical, cs.hfilVertical);
				cs.xB1 = v10.x; cs.yB1 = v10.y; cs.xB2 = v20.x; cs.yB2 = v20.y;
				const tubeGeometryFV = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 16);
				filVertical = new THREE.Mesh(tubeGeometryFV, materialGnomon);
				filVertical.castShadow = true;
				cadranSolaireGroup.add(filVertical);

				if (cs.anglefilHorizontal == 0) {
					v10 = new THREE.Vector3(-cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hfilHorizontal));
					v20 = new THREE.Vector3(cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hfilHorizontal))
				}
				else TracerFil(cs.anglefilHorizontal, cs.hfilHorizontal, cs.hfilHorizontal);
				cs.xA1 = v10.x; cs.yA1 = v10.y; cs.xA2 = v20.x; cs.yA2 = v20.y;
				const tubeGeometryFH = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 16);
				filHorizontal = new THREE.Mesh(tubeGeometryFH, materialGnomon);
				filHorizontal.castShadow = true;
				cadranSolaireGroup.add(filHorizontal)

				gnomon.visible = false;
				cadranSolaireGroup.remove(gnomon)
				croixSVG(cs.xA1, cs.yA1); croixSVG(cs.xA2, cs.yA2); croixSVG(cs.xB1, cs.yB1); croixSVG(cs.xB2, cs.yB2)
				croixSVG(cs.xgnomon, cs.ygnomon)
				//console.log(g1,g2,k1,k2)

			}

			if (cs.typeCadran == BFG) {

				if (cs.anglefilVertical == 90) {
					v10 = new THREE.Vector3(cs.xgnomon, -cs.hauteur / 2, (cs.epaisseur / 2 + cs.hB1));
					v20 = new THREE.Vector3(cs.xgnomon, cs.hauteur / 2, (cs.epaisseur / 2 + cs.hB2))
				}
				else TracerFil(cs.anglefilVertical, cs.hB1, cs.hB2);
				cs.xB1 = v10.x; cs.yB1 = v10.y; cs.xB2 = v20.x; cs.yB2 = v20.y;
				const tubeGeometryFV = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 8);
				filVertical = new THREE.Mesh(tubeGeometryFV, materialGnomon);
				filVertical.castShadow = true;
				cadranSolaireGroup.add(filVertical);
				v30 = new THREE.Vector3(v10.x, v10.y, -cs.epaisseur / 2)
				const tubeGeometryH1 = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v30), 16, cs.egnomon, 8);
				pilierH1 = new THREE.Mesh(tubeGeometryH1, materialGnomon);
				v40 = new THREE.Vector3(v20.x, v20.y, -cs.epaisseur / 2)
				const tubeGeometryH2 = new THREE.TubeGeometry(new THREE.LineCurve3(v20, v40), 16, cs.egnomon, 8);
				pilierH2 = new THREE.Mesh(tubeGeometryH2, materialGnomon);
				cadranSolaireGroup.add(pilierH1); cadranSolaireGroup.add(pilierH2);

				if (cs.anglefilHorizontal == 0) {
					v10 = new THREE.Vector3(-cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hA1));
					v20 = new THREE.Vector3(cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hA2))
				}
				else TracerFil(cs.anglefilHorizontal, cs.hA1, cs.hA2);
				cs.xA1 = v10.x; cs.yA1 = v10.y; cs.xA2 = v20.x; cs.yA2 = v20.y;
				const tubeGeometryFH = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 8);
				filHorizontal = new THREE.Mesh(tubeGeometryFH, materialGnomon);
				filHorizontal.castShadow = true;
				cadranSolaireGroup.add(filHorizontal)
				v30 = new THREE.Vector3(v10.x, v10.y, -cs.epaisseur / 2)
				const tubeGeometryH3 = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v30), 16, cs.egnomon, 8);
				pilierH3 = new THREE.Mesh(tubeGeometryH3, materialGnomon);
				v40 = new THREE.Vector3(v20.x, v20.y, -cs.epaisseur / 2)
				const tubeGeometryH4 = new THREE.TubeGeometry(new THREE.LineCurve3(v20, v40), 16, cs.egnomon, 8);
				pilierH4 = new THREE.Mesh(tubeGeometryH4, materialGnomon);
				cadranSolaireGroup.add(pilierH3); cadranSolaireGroup.add(pilierH4);

				croixSVG(cs.xA1, cs.yA1); croixSVG(cs.xA2, cs.yA2); croixSVG(cs.xB1, cs.yB1); croixSVG(cs.xB2, cs.yB2)
				croixSVG(cs.xgnomon, cs.ygnomon)
				gnomon.visible = false;
				//cadranSolaireGroup.remove(gnomon)

				//console.log(g1,g2,k1,k2)

			}

			if (cs.typeCadran == ANL) {
				xd = zd * Math.tan(base.toRad(cs.xdirect))
				yd = zd * Math.tan(base.toRad(cs.ydirect))
				const pg = Proj(EtoC(0, 0, Math.tan(TS.decSuns[cs.dayofYear - 1])));
				const xp = pg.x + cs.xgnomon, yp = pg.y + cs.ygnomon, zp = cs.epaisseur / 2;
				// const v1 = new THREE.Vector3(xp, yp, zp);
				// const k = cs.Hanalem/Math.sqrt(cs.xdirect*cs.xdirect + cs.ydirect*cs.ydirect + cs.zdirect*cs.zdirect);
				// const v2 = new THREE.Vector3(xp + k*cs.xdirect, yp + k*cs.ydirect, zp + k*cs.zdirect);
				const v1 = new THREE.Vector3(xp, yp, zp);
				const k = cs.Hanalem / Math.sqrt(xd * xd + yd * yd + zd * zd);
				const v2 = new THREE.Vector3(xp + k * xd, yp + k * yd, zp + k * zd);
				const tubeGeometrySP = new THREE.TubeGeometry(new THREE.LineCurve3(v1, v2), 16, cs.egnomon, 32);
				styleAnalem = new THREE.Mesh(tubeGeometrySP, materialGnomon);
				styleAnalem.castShadow = true;
				cadranSolaireGroup.add(styleAnalem);
				//EcrirelesDates()
				//if (ligneDate.length>0) {EcrireTexte(ligneDate,xp,yp,materialAnalem,analemGroup,analemListeMesh)}
			}
		}  //Tracer Style

		//------------------------------------------------------------------------------------------------------
		function ExtrudeSetting(c, spline, nsteps) {
			const squareShape = new THREE.Shape()
				.moveTo(0, c)
				//	.lineTo(  -c,c )
				.lineTo(-2 * c, 0)
				//	.lineTo(  -c, -c)
				.lineTo(0, -c)
				.lineTo(0, c);
			const Settings = {
				steps: nsteps,
				bevelEnabled: false,
				extrudePath: spline
			};
			return { forme: squareShape, setting: Settings }
		}
		//---------------------------------------------------------------------------------------------------------
		function effacelisteMesh(listeMesh, group) {
			//Effacement des lignes existantes
			const lm = listeMesh.length;
			let mesh;
			for (let i = 0; i < lm; i++) {
				mesh = listeMesh[i];
				mesh.geometry.dispose();
				group.remove(mesh);
				mesh.dispose
			}
			listeMesh = [];
			group.clear
			cadranSolaireGroup.remove(group);
		}
		//-----------------------------------------------------------------------------------------------------------------------
		function traceLignes(sunDial, listeMesh, group, material) {
			let tubeGeometry, mesh, xp, yp, zp, pipeSpline, pipeSplineCRC, longLigne, xs, ys, eptrait,hd,h,min;
			// trac√© des nouvelles lignes
			for (let i = 0; i < sunDial.lines.length; i++) {
				longLigne = sunDial.lines[i].points.length
				if (longLigne > 1) {
					hd=sunDial.lines[i].hour;
					h = Math.floor(hd);
					min = Math.round((hd - h) * 60);
					CSVtext += "Heure: " + h.toString()+":"+min.toString() + "\n";
					pipeSpline = [];
					if (presqueEntier(sunDial.lines[i].hour)) { eptrait = cs.egnomon } else { eptrait = cs.egnomon / 2 }
					if (SVGtext.length > 0) {
						SVGtext += ` 
				          <polyline fill="none" stroke="${material.color.getStyle()}" stroke-width="${eptrait}"
				           points= " ` }

					for (let p = 0; p < sunDial.lines[i].points.length; p++) {
						xp = sunDial.lines[i].points[p].x + cs.xgnomon;
						yp = sunDial.lines[i].points[p].y + cs.ygnomon;
						zp = cs.epaisseur / 2 + cs.egnomon / 2;

						pipeSpline.push(new THREE.Vector3(xp, yp, zp));
						ligneCSV("point:",xp,yp)
						//CSVtext += "point: " + cs.separateurCSV + xp.toFixed(2) + cs.separateurCSV + yp.toFixed(2) + "\n";
						if (SVGtext.length > 0) {
							xs = xp + cs.largeur / 2; ys = -yp + cs.hauteur / 2
							SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
						}
					};
					if (SVGtext.length > 0) { SVGtext += `" />` }
					if (pipeSpline.length > 1) {
						pipeSplineCRC = [];
						pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline, false, 'chordal', 1);


						tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, 180, eptrait, 8, false);

						//const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,180)
						//tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 

						mesh = new THREE.Mesh(tubeGeometry, material);
						mesh.receiveShadow = true;
						listeMesh.push(mesh);
						group.add(mesh);						
					}
					cadranSolaireGroup.add(group)
				}
			}
			//   TracerStyle()
		}
		// const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,200)
		// tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 
		// mesh = new THREE.Mesh( tubeGeometry, material);

		// const lineGeometry = new THREE.BufferGeometry().setFromPoints( pipeSplineCRC );				   
		// const lineMaterial = new THREE.LineBasicMaterial( {color:0x0000FF});
		// mesh = new THREE.Mesh( lineGeometry, lineMaterial);		 

		//---------------------------------------------------------------------------------------------------------
		function TracerHeuresSolaires() {
			cs.hoursTextSize = cs.textSizeHS
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HS, heuresSolairesGroup, materialHeuresSolaires, heuresSolairesListeMesh);
			//console.log(CSVtext)
			CSVtext += "\n\n"
			CSVtext += 'Solar hours' + "\n\n"
			
			traceLignes(sunDial, heuresSolairesListeMesh, heuresSolairesGroup, materialHeuresSolaires)

		}

		//-------------------------------------------------------------------------------------------------------
		function TracerHeuresLegalesSA() {
			cs.hoursTextSize = cs.textSizeSA
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HLSA, heuresLegalesGroupSA, materialHeuresLegalesSA, heuresLegalesListeMeshSA);
			CSVtext += "\n\n"
			CSVtext += 'Legal hours (Summer and Autumn)' + "\n\n"
			
			traceLignes(sunDial, heuresLegalesListeMeshSA, heuresLegalesGroupSA, materialHeuresLegalesSA)

		}

		function TracerHeuresLegalesWS() {

			cs.hoursTextSize = cs.textSizeWS
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax + 1, HLWS, heuresLegalesGroupWS, materialHeuresLegalesWS, heuresLegalesListeMeshWS);
			CSVtext += "\n\n"
			CSVtext += 'Legal hours (Winter and Spring)' + "\n\n"

			traceLignes(sunDial, heuresLegalesListeMeshWS, heuresLegalesGroupWS, materialHeuresLegalesWS)

		}

		//------------------------------------------------------------------------------------------------
		function TracerHeuresAntiques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Unequal hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresAntiquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHA
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HA, heuresAntiquesGroup, materialHeuresAntiques, heuresAntiquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Antic hours' + "\n\n"

			traceLignes(sunDial, heuresAntiquesListeMesh, heuresAntiquesGroup, materialHeuresAntiques)
		}
		//-----------------------------------------------------------------------------------------------------
		function TracerHeuresBabyloniques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Babylonics hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresBabyloniquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHB;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HB, heuresBabyloniquesGroup, materialHeuresBabyloniques, heuresBabyloniquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Babylonics hours' + "\n\n"

			traceLignes(sunDial, heuresBabyloniquesListeMesh, heuresBabyloniquesGroup, materialHeuresBabyloniques)

		}
		//-----------------------------------------------------------------------------------------------------
		function TracerHeuresItaliques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Italic hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresItaliquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHI;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HI, heuresItaliquesGroup, materialHeuresItaliques, heuresItaliquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Italic hours' + "\n\n"

			traceLignes(sunDial, heuresItaliquesListeMesh, heuresItaliquesGroup, materialHeuresItaliques)

		}

		//------------------------------------------------------------------------------------------------------
		function TracerHeuresSDSA() {
			cs.hoursTextSize = cs.textSizeSDSA;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HSDSA, heuresSDSAgroup, materialHeuresSDSA, heuresSDSAListeMesh);
			CSVtext += "\n\n"
			CSVtext += HSDSA + "\n\n"

			traceLignes(sunDial, heuresSDSAListeMesh, heuresSDSAgroup, materialHeuresSDSA)
		}

		function TracerHeuresSDWS() {
			cs.hoursTextSize = cs.textSizeSDWS;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HSDWS, heuresSDWSgroup, materialHeuresSDWS, heuresSDWSListeMesh);
			CSVtext += "\n\n"
			CSVtext += HSDWS + "\n\n"
			
			traceLignes(sunDial, heuresSDWSListeMesh, heuresSDWSgroup, materialHeuresSDWS)

		}
	
		//---------------------------------------------------------------------------------------------------------
		function TracerArcsDiurnes() {
			let tubeGeometry, mesh, xp, yp, zp, lm, pipeSpline, pipeSplineCRC, xs, ys;

			effacelisteMesh(arcsDiurnesListeMesh, arcsDiurnesGroup)

			const sunDial = arcsDiurnes
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, arcsDiurnesGroup, materialArcsDiurnes, arcsDiurnesListeMesh);


			CSVtext += "\n\n";
			CSVtext += "Diurnial arcs" + "\n\n";

			//traceLignes(sunDial,arcsDiurnesListeMesh,arcsDiurnesGroup,materialArcsDiurnes)
			// trac√© des nouvelles lignes
			for (let i = 0; i < sunDial.lines.length; i++) {
				if (sunDial.lines[i].points.length > 1) {
					CSVtext += "Date: " + sunDial.lines[i].date[0].toString() + "\n";
					pipeSpline = [];
					if (SVGtext.length > 0) {
						SVGtext += ` 
				          <polyline fill="none" stroke="${materialArcsDiurnes.color.getStyle()}" stroke-width="${cs.egnomon}"
				           points= " ` }

					for (let p = 0; p < sunDial.lines[i].points.length; p++) {
						xp = sunDial.lines[i].points[p].x + cs.xgnomon;
						yp = sunDial.lines[i].points[p].y + cs.ygnomon;
						zp = (cs.epaisseur + cs.egnomon) / 2;
						pipeSpline.push(new THREE.Vector3(xp, yp, zp));
						ligneCSV( "point: ",xp,yp)
						//CSVtext += "point: " + cs.separateurCSV + xp.toFixed(2) + cs.separateurCSV + yp.toFixed(2) + "\n"
						if (SVGtext.length > 0) {
							xs = xp + cs.largeur / 2; ys = -yp + cs.hauteur / 2
							SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
						}
					};
					if (SVGtext.length > 0) { SVGtext += `" />` }
					if (pipeSpline.length > 1) {
						pipeSplineCRC = [];
						pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline);
						tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, 200, cs.egnomon, 8, false);
						mesh = new THREE.Mesh(tubeGeometry, materialArcsDiurnes);
						mesh.receiveShadow = true;
						arcsDiurnesListeMesh.push(mesh);
						arcsDiurnesGroup.add(mesh);
					}
				}
			}
			//TracerStyle(sunDial)
			cadranSolaireGroup.add(arcsDiurnesGroup);

		}

		/**
		 * Point return type represents a point to be used in constructing the sundial.
		 */
		function Point(x, y) {
			this.x = x || 0
			this.y = y || 0
		}

		/**
		 * Line holds data to draw an hour line on the sundial.
		 */
		function LigneHoraire(hour, points) {
			this.hour = hour // 0 to 24
			this.points = points || [] // One or more points corresponding to the hour.
		}

		function LigneArc(date, points) {
			this.date = date
			this.points = points || [] // One or more points corresponding to the date.
		}

		/**
		 * General computes data for the general case of a planar sundial.
		 *
		 * Argument œÜ is geographic latitude at which the sundial will be located.
		 * D is gnomonic declination, the azimuth of the perpendicular to the plane
		 * of the sundial, measured from the southern meridian towards the west.
		 * Argument a is the length of a straight stylus perpendicular to the plane
		 * of the sundial, z is zenithal distance of the direction defined by the
		 * stylus.  Angles œÜ, D, and z are in radians.  Units of stylus length a
		 * are arbitrary.
		 *
		 * Results consist of a set of lines, a center point, u, the length of a
		 * polar stylus, and œà, the angle which the polar stylus makes with the plane
		 * of the sundial.  The center point, the points defining the hour lines, and
		 * u are in units of a, the stylus length.  œà is in radians.
		 */

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////
		function Correction(H0, j) {
			let c = 0
			c = TS.eqtimes[j] + (cs.longi / 15 - cs.offset_sec / 3600) * Math.PI / 12;
			return (H0 + c);  //angle horaire en radians, de -pi √† +pi
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////
		function coordOmbre(sH, cH, sD, cD, sz, cz, sœÜ, cœÜ, tŒ¥, Q,H,dec) {

			if (cs.typeCadran == SP) {
				const Nx = cD * sH - sD * (sœÜ * cH - cœÜ * tŒ¥)
				const Ny = cz * sD * sH - (cœÜ * sz - sœÜ * cz * cD) * cH - (sœÜ * sz + cœÜ * cz * cD) * tŒ¥
				return {
					xo: cs.hgnomon * Nx / Q,
					yo: cs.hgnomon * Ny / Q,
					ok: true
				}
			}
			if (cs.typeCadran == BF) {
				const Dn = sD * sH + cD * (sœÜ * cH - cœÜ * tŒ¥)
				const Nx = (g1 * (cD * sH - sD * (sœÜ * cH - cœÜ * tŒ¥)) + k1 * (sœÜ * tŒ¥ + cœÜ * cH)) / Dn
				const Ny = (g2 * (sœÜ * tŒ¥ + cœÜ * cH) + k2 * (cD * sH - sD * (sœÜ * cH - cœÜ * tŒ¥))) / Dn
				return {
					xo: -Nx,
					yo: -Ny,
					ok: true
				}
			}
			if (cs.typeCadran == BFG) {
				const Nx = cD * sH - sD * (sœÜ * cH - cœÜ * tŒ¥)
				const Ny = cz * sD * sH - (cœÜ * sz - sœÜ * cz * cD) * cH - (sœÜ * sz + cœÜ * cz * cD) * tŒ¥
				const xA1 = cs.hA1 * Nx / Q + cs.xA1  //algorythme Hugo: coord des points d'ombre des supports
				const yA1 = cs.hA1 * Ny / Q + cs.yA1
				const xA2 = cs.hA2 * Nx / Q + cs.xA2
				const yA2 = cs.hA2 * Ny / Q + cs.yA2
				const xB1 = cs.hB1 * Nx / Q + cs.xB1
				const yB1 = cs.hB1 * Ny / Q + cs.yB1
				const xB2 = cs.hB2 * Nx / Q + cs.xB2
				const yB2 = cs.hB2 * Ny / Q + cs.yB2
				const a = yA2 - yA1; const b = -xA2 + xA1;    //coefs droite A1A2: a x + b y =c
				const c = xA1 * (yA2 - yA1) - yA1 * (xA2 - xA1)
				const ap = yB2 - yB1; const bp = -xB2 + xB1;  //coefs droite B1B2: ap x + bp y = cp
				const cp = xB1 * (yB2 - yB1) - yB1 * (xB2 - xB1)
				let det = a * bp - ap * b
				const xombre = (bp * c - b * cp) / det
				const yombre = (a * cp - ap * c) / det
				const kxA = (xombre - xA1) / (xA2 - xA1)
				const kxB = (xombre - xB1) / (xB2 - xB1)
				// const kyA=(yombre+cs.ygnomon-yA1)/(yA2-yA1)
				// const kyB=(yombre+cs.ygnomon-yB1)/(yB2-yB1)
				//if ((kxA<0)||(kxA>1)||(kxB<0)||(kxB>1)||(kyA<0)||(kyA>1)||(kyB<0)||(kyB>1)){det=0}
				if ((kxA < 0) || (kxA > 1) || (kxB < 0) || (kxB > 1)) { det = 0 }
				if (!(pointDansCadran(xombre, yombre))) { det = 0 }
				if (Math.abs(det) > 1) {
					return {
						xo: xombre - cs.xgnomon,
						yo: yombre - cs.ygnomon,
						ok: true
					}
				} else {
					return {						
						xo: 0,
						yo: 0,
						ok: false
					}
				}
			}
			if (cs.typeCadran == RTS) {
				const Coord = CoordRayTracing(cadran, H, dec)
				//console.log(Coord)
				if (Coord.ok) {
					return {
						xo: Coord.x,
						yo: Coord.y,
						ok: Coord.ok
					}
				} else {
					return {
						xo: 0,
						yo: 0,
						ok: false
					}
				}
			}
		}


		function presqueEntier(x) {
			return (Math.abs(Math.round(x) - x) < 0.001)
		}

		function generalAJL(œÜ, D, a, z, debut, fin, TypeHeure, group, material, listeMesh) {
			// (œÜ, D, a, z float64)  (lines []LigneHoraire, center Point, u, œà float64)
			let l
			let coupe = false
			effacelisteMesh(listeMesh, group)
			let H, xp, yp, xm, ym, chiffreH = 0, sHeure = "";
			if (œÜ * 180 / Math.PI > 89.999999) { œÜ = 89.999999 * Math.PI / 180 }
			const [sœÜ, cœÜ] = base.sincos(œÜ)
			const tœÜ = sœÜ / cœÜ
			const [sD, cD] = base.sincos(D)
			const [sz, cz] = base.sincos(z)
			const P = sœÜ * cz - cœÜ * sz * cD
			const tan23p44 = Math.tan(23.44 / 180 * Math.PI)
			const lines = []
			for (let i = 0; i <= 24; i += cs.subDivisions) {
				l = new LigneHoraire(i)
				const Hi = (i - 12) * 15 * Math.PI / 180

				let j = debut;
				while (j !== fin + 1) {
					//if((Math.abs(j-TS.jdecSunMin)<5)||(Math.abs(j-TS.jdecSunMax)<5)){j++}else{j+=cs.precisionHours}
					j++
					if (j >= TS.decSuns.length) { j = 0 }
					if ((j % cs.precisionHours == 0) || (Math.abs(j - TS.jdecSunMin) <= 7) || (Math.abs(j - TS.jdecSunMax) <= 7)) {
						coupe = false
						const tŒ¥ = Math.tan(TS.decSuns[j])
						const cosH0 = -tœÜ * tŒ¥
						let H0 = Math.acos(cosH0)    //half day length 
						if (cosH0 > 1) { H0 = -Math.PI }   //nuit polaire
						if (cosH0 <= -1) { H0 = Math.PI }  //j0ur polaire

						if (TypeHeure == HS) { H = Hi; chiffreH = i }     // Heures solaires
						if ((TypeHeure == HLSA) || (TypeHeure == HLWS)) { H = Correction(Hi, j); chiffreH = i }   //l√©gales
						if (TypeHeure == HA) { H = H0 / 6 * (i - 12); chiffreH = i - 6 }  // heures antiques
						if (TypeHeure == HB) { H = i * 15 / 180 * Math.PI - H0; chiffreH = i }  //heures babyloniques
						if (TypeHeure == HI) { H = (i - 24) * 15 / 180 * Math.PI + H0; chiffreH = i }  //heures italiquesiques
						if (TypeHeure == HSDSA) {
							const RA = Math.PI - Math.asin(tŒ¥ / tan23p44) //heures sid√©rales
							H = i * 15 / 180 * Math.PI - RA
							chiffreH = i
						}
						if (TypeHeure == HSDWS) {
							const RA = Math.asin(tŒ¥ / tan23p44) //heures sid√©rales
							H = (i - 12) * 15 / 180 * Math.PI - RA
							if ((i - 12) < 0) { chiffreH = i + 12 } else { chiffreH = i - 12 }
						}
						const aH = Math.abs(H)
						const [sH, cH] = base.sincos(H)
						if (aH < H0) { // sun above horizon
							const Q = sD * sz * sH + (cœÜ * cz + sœÜ * sz * cD) * cH + P * tŒ¥
							if (Q > 0) { // sun above plane of sundial         
								const coor = coordOmbre(sH, cH, sD, cD, sz, cz, sœÜ, cœÜ, tŒ¥, Q, H,TS.decSuns[j])       // Calcul des coordonn√©es de l'ombre
								if (coor.ok == true) {
									xp = coor.xo; yp = coor.yo;
									if (pointDansCadran(xp + cs.xgnomon, yp + cs.ygnomon)) {
										if (coupe) {
											if (l.points.length > 0) { lines.push(l) }
											l = new LigneHoraire(i); coupe = false
										}
										l.points.push(new Point(xp, yp)); xm = xp + cs.xgnomon; ym = yp + cs.ygnomon
									} else { coupe = true }
								}
							}
						}

					}
				}
				if (presqueEntier(chiffreH)) { sHeure = Math.round(chiffreH).toString() } else { sHeure = "" };
				if (l.points.length > 0) {
					lines.push(l);
					EcrireTexte(sHeure, xm, ym, material, group, listeMesh)
				}
			}
			const center = new Point()
			center.x = a / P * cœÜ * sD
			center.y = -a / P * (sœÜ * sz + cœÜ * cz * cD)
			const aP = Math.abs(P)
			const u = a / aP
			const œà = Math.asin(aP)
			cs.xPole = center.x; cs.yPole = center.y; cs.angleStyleSousstylaire = œà * 180 / Math.PI;
			//console.log (lines)
			return {
				lines: lines,
				center: center,
				length: u,
				angle: œà
			}
		}


		function arcsDiurnes(œÜ, D, a, z, debut, fin, group, material, listeMesh) {
			// (œÜ, D, a, z float64)  (lines []LigneHoraire, center Point, u, œà float64)
			let H, xp, yp, xm, ym, s, coupe, l;

			if (œÜ * 180 / Math.PI > 89.999999) { œÜ = 89.999999 * Math.PI / 180 }
			const [sœÜ, cœÜ] = base.sincos(œÜ)
			const tœÜ = sœÜ / cœÜ
			const [sD, cD] = base.sincos(D)
			const [sz, cz] = base.sincos(z)
			const P = sœÜ * cz - cœÜ * sz * cD

			const lines = []

			for (const d of cs.datesArcsDiurnes) {
				l = new LigneArc(d)
				coupe = false
				for (let i = 0; i < 24 * 60; i += cs.precisionArcs) {
					const H = (i - 12 * 60) / 60 * 15 * Math.PI / 180
					const aH = Math.abs(H)
					const [sH, cH] = base.sincos(H)
					const tŒ¥ = Math.tan(d[1])
					const cosH0 = -tœÜ * tŒ¥
					let H0 = Math.acos(cosH0)
					if (cosH0 > 1) { H0 = -Math.PI }  //nuit polaire
					if (cosH0 <= -1) { H0 = Math.PI }  //jour polaire
					if (aH < H0) { // sun above horizon
						const Q = sD * sz * sH + (cœÜ * cz + sœÜ * sz * cD) * cH + P * tŒ¥
						if (Q > 0) { // sun above plane of sundial         
							const coord = coordOmbre(sH, cH, sD, cD, sz, cz, sœÜ, cœÜ, tŒ¥, Q, H,d[1])
							if (coord.ok == true) {
								xp = coord.xo; yp = coord.yo;
								if (pointDansCadran(xp + cs.xgnomon, yp + cs.ygnomon)) {
									if (coupe) {
										if (l.points.length > 0) { lines.push(l) }
										l = new LigneArc(d); coupe = false
									}
									l.points.push(new Point(xp, yp));
									xm = xp + cs.xgnomon; ym = yp + cs.ygnomon; coupe = false
								} else { coupe = true }
							}
						}
					}
				}
				if (l.points.length > 0) { lines.push(l) }
			}
			const center = new Point()
			center.x = a / P * cœÜ * sD
			center.y = -a / P * (sœÜ * sz + cœÜ * cz * cD)
			const aP = Math.abs(P)
			const u = a / aP
			const œà = Math.asin(aP)
			cs.xPole = center.x; cs.yPole = center.y; cs.angleStyleSousstylaire = œà * 180 / Math.PI;
			return {
				lines: lines,
				center: center,
				length: u,
				angle: œà
			}
		}

		//-----------------------------------------------------------------------------------------------------
		function loadJsonFile() {
			let csl;
			const [file] = document.querySelector('input[type=file]').files;

			const reader = new FileReader();
			reader.addEventListener("load", () => {
				try { csl = JSON.parse(reader.result) }
				catch (e) { console.error("Parsing error:", e) }
				//console.log(JSON.stringify(csl,null,2));
				for (var k in csl) { cs[k] = csl[k] }
				console.log(JSON.stringify(cs, null, 2));
				TS = TableSol(cs.year);
				run();
			}, false);
			if (file) {
				reader.readAsText(file);
			}

			return reader.result;
		}



		//--------------------------------------------------------------------------------------------------------
		//function saveString    Ecrit la chaine de caracteres text dans le fichier texte de nom filename 
		//saveString('mon texte','Bidon.txt');
		const link = document.createElement('a');
		link.style.display = 'none';
		document.body.appendChild(link); // Firefox workaround, see #6594
		function save(blob, filename) {
			link.href = URL.createObjectURL(blob);
			link.download = filename;
			link.click();
		}
		function saveString(text, filename) {
			save(new Blob([text], { type: 'text/plain' }), filename);
			// console.log(text)
		}

		// ---------------------------------------------------------------------------------------------------
		function eulerCsGroup() {
			const a = new THREE.Euler((cs.incli - 90) / 180 * Math.PI, cs.decli / 180 * Math.PI, cs.rot / 180 * Math.PI, 'YXZ');
			cadranSolaireGroup.setRotationFromEuler(a);
		}

		// ---------------------------------------------------------------------------------------------------
		//   function 	eulerEarthGroup() 
		//   {
		//   	const a = new THREE.Euler( (cs.lati-90)/180*Math.PI, 0*Math.PI,-cs.longi/180*Math.PI, 'YZX' );
		// 	earthGroup.setRotationFromEuler(a); 	
		//   }


		//---------------------------------------------------------------------------------------------------------
		function init() {


			//Effacement de toute la page d'introduction  

			document.getElementById("info").style.display = "none";

			// dat.GUI ///////////////////////////////////////////////////////////////////////////////////////


			function initMenu(e) {
				if (e == SP) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					folderGnomonClassic.show();
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = SP;
					cs.vgnomon = true;
					gnomon.visible = true
					TracerHeuresEtArcs();
				};
				if (e == BF) {
					folderGnomonClassic.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.setValue(90);
					cs.incli = 90;
					ctlIncli.disable();
					folderGnomonBifilaireVertical.show()
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = BF;
					calculg1g2k1k2()
					TracerHeuresEtArcs();
				};
				if (e == BFG) {
					folderGnomonClassic.hide();
					folderGnomonBifilaireVertical.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					cs.typeCadran = BFG;
					folderGnomonBifilaireGen.show();
					folderHours.show();
					folderArcs.show();
					TracerHeuresEtArcs()
				}

				if (e == ANL) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderGnomonClassic.hide();
					folderHours.hide();
					folderArcs.hide();
					cadranSolaireGroup.remove(heuresSolairesGroup);
					cadranSolaireGroup.remove(heuresLegalesGroupSA);
					cadranSolaireGroup.remove(heuresLegalesGroupWS);
					cadranSolaireGroup.remove(heuresAntiquesGroup);
					cadranSolaireGroup.remove(heuresBabyloniquesGroup);
					cadranSolaireGroup.remove(heuresItaliquesGroup);
					cadranSolaireGroup.remove(heuresSDSAgroup);
					cadranSolaireGroup.remove(heuresSDWSgroup);
					cadranSolaireGroup.remove(arcsDiurnesGroup);
					gnomon.visible = false;
					ctlIncli.enable();
					//cs.incli=0;eulerCsGroup();
					folderAnalem.show();
					TracerHeuresEtArcs();
				}
				if (e == RTS) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					folderGnomonClassic.show();
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = RTS;
					cs.vgnomon = true;
					gnomon.visible = true
					TracerHeuresEtArcs();
				}
			}




			const gui = new GUI(
				{ width: Math.min(Math.round(window.innerWidth / 2), 280), title: "Edit sundial..." }
			);
			const sp = "‚òº "
			gui.$title.style.color = 'yellow'

			function helpGui(g, textHelp) {
				g.domElement.addEventListener("mouseover", function () {
					gui.title(textHelp)
				})
				g.domElement.addEventListener("mouseout", function () {
					gui.title("Edit sundial...")
				})
			}


			const guihsol = gui.add(cs, "hsol", 0, 24, 0.01)
				.name("Hour  (0-24)")
				.onChange(function (e) { PlacerLeSoleil() });
			helpGui(guihsol, 'decimal hour')
			// hsol.domElement.addEventListener("mouseover", function(){
			// 	gui.title('decimal hour')
			// })
			// hsol.domElement.addEventListener("mouseout", function(){
			// 	gui.title("Edit sundial...")
			// })
			const guiday = gui.add(cs, "dayofYear", 1, 365, 1)
				.name("Day (1-365))")
				.onChange(function () {
					PlacerLeSoleil();
					if (cs.typeCadran == ANL) TracerStyle();
				});
			helpGui(guiday, 'day of the year')

			const guiyear = gui.add(cs, "year")
				.name("Year")
				.onFinishChange(function () {
					TS = TableSol(cs.year)
					TracerHeuresEtArcs();
				});

			gui.add(cs, "typeCadran", [SP, BF, BFG, ANL,RTS]).name("type of sundial") ///+++
				.onChange(function (e) {
					initMenu(e)


				});

			const Button2D = {
				function2D() {
					let w; // window
					initSVGtext("auto");
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
					TracerHeuresEtArcs()
					closeSVGtext();
					w = window.open()
					w.name = cs.nameFile
					w.document.write(`					
					<!DOCTYPE html>
					<html lang="en">
  			    	<head>					
					<meta charset="utf-8" />
	                <title>CadsolOnLine 2D ${cs.nameFile}</title>
					</head>
					<body>
					`)
					w.document.write(SVGtext)
					w.document.write(`
					</body>
					</html>
	                `)
					w.document.close()
				}
			}
			gui.add(Button2D, 'function2D').name('2D View');

			const nameW="List params"
			const ButtonFiche = {
				functionFiche() {
					let w; // window
					//w = window.open("",nameW, "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
					w = window.open()
					w.name = nameW+":"+cs.nameFiles
					w.document.write(HTLM(cs))
					w.document.close()
				}
			}
			gui.add(ButtonFiche, 'functionFiche').name(nameW);

			//// GEOLOCALISATION
			const folderGeoSundial = gui.addFolder(sp+"Geolocation")
			//folderGeoSundial.domElement.addEventListener
			folderGeoSundial.add(cs, "lati", -90, 90, 0.001)
				.name("Latitude")
				.onChange(() => { orienterAxedumonde(); PlacerLaTerre() })
				.onFinishChange(() => {
					orienterAxedumonde();
					PlacerLaTerre();//eulerEarthGroup()
					PlacerLeSoleil(); TracerHeuresEtArcs()
				})
				.listen();
			folderGeoSundial.add(cs, "longi", -180, 180, 0.001)
				.name("Longitude")
				.onChange(() => {
					PlacerLaTerre()
					cs.offset_sec = Math.trunc(cs.longi / 15) * 3600
				})
				.onFinishChange(() => {
					PlacerLaTerre();//eulerEarthGroup():
					TracerHeuresEtArcs()
				})
				.listen();
			folderGeoSundial.add(cs, "adresse")
				.name("postal adress")
			// folderGeoSundial.domElement.addEventListener("click", function () {
			// 	for (let g = 0; g < gui.folders.length; g++) {
			// 	//gui.folders[g].$title.style.color = couleurMenu
			// 	gui.folders[g].close()
			//     }	
			// 	})
			

			const folderViewParam = {
				functionViewMap() {
					if (cs.adresse.length > 0) {
						RechercheParAdresse(cs.adresse);
						TracerHeuresEtArcs();
						orienterAxedumonde();
						PlacerLaTerre();
						window.open(cs.urlOpenStreet, "OSM", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
					}
				}
			}
			folderGeoSundial.add(folderViewParam, "functionViewMap")
				.name('Seek by adress')


			folderGeoSundial.add(cs, "timezone")
				.name("Time zone")
				.listen();
			
			folderGeoSundial.add(cs, "offset_sec", -43200, 43200, 3600)
				.name("offset from UTC (sec)")
				.onFinishChange(function (v) {
					cs.offset_sec = v;
					TracerHeuresEtArcs()
				})
				.listen();
			const ofStr=folderGeoSundial.add(cs,"offset_string")
			    .name("+/- HHMM")
			    .listen()
			ofStr.disable()
			//console.log(cs)
			folderGeoSundial.add(cs, "autoLocation")
				.name("auto")
				.onFinishChange(function (v) {
					if (v) {
						getLocation()
						TracerHeuresEtArcs(); orienterAxedumonde();
						PlacerLaTerre()
					}
				})

			//   folderGeoSundial.add(cs,"offset_string") 
			//        .name(" offset (HHMM)");
			//   folderGeoSundial.add(cs,"now_in_dst") 
			//        .name("summer time (H)");

			const folderSundial = gui.addFolder(sp + 'Geometry ');

			//// ORIENTATION				
			const folderOrientationSundial = folderSundial.addFolder("Orientation...");
			folderOrientationSundial.add(cs, "decli", -180, 180, 0.1)
				.name("Declinaison ¬∞")
				.onChange(() => { eulerCsGroup() })
				.onFinishChange(() => { TracerHeuresEtArcs() });
			const ctlIncli = folderOrientationSundial.add(cs, "incli", -180, 180, 0.1)
				.name("Inclinaison ¬∞")
				.onChange(() => { eulerCsGroup() })
				.onFinishChange(() => { TracerHeuresEtArcs() });
			//                 folderOrientationSundial.add( cs, "rot", -180, 180, 0.1 )
			//                    .name("Rotation")
			//                    .onChange(function(v){
			// 					cs.rot=v;
			// 					eulerCsGroup() })
			//                    .onFinishChange(function(){TracerHeuresEtArcs()});


			//// DIMENTIONS
			const folderDimensionsSundial = folderSundial.addFolder("Dimensions...");
			folderDimensionsSundial.add(cs, "largeur", 10, 1000, 0.1)
				.name("Width")
				.onChange(() => {
					cadran.scale.x = cs.largeur;
					meshDevise.position.x = -cs.largeur / 2 * 0.9
				})
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderDimensionsSundial.add(cs, "hauteur", 10, 1000, 0.1)
				.name("Height")
				.onChange(function (v) {
					cs.hauteur = v; cadran.scale.y = cs.hauteur;
					meshDevise.position.y = -cs.hauteur / 2 * 0.9;
					PlacerLaTerre()
				})
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderDimensionsSundial.add(cs, "epaisseur", 1, 1000, 0.1)
				.name("Depth")
				.onChange(function (v) {
					cs.epaisseur = v;
					cadran.scale.z = cs.epaisseur;
					meshDevise.position.z = cs.epaisseur / 2;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
				})
				.onFinishChange(function () { TracerHeuresEtArcs() });

			//// STYLE

			const folderGnomon = folderSundial.addFolder('Shadow by ...');

			//// ANALEMMATIQUE  +++

			const folderAnalem = folderGnomon.addFolder("Analematic gnomon");
			folderAnalem.add(cs, "xdirect", -89, 89, 0.1)
				.name("‚Üê ‚Üí ¬∞")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderAnalem.add(cs, "ydirect", -89, 89, 0.1)
				.name("‚Üë ‚Üì ¬∞")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			//folderAnalem.add(cs, "zdirect", -500, 500, 0.1)
			//	.name("Alt")
			//	.onChange(function () {TracerStyle()})
			//	.onFinishChange(function () {TracerHeuresEtArcs()});
			folderAnalem.add(cs, "Hanalem", 1, 500, 0.1)
				.name("Gnomon length")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderAnalem.add(cs, "Ranalem", 1, 500, 0.1)
				.name("elliptical radius")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			//folderAnalem.add(cs, "Canalem")
			//	.name("Central projection")
			folderAnalem.addColor(cs, "colorAnalem")
				.name("Color")
				.onChange(function (e) {
					materialAnalem.color = new THREE.Color(e);
					cs.colorAnalem = materialAnalem.color.getStyle();
				});
			folderAnalem.add(cs, "textSizeANL", 0, 5, 0.1)
				.name("Font size")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderAnalem.add(cs, "dateAnalem", 1, 31, 1)
				.name("date (1..31)")
				.onFinishChange(function () {
					TracerStyle()
					TracerHeuresEtArcs()
				});




			/// Style droit ou polaire
			const folderGnomonClassic = folderGnomon.addFolder('Straight or polar style...');
			folderGnomonClassic.add(cs, "hgnomon", 1, 1000, 0.1)
				.name("Length straight style")
				.onChange(function (e) {
					cs.hgnomon = e;
					gnomon.scale.y = cs.hgnomon;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
				})
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderGnomonClassic.add(cs, "vgnomon")
				.name("straight style visible")
				.onChange(function (e) {
					cs.vgnomon = e
					gnomon.visible = e
				})
			folderGnomonClassic.add(cs, "vstyle")
				.name("polar style visible")
				.onChange(function (e) {
					//TracerHeuresEtArcs()				    
					stylePolaire.visible = e
				})
			folderGnomonClassic.add(cs, "vsousstyle")
				.name("under style visible")
				.onChange(function (e) {
					//TracerHeuresEtArcs()			    
					sousStylaire.visible = e
				})


			// filaire vertical

			const folderGnomonBifilaireVertical = folderGnomon.addFolder('Wires...');
			folderGnomonBifilaireVertical.add(cs, "anglefilHorizontal", 0, 180, 0.1)
				.name("angle  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "anglefilVertical", 0, 180, 0.1)
				.name("angle  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "hfilHorizontal", 1, 500, 0.1)
				.name("height  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "hfilVertical", 1, 500, 0.1)
				.name("height  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })




			// filaire gen	        

			const folderGnomonBifilaireGen = folderGnomon.addFolder('Wires...');

			folderGnomonBifilaireGen.add(cs, "anglefilHorizontal", 0, 180, 0.1)
				.name("angle  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "anglefilVertical", 0, 180, 0.1)
				.name("angle  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hA1", 0, 1000, 0.1)
				.name("height A1")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hA2", 0, 1000, 0.1)
				.name("height A2")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hB1", 0, 1000, 0.1)
				.name("height B1")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hB2", 0, 1000, 0.1)
				.name("height B2")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })


			const folderGnomonPosition = folderGnomon.addFolder('Position ...');

			folderGnomonPosition.add(cs, "xgnomon", -1000, 1000, 0.1)
				.name("‚Üê ‚Üí")
				.onChange(function () {
					gnomon.position.x = cs.xgnomon;
					TracerStyle()
					gnomon.visible = cs.vgnomon && ((cs.typeCadran == SP)||(cs.typeCadran == RTS))
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonPosition.add(cs, "ygnomon", -1000, 1000, 0.1)
				.name("‚Üë ‚Üì")
				.onChange(function () {
					gnomon.position.y = cs.ygnomon;
					TracerStyle()
					gnomon.visible = cs.vgnomon && ((cs.typeCadran == SP)||(cs.typeCadran == RTS))
				})
				.onFinishChange(function () { TracerHeuresEtArcs() })

			folderGnomon.add(cs, "egnomon", 0.1, 5, 0.01)
				.name("Thickness")
				.onChange(function () {
					gnomon.scale.x = cs.egnomon;
					gnomon.scale.z = cs.egnomon;

					TracerHeuresEtArcs()
				});






			//// COLOR             
			const folderColorsSundial = gui.addFolder(sp+"Color and texture");
			materialCS.color.setStyle(cs.colorCS);
			materialCS.emissive.setStyle(cs.emissiveCS);
			// materialCS.specular.setStyle(cs.specularCS); 
			materialCS.metalness = cs.metalness;
			materialCS.transparent = true;
			materialCS.opacity = cs.opaciteCS;
			folderColorsSundial.addColor(cs, 'colorCS').name('reflection').onChange(function (e) {
				materialCS.color = new THREE.Color(e);
				cs.colorCS = materialCS.color.getStyle();
			});
			folderColorsSundial.addColor(cs, 'emissiveCS').name('emition').onChange(function (e) {
				materialCS.emissive = new THREE.Color(e);
				cs.emissiveCS = materialCS.emissive.getStyle();
			});
			folderColorsSundial.add(materialCS, 'metalness', 0, 1, 0.1)
			folderColorsSundial.add(materialCS, 'roughness', 0, 1, 0.1)
			//   folderColorsSundial.addColor(controlCS, 'specular').onChange(function (e) {
			//        materialCS.specular = new THREE.Color(e);
			//        cs.specularCS=materialCS.specular.getStyle();
			//        });
			//   folderColorsSundial.add(materialCS, 'shininess', 0, 100, )              
			folderColorsSundial.add(cs, 'opaciteCS', 0, 1, 0.1)
				.name('opacity').onChange(function (e) {
					materialCS.transparent = true;
					cs.opaciteCS = e;
					materialCS.opacity = e
				});
			folderColorsSundial.add(materialCS, 'wireframe')
				.onChange(function (v) {
					materialGnomon.wireframe = v;
					materialHeuresSolaires.wireframe = v;
					materialHeuresLegalesSA.wireframe = v;
					materialHeuresLegalesWS.wireframe = v;
					materialArcsDiurnes.wireframe = v
				});

			const choixTextures = { 'steel': textureAcier, 'copper': textureCuivre, 'asphalt': textureAsphalt, 'fruits': textureFruits }
			folderColorsSundial.add(choixTextures, 'steel', choixTextures).name('Texture')
				.onChange(function (t) {
					materialCS.map = t
				});

			//let  heure= {nom:"Solar (local true time)",trace:true,couleur:cs.colorHS,tailleFonte:cs.textSizeHS}     

			const folderHours = gui.addFolder(sp + 'Hours');
			materialHeuresSolaires.color.setStyle(cs.colorHS);
			materialHeuresLegalesSA.color.setStyle(cs.colorHLSummerAutums);
			materialHeuresLegalesWS.color.setStyle(cs.colorHLWinterSpring);
			materialHeuresAntiques.color.setStyle(cs.colorHeuresAntiques);
			materialHeuresBabyloniques.color.setStyle(cs.colorHeuresBabyloniques);
			materialHeuresItaliques.color.setStyle(cs.colorHeuresItaliques);
			materialHeuresSDSA.color.setStyle(cs.colorHeuresSDSA);
			materialHeuresSDWS.color.setStyle(cs.colorHeuresSDWS);
			materialAnalem.color.setStyle(cs.colorAnalem);


			folderHours.add(cs, 'heuresSolaires')
				.name(HS)
				.onChange(function (e) {
					//cs.heuresSolaires=e;
					if (e) { cs.textSizeHS = cs.hoursTextSize; TracerHeuresSolaires() } else { cadranSolaireGroup.remove(heuresSolairesGroup) }
				});
			folderHours.addColor(cs, 'colorHS')
				.name('      color-> ')
				.onChange(function (e) {
					materialHeuresSolaires.color = new THREE.Color(e);
					cs.colorHS = materialHeuresSolaires.color.getStyle()
				});
			// folderHours.add(cs,'textSizeHS',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresSolaires) {TracerHeuresSolaires()} });	

			folderHours.add(cs, 'heuresLegalesSummerAutums')
				.name(HLSA)
				.onChange(function (e) {
					if (e) { cs.textSizeSA = cs.hoursTextSize; TracerHeuresLegalesSA() } else { cadranSolaireGroup.remove(heuresLegalesGroupSA) }
				});
			folderHours.addColor(cs, 'colorHLSummerAutums')
				.name('      color-> ')
				.onChange(function (e) {
					materialHeuresLegalesSA.color = new THREE.Color(e);
					cs.colorHLSummerAutums = materialHeuresLegalesSA.color.getStyle()
				});
			// folderHours.add(cs,'textSizeSA',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresLegalesSummerAutums) {TracerHeuresLegalesSA()} });	

			folderHours.add(cs, 'heuresLegalesWinterSpring')
				.name(HLWS)
				.onChange(function (e) {
					if (e) { cs.textSizeWS = cs.hoursTextSize; TracerHeuresLegalesWS() } else { cadranSolaireGroup.remove(heuresLegalesGroupWS) }
				});
			folderHours.addColor(cs, 'colorHLWinterSpring')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresLegalesWS.color = new THREE.Color(e);
					cs.colorHLWinterSpring = materialHeuresLegalesWS.color.getStyle()
				});
			// folderHours.add(cs,'textSizeWS',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresLegalesWinterSpring) {TracerHeuresLegalesWS()} });	

			folderHours.add(cs, 'heuresAntiques')
				.name(HA)
				.onChange(function (e) {
					if (e) { cs.textSizeHA = cs.hoursTextSize; TracerHeuresAntiques() } else { cadranSolaireGroup.remove(heuresAntiquesGroup) }
				});
			folderHours.addColor(cs, 'colorHeuresAntiques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresAntiques.color = new THREE.Color(e);
					cs.colorHeuresAntiques = materialHeuresAntiques.color.getStyle()
				});
			// folderHours.add(cs,'textSizeHA',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresAntiques) {TracerHeuresAntiques()} });	

			folderHours.add(cs, 'heuresBabyloniques')
				.name(HB)

				.onChange(function (e) {
					if (e) { cs.textSizeHB = cs.hoursTextSize; TracerHeuresBabyloniques() } else { cadranSolaireGroup.remove(heuresBabyloniquesGroup) }
				});
			folderHours.addColor(cs, 'colorHeuresBabyloniques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresBabyloniques.color = new THREE.Color(e);
					cs.colorHeuresBayloniques = materialHeuresBabyloniques.color.getStyle()
				});
			// folderHours.add(cs,'textSizeHB',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresBabyloniques) {TracerHeuresBabyloniques()} });	

			folderHours.add(cs, 'heuresItaliques')
				.name(HI)
				.onChange(function (e) {
					if (e) { cs.textSizeHI = cs.hoursTextSize; TracerHeuresItaliques() } else { cadranSolaireGroup.remove(heuresItaliquesGroup) }
				});
			folderHours.addColor(cs, 'colorHeuresItaliques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresItaliques.color = new THREE.Color(e);
					cs.colorHeuresItaliques = materialHeuresItaliques.color.getStyle()
				});
			// folderHours.add(cs,'textSizeHI',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresItaliques) {TracerHeuresItaliques()} });	

			folderHours.add(cs, 'heuresSideralesSA')
				.name(HSDSA)
				.onChange(function (e) {
					if (e) { cs.textSizeSDSA = cs.hoursTextSize; TracerHeuresSDSA() } else { cadranSolaireGroup.remove(heuresSDSAgroup) }
				});
			folderHours.addColor(cs, 'colorHeuresSDSA')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresSDSA.color = new THREE.Color(e);
					cs.colorHeuresSDSA = materialHeuresSDSA.color.getStyle()
				});
			// folderHours.add(cs,'textSizeSDSA',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresSideralesSA) {TracerHeuresSDSA()} });	

			folderHours.add(cs, 'heuresSideralesWS')
				.name(HSDWS)
				.onChange(function (e) {
					if (e) { cs.textSizeSDWS = cs.hoursTextSize; TracerHeuresSDWS() } else { cadranSolaireGroup.remove(heuresSDWSgroup) }
				});
			folderHours.addColor(cs, 'colorHeuresSDWS')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresSDWS.color = new THREE.Color(e);
					cs.colorHeuresSDWS = materialHeuresSDWS.color.getStyle()
				});
			// folderHours.add(cs,'textSizeSDWS',0,5,0.1).name('   font size->')
			//   .onFinishChange(function(v){
			//     if (cs.heuresSideralesWS) {TracerHeuresSDWS()} });	

			const folderHoursOptions = folderHours.addFolder("Options (choose before tracing)")
			folderHoursOptions.add(cs, 'hoursTextSize', 0, 5, 0.1).name('Font size')
			//   .onFinishChange(function(v){TracerHeuresEtArcs()});

			const subDiv = {
				"no": 1,
				"30 min": 0.5,
				"15 min": 0.25,
				"10 min": 1 / 6,
				" 5 min": 1 / 12
			}
			folderHoursOptions.add(cs, "subDivisions", subDiv)
				.name('Subdivisions')
				.onChange(TracerHeuresEtArcs())

			const precisionH = {
				"one day": 1,
				"2 days": 2,
				"5 days": 5
			}
			folderHoursOptions.add(cs, "precisionHours", precisionH)
				.name('precision (days)')
				.onChange(TracerHeuresEtArcs())



			///// ARCS



			let dateArc = { day: 1, month: 1, function1() { tracerArc() }, function2() { effaceArcs() } };
			const folderArcs = gui.addFolder(sp+'Diurnials arcs...');
			//  const folderDate= folderArcs.addFolder('Date')
			folderArcs.add(dateArc, "day", 1, 31, 1)
				.name("Day of the month")
			//  .onChange(function(v){dateArc.trace=false});
			folderArcs.add(dateArc, "month", 1, 12, 1)
				.name("Month of the year")
			//  .onChange(function(v){dateArc.trace=false});						  
			folderArcs.add(dateArc, 'function1')
				.name("trace one arc");
			folderArcs.add(dateArc, 'function2')
				.name("delete all arcs");
			function tracerArc() {
				let j = 0, s = "";
				j = JULIAN.DayOfYearGregorian(cs.year, dateArc.month, dateArc.day)
				s = dateArc.day + '/' + dateArc.month + '/' + cs.year
				cs.datesArcsDiurnes.push([s, TS.decSuns[j]])
				TracerArcsDiurnes()
			}
			function effaceArcs() {
				// cs.datesArcsDiurnes=cs.datesArcsDiurnes.filter(
				// function(d){return((d[0]=='so.')||(d[0]=='eq.'))})	
				// TracerArcsDiurnes()	
				cs.datesArcsDiurnes = [[]]
				cs.equinoxeAndSolstices = false
				TracerArcsDiurnes()
			}

			folderArcs.add(cs, 'equinoxeAndSolstices')
				.name('Equinoxe and solstices')
				.onChange(function (v) {
					cs.equinoxeAndSolstices = v;
					if (v) {
						cs.datesArcsDiurnes.unshift(['solstice', base.toRad(-23.44)])
						cs.datesArcsDiurnes.unshift(['solstice', base.toRad(23.44)])
						cs.datesArcsDiurnes.unshift(['equinoxe', 0])
					}
					else {
						cs.datesArcsDiurnes = cs.datesArcsDiurnes.filter(function (d) {
							return ((d[0] !== 'solstice') && (d[0] !== 'equinoxe'))
						})
					}
					//cs.datesArcsDiurnes=[];
					TracerArcsDiurnes()
					//console.log(cs.datesArcsDiurnes)
				})
				.listen();

			materialArcsDiurnes.color.setStyle(cs.colorequinoxeAndSolstice);
			folderArcs.addColor(cs, 'colorequinoxeAndSolstice')
				.name("color ")
				.onChange(function (e) {
					materialArcsDiurnes.color = new THREE.Color(e);
					cs.colorequinoxeAndSolstice = materialArcsDiurnes.color.getStyle()
				});

			const precisionA = {
				"one minute": 1,
				" 5 min": 5,
				"10 min": 15,
				"30 min": 30,
				"60 min": 60
			}
			folderArcs.add(cs, "precisionArcs", precisionA)
				.name('precision (min)')
				.onChange(TracerHeuresEtArcs());





			///// Displays and animations


			const folderView = gui.addFolder(sp + 'Displays and animations');



			folderView.add(cs, "axesESZ").name("East,South,Zenith")
				.onChange(function (e) { cs.axesESZ = e; axesESZHelper.visible = e });

			folderView.add(cs, "voirTerre").name("Earth")
				.onChange(function (e) {
					cs.voirTerre = e; PlacerLaTerre()
				});


			const Vsun = {
				"0": 0,
				"1sec  /sec": 1,
				"1min  /sec": 60,
				"10min /sec": 600,
				"20min /sec": 1200,
				"30min /sec": 1800,
				"1h    /sec": 3600
			}
			folderView.add(cs, "vrotSun", Vsun)
				.name('Rotation of sun')
				.onChange(function (e) { RotationSoleil(e) });

			folderView.add(cs, "vrotscene", 0, 10, 1)
				.name('Rotation of the scene')
				.listen;


			///// DEVISE
			const folderDevise = folderView.addFolder('Motto ...');
			folderDevise.add(cs, 'devise').name('text')
				.onChange(function (v) {
					cs.devise = v;
					
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				});
			folderDevise.add(cs, 'deviseSize', 0, 5, 0.1).name('font size')
				.onChange(function (v) {
					cs.deviseSize = v;
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				});
			folderDevise.add(cs, "positionDevisex", -500, 500, 0.1)
				.name("‚Üê ‚Üí")
				.onChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.onFinishChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.listen
			folderDevise.add(cs, "positionDevisey", -500, 500, 0.1)
				.name("‚Üë ‚Üì")
				.onChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.onFinishChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})

			//// backGround
			folderView.addColor(cs, 'background')
				.name('wallpaper')
				.onChange(function () {
					scene.background = new THREE.Color(cs.background)
				});
			/// link
			folderView.add(cs, "linkMedia").name("link web")
			const btnMedia = { lireMedia() { if (cs.linkMedia.length > 0) { window.open(cs.linkMedia) } } }
			folderView.add(btnMedia, "lireMedia").name("open link")


			///// EXPORT
			const folderFiles = gui.addFolder(sp + 'Export');
			const ButtonDownload = {
				functionDownload() {
					let e = cs.export
					if (e == "Sundial(JSON)") { saveString(JSON.stringify(cs, null, 2), cs.nameFile + '.json') };
					if (e == "Spreadsheet(CSV)") {
						initCSVtext(); TracerHeuresEtArcs();
						saveString(CSVtext, cs.nameFile + '.csv')
					};
					if (e == "Ephemeris(CSV)") { Ephemerid(cs.year); saveString(CSVephemerid, 'Ephemerid' + cs.year + '.csv') };
					if (e == "3D(PLY)") { saveString(GenererPLY(), cs.nameFile + ".PLY") };
					if (e == "3D(OBJ)") { saveString(GenererOBJ(), cs.nameFile + ".OBJ") };
					if (e == "3D(STL)") { saveString(GenererSTL(), cs.nameFile + ".STL") };
					if (e == "Scal.Vect.Graph.(SVG)") {
						initSVGtext(cs.unitSVG);
						EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
						TracerHeuresEtArcs()
						closeSVGtext();
						saveString(SVGtext, cs.nameFile + '.svg')
					    };
					if (e =="Params (.HTML)"){saveString(HTLM(cs), cs.nameFile + '.html')}
				}
			}
			folderFiles.add(ButtonDownload, 'functionDownload').name('Download');

			folderFiles.add(cs, "nameFile").name("File name")

			folderFiles.add(cs, "export",
				["Sundial(JSON)", "Spreadsheet(CSV)", "3D(.PLY)", "3D(OBJ)", "3D(STL)", 
				"Ephemeris(CSV)", "Scal.Vect.Graph.(SVG)", "Params (.HTML)"])
				.name('Type of file')
				.onChange(function (e) {
					if (e == "Scal.Vect.Graph.(SVG)") { unitsSVG.enable() } else { unitsSVG.disable() };
					if (e == "Spreadsheet(CSV)") { sepCSV.enable() } else { sepCSV.disable() }
				});


			const absoluteUnits = {
				"millimeters": "mm",
				"quarters-millimeters(0.25mm)": "Q",
				"centimeters": "cm",
				"inches (2.54cm)": "in",
				"pixels": "px",
				"auto": "auto"
			}
			const unitsSVG = folderFiles.add(cs, "unitSVG", absoluteUnits)
				.name('SVG units')
			//   .onChange(function(e){});

			unitsSVG.disable();

			const separateurCSV = {
				"semicolon": ";",
				"comma ": ",",
				"espace": " "
			}
			const sepCSV = folderFiles.add(cs, "separateurCSV", separateurCSV)
				.name('CSV separator')
			//   .onChange(function(e){});

			unitsSVG.disable();
			sepCSV.disable()

			// // Exemples --------------------------------------------------------------------------------------

			const folderSamples = gui.addFolder(sp+"Exemples")
			let urlServeur = location.href
			function newSundial(nf) {
				if (urlServeur.indexOf("#") > 0) { urlServeur = urlServeur.substring(0, urlServeur.indexOf("#")) }
				window.open(urlServeur + "#" + nf)
			}
			let objEx = {
				myEx1: function () { newSundial('Bab&Ita-DSavoie-p278.json') },
				myEx2: function () { newSundial('Antiques-DSavoie-p301.json') },
				myEx3: function () { newSundial('Sideral-DSavoie-p291.json') },
				myEx4: function () { newSundial('CollinEx1.json') },
				myEx5: function () { newSundial('CollinEx4.json') },
				myEx6: function () { newSundial('LambertAustral.json') },
				myEx7: function () { newSundial('LambertBoreal.json') },
				myEx8: function () { newSundial('ParentOccidental.json') },
				myEx9: function () { newSundial('CadranHerstmonceux.json') },
				myEx10: function () { newSundial('BifilaireOslo.json') },
				myEx11: function () { newSundial('HorizontalCusco.json') }
			}
			const CadPolairesEx = folderSamples.addFolder('Polar or straigth style');
			CadPolairesEx.add(objEx, 'myEx1').name("Bab&Ita-D.Savoie-p278");
			CadPolairesEx.add(objEx, 'myEx2').name("Hours antics-D.Savoie p301")
			CadPolairesEx.add(objEx, 'myEx3').name('Sideral-DSavoie-p291');
			CadPolairesEx.add(objEx, 'myEx11').name('Horizontal Cusco (Perou)');

			const BifilairesEx = folderSamples.addFolder('Bifilar');
			BifilairesEx.add(objEx, 'myEx4').name("D.Collin Ex1");
			BifilairesEx.add(objEx, 'myEx5').name("D.Collin Ex4");
			BifilairesEx.add(objEx, 'myEx10').name("Generalised Bifilar Oslo");

			const AnalemEx = folderSamples.addFolder('Analemmatic');
			AnalemEx.add(objEx, 'myEx6').name("Lambert austral");
			AnalemEx.add(objEx, 'myEx7').name("Lambert boreal");
			AnalemEx.add(objEx, 'myEx8').name("Parent Occidental");
			AnalemEx.add(objEx, 'myEx9').name("Herstmonceux");





			//generateGeometry;   

			scene.add(axeLocalisation);
			scene.add(cadranSolaireGroup);
			scene.add(axeMondeGroup);
			scene.add(earthGroup);





			//cadran = new THREE.Mesh( geometryCS, materialCST ); 
			cadran.scale.x = cs.largeur;
			cadran.scale.y = cs.hauteur;
			cadran.scale.z = cs.epaisseur;
			cadran.receiveShadow = true;
			//console.log(geometryCS)

			gnomon.position.x = cs.xgnomon;
			gnomon.position.y = cs.ygnomon;
			gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2;

			gnomon.scale.y = cs.hgnomon;
			gnomon.scale.x = cs.egnomon;
			gnomon.scale.z = cs.egnomon;
			gnomon.rotation.x = Math.PI * 0.5;
			gnomon.castShadow = true; //default is false



			cadranSolaireGroup.add(cadran);
			//    cadranSolaireGroup.add( gnomon );
			//    cadranSolaireGroup.add( boutGnomon );
			//    cadranSolaireGroup.add( debutGnomon );
			// cadranSolaireGroup.add( boutGnomon );

			orienterAxedumonde()
			PlacerLaTerre()
			eulerCsGroup();
			//eulerEarthGroup() 

			PlacerLeSoleil();
			PlacerLaTerre();
			sphereEarth.rotation.y = -Math.PI * 0.5;


			// helpers 
			const axesESZHelper = new THREE.AxesHelper(Math.max(cs.largeur, cs.hauteur, cs.epaisseur));
			scene.add(axesESZHelper);
			// 				const camHelper = new THREE.CameraHelper( light.shadow.camera );
			//              scene.add(camHelper) 
			//EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9)



			const couleurMenu = "#C8FAFF"
			for (let g = 0; g < gui.folders.length; g++) {
				gui.folders[g].$title.style.color = couleurMenu
				gui.folders[g].close()
				if (cs.autoCloseMenu) {
					gui.folders[g].domElement.addEventListener("mouseleave", function () {
						gui.folders[g].close()
					})
					gui.folders[g].domElement.addEventListener("mouseenter", function () {
						gui.folders[g].open()
					})
				}
			}


			CadPolairesEx.close()
			BifilairesEx.close()
			AnalemEx.close()


			initMenu(cs.typeCadran)
			scene.background = new THREE.Color(cs.background);

			EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
			TracerHeuresEtArcs()
			//console.log (window.location.href);

		}//init



		//  EXPORT---------------------------------------------------------------------------------

		function GenererPLY() {
			const plyExporter = new PLYExporter();
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			s = plyExporter.parse(cadranSolaireGroup)
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}

		function GenererOBJ() {
			const objExporter = new OBJExporter();
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			s = objExporter.parse(cadranSolaireGroup)
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}

		function GenererSTL() {
			const stlExporter = new STLExporter();
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			s = stlExporter.parse(cadranSolaireGroup, { binary: false })
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}






		//-------------------------------------------------------------------------------------------------------------

		function orienterAxedumonde() {

			axeMonde.setDirection(new THREE.Vector3(0, Math.sin(cs.lati * Math.PI / 180),
				-Math.cos(cs.lati * Math.PI / 180)));
			axeMonde.setLength(Math.max(cs.largeur, cs.hauteur, cs.epaisseur), 30, 10);
			//   helperLight.update()
			//   axeMonde.visible=cs.voirTerre;
			//   axeMonde.visible=false;

		}

		//--------------------------------------------------------------------------------------
		function PlacerLeSoleil() {
			const k = 2 * Math.max(cs.largeur, cs.hauteur, cs.epaisseur);
			const v3 = new THREE.Vector3();
			
			let h, he, min, sec, y, m, d, dec, eqt, date, sdate, hsol;

			h = Math.floor(cs.hsol);
			min = Math.floor((cs.hsol - h) * 60);
			sec = Math.floor((cs.hsol - h - min / 60) * 3600);
			//console.log(cs.hsol,sec)
			h = (h < 10) ? "0" + h : h;
			min = (min < 10) ? "0" + min : min;
			sec = (sec < 10) ? "0" + sec : sec;

			date = JULIAN.JDToCalendarGregorian(TS.jdates[cs.dayofYear - 1]);
			//jde= JULIAN.CalendarGregorianToJD(cs.year, date.month, date.day); 
			dec = base.toDeg(TS.decSuns[cs.dayofYear - 1]);

			dec = Math.round(dec * 1000) / 1000;

			eqt = Math.round(SEXA.secFromHourAngle(TS.eqtimes[cs.dayofYear - 1]));
			//hsol=cs.hsol + eqt/3600 +(cs.longi/15 - cs.offset_sec/3600); //correction de l'heure
			hsol = cs.hsol + eqt / 3600   // correction eq. du temps
			if (cs.typeCadran != ANL) { hsol += cs.longi / 15 - cs.offset_sec / 3600 }   // pas d'heure l√©gale avec un analemmatique
			//console.log(cs.typeCadran,ANL,cs.typeCadran!=ANL)
			d = Math.floor(date.day); m = date.month; y = date.month;
			d = (d < 10) ? "0" + d : d;
			m = (m < 10) ? "0" + m : m;
			sdate = d + "/" + m + "/" + date.year;  //date JJ/MM/YYYY

			sphereSun.position.z = k * Math.cos(base.toRad(dec)) * Math.cos(base.toRad(-(hsol - 12) * 15));
			sphereSun.position.x = k * Math.cos(base.toRad(dec)) * Math.sin(base.toRad(-(hsol - 12) * 15));
			sphereSun.position.y = k * Math.sin(base.toRad(dec));

			sphereSun.getWorldPosition(v3);
			light.position.set(v3.x, v3.y, v3.z).normalize();
			light.castShadow = (v3.y > 0)  // le soleil dit √™tre au desus de l'horizon	
			
			labeltime.innerHTML = h + ":" + min + ':' + sec + "  " + sdate + " dec:" + dec.toFixed(3) + "¬∞  eqt:" + eqt + 's'
			//labeldeceqt.innerHTML="dec:"+dec.toFixed(3)+"¬∞  eqt:"+eqt+'s'
			//  helperLight.update()
			//scene.background = new THREE.Color( cs.background*((12-cs.hsol)/24) );

		    
		}

		function myTimerSun() {
			cs.hsol += cs.vrotSun / 360000;
			if (cs.hsol > 24) { cs.hsol = 0 };
			PlacerLeSoleil()
		}
		let temporisation = null;
		function RotationSoleil(e) {
			window.clearInterval(temporisation);
			if (e > 0) { temporisation = window.setInterval(myTimerSun, 10) }; //    1/100 sec
		}
		// -------------------------------------------------------------------------------------------------------
		function CoordRayTracing(cadran,hrad,dec) {   // hrad: angle horaire en radians de -Pi a Pi   dec declinaison du soleil en radians
			let rayOrigin = new THREE.Vector3();
			let rayDirection = new THREE.Vector3();
			let coordRayCaster = new THREE.Vector3();
			// let dec=TS.decSuns[j-1]
			const k = 2 * Math.max(cs.largeur, cs.hauteur, cs.epaisseur);

			rayOrigin.set(cs.xgnomon / cadran.scale.x, cs.ygnomon / cadran.scale.y, (cs.hgnomon + cs.epaisseur / 2) / cadran.scale.z)
			cadran.localToWorld(rayOrigin)
			//console.log(hsol,dec)
			// sphereSun.position.z =  k*Math.cos(dec) * Math.cos(base.toRad(-(hsol - 12) * 15));
			// sphereSun.position.x =  k*Math.cos(dec) * Math.sin(base.toRad(-(hsol - 12) * 15));
			sphereSun.position.z =  k*Math.cos(dec) * Math.cos(-hrad);
			sphereSun.position.x =  k*Math.cos(dec) * Math.sin(-hrad);
			sphereSun.position.y =  k*Math.sin(dec);
			sphereSun.getWorldPosition(rayDirection)

			rayDirection.negate();
			rayDirection.normalize();
			rayCaster.set(rayOrigin, rayDirection)
			//console.log(rayOrigin,rayDirection)
			const intersects = rayCaster.intersectObject(cadran);
			if (intersects.length > 0) {
				coordRayCaster = cadran.worldToLocal(intersects[0].point)
				coordRayCaster.set(coordRayCaster.x * cadran.scale.x -cs.xgnomon, coordRayCaster.y * cadran.scale.y - cs.ygnomon, coordRayCaster.z * cadran.scale.z)
			//	console.log(coordRayCaster.x * cadran.scale.x, coordRayCaster * cadran.scale.y, coordRayCaster.z * cadran.scale.z)			
				return {
					x: coordRayCaster.x,
					y: coordRayCaster.y,
					z: coordRayCaster.z,
					ok:true
				}}
				else return {
					x: 0,
					y: 0,
					z: 0,
					ok:false}

			}
		
		// Terre ---------------------------------------------------------------------------------------------------
		function PlacerLaTerre() {
			let r, l;
			r = cs.hauteur;
			sphereEarth.scale.x = r; sphereEarth.scale.y = r; sphereEarth.scale.z = r;
			earthGroup.position.x = 0;
			earthGroup.position.y = -(cs.hauteur / 2 + r) * 1.2;
			earthGroup.position.z = 0;
			earthGroup.rotation.x = -base.toRad(90 - cs.lati);
			earthGroup.rotation.y = -base.toRad(cs.longi);
			earthGroup.visible = cs.voirTerre;
			axeTerre.setLength(r * 1.5, r * 1.5 * 0.1, r * 1.5 * 0.02);
			l = -earthGroup.position.y - r;
			axeLocalisation.setLength(l, 0.1 * l, 0.02 * l)
			axeLocalisation.visible = cs.voirTerre;

			//	console.log(renderer.info)

		}

		//---------------------------------------------------------------------------------------------------------

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);

		}


		function animate() {
			//console.log("animate")
			requestAnimationFrame(animate);

			if (cs.vrotscene > 0) { scene.rotation.y += 0.001 * cs.vrotscene } else { scene.rotation.y = 0 };

			render();
			stats.update();

			document.body.style.cursor = "auto"
		}

		//

		function render() {

			renderer.render(scene, camera);

		}



	</script>



</body>

</html>