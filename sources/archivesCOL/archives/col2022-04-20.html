<!DOCTYPE html>
<html lang="en">
@
<head>
	<title>CadsolOnLine</title>
	<link rel="icon" type="image/x-icon" href="./favicon.ico">
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0">
	<link type="text/css" rel="stylesheet" href="./main.css">
</head>

<body>
	<div id="container"></div>

	<div id="info">
		<h1>CadsolOnLine</h1>
		<!-- version: <a href="https://cadsol.web-pages.fr/" target="_blank"> 2022.04.19</a></br> -->
		version 22.04.19 <a href="https://cadsol.web-pages.fr/" target="_blank"> cadsol.fr</a></br>
		3D library: <a href="https://threejs.org" target="_blank" rel="noopener">Three.js</a> </br>

		Astronomical library:
		<a href="https://en.wikipedia.org/wiki/Jean_Meeus" target="_blank" rel="noopener">Jean Meeus</a> </br>
		<!--  <a href="https://en.wikipedia.org/wiki/Sonia_Keys" target="_blank" rel="noopener">Sonia Keys</a> & 
        <a href="https://github.com/commenthol/astronomia" target="_blank" rel="noopener">commenthol</a></br>
	    <a     https://articles.adsabs.harvard.edu//full/2000JRASC..94...95C/0000103.000.html     Dominique Collin-->
		</p>
		<img src="./imageMoret.jpg" alt="Image" style="max-width:100%;height:auto">
		</p>
		</p>
		<label for="fileinput">. Open existing Sundial (JSON) . </label>

		<div id="menu"><br></div>
		<input type="file" id="fileinput" accept=".json">


		<script>
			const docinput = document.querySelector('input');
			docinput.style.opacity = 0;
		</script>

	</div>

	<div id="time"></div>


</@body>





<script type="module">



	        import * as THREE from '../build/three.module.js';
			import Stats from './jsm/libs/stats.module.js';
		//	import { GUI } from './jsm/libs/dat.gui.module.js';
			import { GUI } from './jsm/libs/lil-gui.module.min.js';
	   		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		    import {apparentEquatorial} from '../astronomia-master/src/solar.js';
		    import * as JULIAN from '../astronomia-master/src/julian.js';		
		    import * as base from '../astronomia-master/src/base.js';					
            import * as EQTIME from '../astronomia-master/src/eqtime.js';	
            import * as SEXA from '../astronomia-master/src/sexagesimal.js';

            import { FontLoader } from './jsm/loaders/FontLoader.js';
			import { TextGeometry } from './jsm/geometries/TextGeometry.js';
            import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';
			//import { DDSLoader } from './jsm/loaders/DDSLoader.js';
			import { PLYExporter } from './jsm/exporters/PLYExporter.js';
			//import { GLTFExporter } from './jsm/exporters/GLTFExporter.js';
			import { OBJExporter } from './jsm/exporters/OBJExporter.js';
            
            document.querySelector("input").addEventListener('change', function() {loadJsonFile() });

			
            // if (navigator.geolocation) {
            //   navigator.geolocation.watchPosition(showPosition);
            // } else { cs.lati = 0;
            //          cs.longi= 0} ;  

            // function showPosition(position) {
            //    cs.lati = position.coords.latitude;
            //    cs.longi= position.coords.longitude}

			let SP="Classic",BF=" Bifilar (vertical) ";

            let  cs ={    version:"22.04.14", 
                          nameFile:"mySundial",
						  typeCadran:SP,
				          export:"?",			        
					      largeur:600,
				          hauteur:400,
				          epaisseur:30,
				          decli:0,
				          incli:90,
				          rot:0,
				          colorCS: "rgb(200,250,250)",
				          emissiveCS:"rgb(37,53,37)",
				     //     specularCS:"rgb(0,0,0)",
				          opaciteCS:0.5,
				          lati:45,
				          longi:0,
				          adresse:"",
				          urlOpenStreet:"",
				          timezone:"",
				          offset_sec:0,
				          offset_string:"",
				          now_in_dst:0,
				          dst:0,
				          hgnomon:50,
				          egnomon:1,
				          xgnomon:0,				         
				          ygnomon:100, 
				          vgnomon:true,
				          vstyle:true,
				          vsousstyle:true,
						  hfilHorizontal:30,
						  hfilVertical:50,
				          heuresSolaires:true,
						  heuresLegalesSummerAutums:false,
						  heuresLegalesWinterSpring:false,
						  colorHS:"rgb(185,255,75)",
						  colorHLSummerAutums:"rgb(210,200,230)",
						  colorHLWinterSpring:"rgb(0,0,200)",
						  hoursTextSize:1,
						  equinoxeAndSolstices:false,
						  colorequinoxeAndSolstice:"rgb(152,0,0)",
						  datesArcsDiurnes:[],  // [[date, dec en rad]]  tableau à deux dimensions
				          devise:"Carpe Diem",
						  deviseSize:1,
				          hsol:13.5,
				          decsol:0,
				          axesESZ:true,
				          voirTerre:true,
				          vrotscene:0,
					      year:2022,
						  dayofYear:105,
						  vrotSun:0,
						  vanalemSun:0
				          };
				
				//document.getElementById("ver").innerHTML=cs.version

				let container, stats,buttonNewSundial;
				let camera, scene, renderer;   
		        container = document.getElementById( 'container' );
                
				// camera

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10000 );
				camera.position.set( 2000, 2000, 2000 );
				//camera.position.set( 0, 0, 2000 );

				// scene
                scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				// light

				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1, 1 ).normalize();
				
				const ambientLight = new THREE.AmbientLight( 0x303030 ); // soft white light
        		scene.add( ambientLight );

				//Set up shadow properties for the light
				light.shadow.mapSize.width = 2048*4; // default
				light.shadow.mapSize.height =2048*4; // default
				light.shadow.camera.near = -1000; // default
				light.shadow.camera.far = 1000; // default
				light.shadow.camera.top = 1000;
				light.shadow.camera.bottom = -1000;
				light.shadow.camera.right = 1000;
				light.shadow.camera.left = -1000;
				

				light.castShadow = true; // default false
				scene.add( light );
				//const helperLight = new THREE.DirectionalLightHelper( light, 100 );
				//scene.add( helperLight );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true,localClippingEnabled:true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
				container.appendChild( renderer.domElement );

				// stats
				stats = new Stats();
				container.appendChild( stats.dom );

                // OrbitControls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10000;

				//addEventListener
				window.addEventListener( 'resize', onWindowResize );
				
				//Button New Sundial
				buttonNewSundial = document.createElement( 'button' );
			    buttonNewSundial.innerHTML ='New Sundial';
			    const menu = document.getElementById( 'menu' );
			    menu.appendChild( buttonNewSundial );
				buttonNewSundial.addEventListener("click", function() { run() });

				
				//Button Clock
				const labelclock = document.createElement( 'label' );
			    const labelutc = document.getElementById( 'time' );
			    labelutc.appendChild( labelclock );
				const d = '';
                labelutc.innerHTML = d;
				

			let cadran,gnomon,stylePolaire,sousStylaire,geometryCS ;
			let meshDevise,cadranSolaireGroup,axeMondeGroup, earthGroup;
			let heuresSolairesGroup,heuresLegalesGroupSA,heuresLegalesGroupWS,arcsDiurnesGroup;
			let heuresSolairesListeMesh,heuresLegalesListeMeshSA,heuresLegalesListeMeshWS,arcsDiurnesListeMesh;
			let CSVtext,SVGtext,CSVephemerid;
		
			
			
				const separateurCSV =";"

                cadranSolaireGroup = new THREE.Group();               
                heuresSolairesGroup=new THREE.Group();
				heuresLegalesGroupSA=new THREE.Group();
				heuresLegalesGroupWS=new THREE.Group();
				arcsDiurnesGroup=new THREE.Group();
				heuresSolairesListeMesh=[];
                heuresLegalesListeMeshSA=[];
				heuresLegalesListeMeshWS=[];
				arcsDiurnesListeMesh=[];

                const materialHeuresSolaires  = new THREE.MeshStandardMaterial(
					{transparent:true,opacity:1,side:THREE.DoubleSide,});
				const materialHeuresLegalesSA = new THREE.MeshStandardMaterial(
					{transparent:true,opacity:1,side:THREE.DoubleSide});
				const materialHeuresLegalesWS = new THREE.MeshStandardMaterial(
					{transparent:true,opacity:1,side:THREE.DoubleSide});
                const materialGnomon = new THREE.MeshStandardMaterial( 
					{transparent:true,opacity:1,side:THREE.DoubleSide,color: 0xffffff} );
                const materialCS = new THREE.MeshStandardMaterial(); 
				const materialArcsDiurnes = new THREE.MeshStandardMaterial(
					{transparent:true,opacity:1,side:THREE.DoubleSide,color: cs.colorequinoxeAndSolstice}); 
                //materialCS.depthWrite=false; 
				// materialHeuresSolaires.tramage=true; 
                //materialHeuresSolaires.precision="highp"
               				
				// Axe de rotation de la terre
                   const axeMonde = new THREE.ArrowHelper(
                   new THREE.Vector3( 0, Math.sin(cs.lati*Math.PI/180), -Math.cos(cs.lati*Math.PI/180)),
                   new THREE.Vector3( 0, 0, 0 ), 
                   Math.max(cs.largeur,cs.hauteur,cs.epaisseur), 
                   0xffff00,30,15 );
			   
               
               axeMondeGroup = new THREE.Group(); 
               axeMondeGroup.add(axeMonde);              			   	   
			   axeMonde.visible=false;
			  
                const textureLoader = new THREE.TextureLoader();

			    const earthGeometry = new THREE.SphereGeometry( 1, 32, 32 );
				const earthMaterial = new THREE.MeshPhongMaterial( {
					specular: 0x333333,
					emissive:"rgb(5,5,5)",
					shininess: 5,
				    map: textureLoader.load( './earth_pm_2048.jpg' ),
					specularMap: textureLoader.load( 'textures/planets/earth_specular_2048.jpg' ),
					normalMap: textureLoader.load( 'textures/planets/earth_normal_2048.jpg' ),
					normalScale: new THREE.Vector2( 1,1 )					
			  	    } );
				earthMaterial.tranparent=true;
				earthMaterial.opacity=0.5;
				const sphereEarth = new THREE.Mesh( earthGeometry, earthMaterial );
				earthGroup = new THREE.Group();  
			    earthGroup.add(sphereEarth);


		        const geometrySun = new THREE.SphereGeometry( 15, 32, 16 );
			    const materialSun = new THREE.MeshPhongMaterial( { 
					                        //color: 0xffff00, 
											//specular: 0x333333,
											emissive:"rgb(100,100,5)",
											shininess: 5,
				                            map: textureLoader.load( './sun.jpg' ) } );
			    const sphereSun = new THREE.Mesh( geometrySun, materialSun );
				axeMondeGroup.add( sphereSun );
                sphereSun.parent=axeMonde;


			    const axeTerre = new THREE.ArrowHelper(
				   new THREE.Vector3( 1,1,1),
                   new THREE.Vector3( 0,0, 0 ), 
                   Math.max(cs.largeur,cs.hauteur,cs.epaisseur), 
                   0xffffff,30,15 );
                earthGroup.add(axeTerre);  

			
			   const axeLocalisation = new THREE.ArrowHelper(
                   new THREE.Vector3( 0, -1,0),
                   new THREE.Vector3( 0, 0, 0 ), 
                   Math.max(cs.largeur,cs.hauteur,cs.epaisseur), 
                   0x00ff00,30,15 );
    
			
               scene.add( axeLocalisation );
			   scene.add( cadranSolaireGroup );
			   scene.add( axeMondeGroup );
			   scene.add( earthGroup );

			   
               const TS=TableSol(cs.year);

			   let fontDevise;
			   loadFontDevise();

			   getLocation();

//------------------------------------------------------------------------------
// const loader = new DDSLoader();
// const cubemap2 = loader.load( 'textures/compressed/Mountains_argb_mip.dds', function ( texture ) {

// texture.magFilter = THREE.LinearFilter;
// texture.minFilter = THREE.LinearFilter;
// texture.mapping = THREE.CubeReflectionMapping;
// material5.needsUpdate = true;
// } ); 

// const material5 = new THREE.MeshBasicMaterial( { envMap: cubemap2 } );

//-----------------------------------------------------------------------------------------------
// Localisation
function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showPosition);
  } else { 
    alert("Geolocation is not supported by this browser.") ;
  }
}

function showPosition(position) {
  cs.lati = position.coords.latitude ; 
  cs.longi= position.coords.longitude;
}
//----------------------------------------------------------------------------
function loadFontDevise() {
    const loader = new FontLoader();
    loader.load( './fonts/helvetiker_regular.typeface.json', function ( response ) {
                 fontDevise = response } );
	}

// Ecritures------------------------------------------------------------  
function EcrireDevise(texte,x,y){

const fontGeometry = new TextGeometry( texte, {
		   font: fontDevise,
		   size:10*cs.deviseSize,             //ajuster sur largeur
		   height: 2*cs.deviseSize,           //ajuster sur largeur
		   curveSegments: 4,
		   bevelEnabled: true,
		   bevelThickness: 0.5*cs.deviseSize, //ajuster sur largeur
		   bevelSize: 0.5*cs.deviseSize,      //ajuster sur largeur
		   bevelOffset: 0,
		   bevelSegments: 1
	   } );
meshDevise=new THREE.Mesh( fontGeometry, materialGnomon);
cadranSolaireGroup.add(meshDevise);
meshDevise.position.x = x;
meshDevise.position.y = y;
meshDevise.position.z = cs.epaisseur/2
} 

function EcrireTexte(texte,x,y,material,group,listeMesh){
if (cs.hoursTextSize==0) return;

let mesh
const fontGeometry = new TextGeometry( texte, {
			font: fontDevise,
			size:7*cs.hoursTextSize,             //ajuster sur largeur
			height: 1*cs.hoursTextSize,           //ajuster sur largeur
			curveSegments: 4,
			bevelEnabled: true,
			bevelThickness: 0.5*cs.hoursTextSize, //ajuster sur largeur
			bevelSize: 0.5*cs.hoursTextSize,      //ajuster sur largeur
			bevelOffset: 0,
			bevelSegments: 1
		} );
 mesh=new THREE.Mesh( fontGeometry, material);
 
 group.add(mesh);
 if (listeMesh){listeMesh.push(mesh)};
 if (x>0){x-=10*cs.hoursTextSize}else{x+=2*cs.hoursTextSize}
 mesh.position.x = x;
 if (y>0){y-=10*cs.hoursTextSize}else{y+=2*cs.hoursTextSize}

 mesh.position.y = y;
 mesh.position.z = cs.epaisseur/2;

}


//TableSol------------------------
function TableSol(year) {
  let jde,ae,dec,eqt,jdes,eqts,decs;
  let decSunMin=0,decSunMax=0,jdecSunMin=0,jdecSunMax=0,j=0;
  jdes=[];eqts=[];decs=[]
  jde= JULIAN.CalendarGregorianToJD(year, 1, 1.5);  //Premier Janvier à 12h
  while (jde<=JULIAN.CalendarGregorianToJD(year, 12, 31.5))//31 decembre à 12h
    { 
    ae=apparentEquatorial(jde);
    dec=ae.dec;
	if (dec>decSunMax){decSunMax=dec;jdecSunMax=j};
	if (dec<decSunMin){decSunMin=dec;jdecSunMin=j};
    eqt=EQTIME.eSmart(jde);
    jdes.push(jde);eqts.push(eqt);decs.push(dec)
    jde+=1;j+=1
	 };
 // console.log(jdecSunMin,jdecSunMax);
  return {//Tableaux à 365 ou 366 elements, valeurs calculées à 12h
	      decSuns:decs,  //radians
          eqtimes:eqts,  //equation of time as an hour angle in radians.
          jdates:jdes,    //jourjulien
		  //jours des solstices
		  jdecSunMin,
		  jdecSunMax
          }             

}

//-----------------------------------------------------------------------------------------------------
function Ephemerid(year) {
    let d,s;
	
	CSVephemerid  = " DATE"+separateurCSV+"TIME EQUATION (s)"+separateurCSV+"SUN DECLINATION (°)"+separateurCSV+"Julian Day"+"\n"
	CSVephemerid +=" \n";
	CSVephemerid +="Ephemerids year:  "+cs.year+"\n\n";
	CSVephemerid +="CadsolOnLine  Version:"+cs.version+"\n\n";
	CSVephemerid +="(c) Jean Meeus \n* Chapter 28 Equation of time \n* Chapter 25  Solar Coordinates ...\n\n";
	CSVephemerid +=" \n";
 //   const TS=TableSol(cs.year);
	for (let i = 0; i < TS.decSuns.length; i++) {
		d=JULIAN.JDToCalendarGregorian(TS.jdates[i]);
		CSVephemerid +=d.day+"/"+d.month+"/"+d.year	+separateurCSV;  //date JJ/MM/YYYY
		s=Math.round(SEXA.secFromHourAngle(TS.eqtimes[i]));	// equation du temps en secondes	
		CSVephemerid +=s.toFixed(0)+'     '+separateurCSV;
		s=base.toDeg(TS.decSuns[i]);  //dec soleil en degres
		CSVephemerid +=s.toFixed(4);
		if (i==TS.jdecSunMin){CSVephemerid += "  Winter Solstice "}
		if (i==TS.jdecSunMax){CSVephemerid += "  Summer Solstice "}
		CSVephemerid +=separateurCSV
		CSVephemerid +=TS.jdates[i];
		CSVephemerid +="\n"
	}	
	//console.log(CSVephemerid)
   }
//-----------------------------------------------------------------------------------------------------				          
function run() {	        
	           
			init();	
		
			animate();
			
            
// 		const jde = JULIAN.CalendarGregorianToJD(2022, 6, 24);
// 		//const coordSoleilT=trueEquatorial(jde);
//		const coordSoleilA=apparentEquatorial(jde);
// 		console.log(jde,base.toDeg(coordSoleilA.dec),SEXA.secFromHourAngle(EQTIME.eSmart(jde)));
// 		//function general (φ, D, a, z) { // (φ, D, a, z float64)  
// 		//(lines []Line, center Point, u, ψ float64)
// 		s=SUNDIAL.general(base.toRad(cs.lati),base.toRad(cs.decli),cs.hgnomon,base.toRad(cs.incli));
// 		console.log(s);	
// 		console.log('angle',base.toDeg(s.angle));	
// 		console.log(s.center.x);
// 		console.log(s.center.y);
// 		console.log('length',s.lines.length);
// 		console.log(s.lines);
// 		console.log(s.lines[10]);
// 		console.log(s.lines[10].hour);
// 		console.log(s.lines[10].points[5]);
// 		console.log(s.lines[10].points[5].x);
// 	const jde=JULIAN.CalendarGregorianToJD(2022, 1, 1);	 

 // let  TS;     
 //  TS=TableSol(2022);
	// console.log(TS.jdates);
	// console.log(TS.eqtimes);
	// console.log(TS.decSun);
	// console.log(JULIAN.JDToCalendarGregorian(TS.jdates[123]),
	//             SEXA.secFromHourAngle(EQTIME.eSmart(TS.jdates[123])),
	//             base.toDeg(TS.decSun[123])
	//             );


		
}
//------------------------------------------------------------------------------------------------------------
function TracerHeures (){
   if (cs.heuresSolaires) {TracerHeuresSolaires()}
   if (cs.heuresLegalesSummerAutums){TracerHeuresLegalesSA()}
   if (cs.heuresLegalesWinterSpring){TracerHeuresLegalesWS()}
   TracerArcsDiurnes()
}
// --------------------------------------------------------------------------------------------------------
function pointDansCadran(x,y)
{
	return ((Math.abs(x)<=(cs.largeur/2.1))&&(Math.abs(y)<=(cs.hauteur/2.1))) 
}
//---------------------------------------------------------------------------------------------------------
function TracerStyle(sunDial){
//	let tubeGeometrySP,tubeGeometrySS
if (typeof(stylePolaire)!=="undefined") {stylePolaire.geometry.dispose()};
if (typeof(sousStylaire)!=="undefined") {stylePolaire.geometry.dispose()};
cadranSolaireGroup.remove(stylePolaire);
cadranSolaireGroup.remove(sousStylaire);

if (base.toDeg(sunDial.angle)>0.4) 
//  Si l'angle Style polaire-SousStylaire> 0.4°
{ const v1=new THREE.Vector3( sunDial.center.x+cs.xgnomon,sunDial.center.y+cs.ygnomon, (cs.epaisseur-cs.egnomon)/2 );
  const v2=new THREE.Vector3( cs.xgnomon,cs.ygnomon, cs.hgnomon+(cs.epaisseur-cs.egnomon)/2);
  const tubeGeometrySP = new THREE.TubeGeometry( new THREE.LineCurve3( v1, v2 ), 16, cs.egnomon,8 );
  stylePolaire = new THREE.Mesh( tubeGeometrySP, materialGnomon);
  stylePolaire.castShadow = true;
  cadranSolaireGroup.add(stylePolaire);
  stylePolaire.visible=cs.vstyle;
// Sous-stylaire
  const v4=new THREE.Vector3( cs.xgnomon,cs.ygnomon, (cs.epaisseur+cs.egnomon)/2);
  const tubeGeometrySS = new THREE.TubeGeometry( new THREE.LineCurve3( v1, v4 ), 16, cs.egnomon,8 );
  sousStylaire = new THREE.Mesh( tubeGeometrySS, materialGnomon);
  sousStylaire.castShadow = true;
  cadranSolaireGroup.add(sousStylaire);
  sousStylaire.visible=cs.vsousstyle
  }// sinon style polaire parallele au plan
}

//---------------------------------------------------------------------------------------------------------
function TracerHeuresSolaires ()
{let a,tubeGeometry,tubeGeometrySP,tubeGeometrySS,mesh,xp,yp,zp,lm,pipeSpline,pipeSplineCRC;
//Effacement des lignes existantes
   lm=heuresSolairesListeMesh.length;
   for (let i = 0; i < lm; i++)
                    {
   	                mesh = heuresSolairesListeMesh[ i ];
   	                mesh.geometry.dispose();
					heuresSolairesGroup.remove(mesh);
					}
   heuresSolairesListeMesh=[];
   cadranSolaireGroup.remove(heuresSolairesGroup);
   
   const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax,false,heuresSolairesGroup,materialHeuresSolaires,heuresSolairesListeMesh);
   CSVtext="Point"+separateurCSV+"x"+separateurCSV+"y"+"\n\n";
   CSVtext +="CadsolOnLine  Version:"+cs.version+"\n\n";
   a=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+a.toFixed(3)+"\n\n";
   // tracé des nouvelles lignes
   for (let i = 0; i < sunDial.lines.length; i++) {
   		if (sunDial.lines[i].points.length>1) 
   		{ 	 CSVtext +="Heure: "+sunDial.lines[i].hour.toString()+"\n";
			 pipeSpline = [];
			
			 for (let p = 0; p < sunDial.lines[i].points.length; p++)
			    {
			 	xp=sunDial.lines[i].points[p].x+cs.xgnomon;
   			    yp=sunDial.lines[i].points[p].y+cs.ygnomon;
   			    zp=(cs.epaisseur+cs.egnomon)/2;
				if (pointDansCadran(xp,yp))
				     {pipeSpline.push(new THREE.Vector3(xp,yp,zp));
				     CSVtext += "point: "+separateurCSV+xp.toFixed(2)+separateurCSV+yp.toFixed(2)+"\n"}
				};			
				if (pipeSpline.length>1) 
				   {
				   pipeSplineCRC=[];
				   pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline);
				   tubeGeometry = new THREE.TubeGeometry( pipeSplineCRC,32, cs.egnomon,8,false );
				   mesh = new THREE.Mesh( tubeGeometry, materialHeuresSolaires);
				   mesh.receiveShadow = true;
				  // mesh.castShadow = true;
				   heuresSolairesListeMesh.push(mesh);
				   heuresSolairesGroup.add(mesh);
			       }
   		 }
   }
  TracerStyle(sunDial)
  cadranSolaireGroup.add(heuresSolairesGroup); 
  
}

//-------------------------------------------------------------------------------------------------------
function TracerHeuresLegalesSA ()
{let mesh,xp,yp,zp,lm,pipeSpline,pipeSplineCRC,a,tubeGeometry;
  //Effacement des lignes existantes
   lm=heuresLegalesListeMeshSA.length;
   for (let i = 0; i < lm; i++)
                    {
   	                mesh = heuresLegalesListeMeshSA[ i ];
   	                mesh.geometry.dispose();
					heuresLegalesGroupSA.remove(mesh);
					}
   heuresLegalesListeMeshSA=[];
   cadranSolaireGroup.remove(heuresLegalesGroupSA);

   const sunDial=generalAJL
        (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
        TS.jdecSunMax,TS.jdecSunMin,true,heuresLegalesGroupSA,materialHeuresLegalesSA,heuresLegalesListeMeshSA);
   CSVtext="Point"+separateurCSV+"x"+separateurCSV+"y"+"\n\n";
   CSVtext +="CadsolOnLine  Version:"+cs.version+"\n\n";
   a=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+a.toFixed(3)+"\n\n";
   // tracé des nouvelles lignes
   for (let i = 0; i < sunDial.lines.length; i++) {
   		if (sunDial.lines[i].points.length>1) 
   		{ 	CSVtext +="Heure: "+sunDial.lines[i].hour.toString()+"\n";
			pipeSpline = [];
			for (let p = 0; p < sunDial.lines[i].points.length; p++)
			    {
			 	xp=sunDial.lines[i].points[p].x+cs.xgnomon;
   			    yp=sunDial.lines[i].points[p].y+cs.ygnomon;
   			    zp=(cs.epaisseur+cs.egnomon)/2;
				if (pointDansCadran(xp,yp))
				     {pipeSpline.push(new THREE.Vector3(xp,yp,zp));
				     CSVtext+= "point: "+separateurCSV+xp.toFixed(2)+separateurCSV+yp.toFixed(2)+"\n"}
				};
				
			if (pipeSpline.length>1) 
				   {
				   pipeSplineCRC=[];
				   pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline);
				   tubeGeometry = new THREE.TubeGeometry( pipeSplineCRC,128, cs.egnomon,8,false );
				   mesh = new THREE.Mesh( tubeGeometry, materialHeuresLegalesSA);
				   mesh.receiveShadow = true;
				   heuresLegalesListeMeshSA.push(mesh);
				   heuresLegalesGroupSA.add(mesh);
			       }
   		 }
   }
  TracerStyle(sunDial)
  cadranSolaireGroup.add(heuresLegalesGroupSA); 
}

function TracerHeuresLegalesWS(){
		let mesh,xp,yp,zp,lm,pipeSpline,pipeSplineCRC,a,tubeGeometry;
		//Effacement des lignes existantes
		lm=heuresLegalesListeMeshWS.length;
		for (let i = 0; i < lm; i++)
							{
							mesh = heuresLegalesListeMeshWS[ i ];
							mesh.geometry.dispose();
							heuresLegalesGroupWS.remove(mesh);
							}
		heuresLegalesListeMeshWS=[];
		cadranSolaireGroup.remove(heuresLegalesGroupWS);

		const sunDial=generalAJL
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax+1,true,heuresLegalesGroupWS,materialHeuresLegalesWS,heuresLegalesListeMeshWS);
		CSVtext="Point"+separateurCSV+"x"+separateurCSV+"y"+"\n\n";
		CSVtext +="CadsolOnLine  Version:"+cs.version+"\n\n";
		a=base.toDeg(sunDial.angle);
		CSVtext +="Angle style/plan: "+a.toFixed(3)+"\n\n";
		// tracé des nouvelles lignes
		for (let i = 0; i < sunDial.lines.length; i++) { 
				if (sunDial.lines[i].points.length>1) 
				{ 	 CSVtext +="Heure: "+sunDial.lines[i].hour.toString()+"\n";
					pipeSpline = [];
					for (let p = 0; p < sunDial.lines[i].points.length; p++)
						{
						xp=sunDial.lines[i].points[p].x+cs.xgnomon;
						yp=sunDial.lines[i].points[p].y+cs.ygnomon;
						zp=(cs.epaisseur+cs.egnomon)/2;
						if (pointDansCadran(xp,yp))
							{pipeSpline.push(new THREE.Vector3(xp,yp,zp));
							CSVtext+= "point: "+separateurCSV+xp.toFixed(2)+separateurCSV+yp.toFixed(2)+"\n"}
						    };
					if (pipeSpline.length>1) 
						{
						pipeSplineCRC=[];
						pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline);
						tubeGeometry = new THREE.TubeGeometry( pipeSplineCRC,128, cs.egnomon,8,false );
						mesh = new THREE.Mesh( tubeGeometry, materialHeuresLegalesWS);
						mesh.receiveShadow = true;
						heuresLegalesListeMeshWS.push(mesh);
						heuresLegalesGroupWS.add(mesh);
						}
				}	
			}
		TracerStyle(sunDial)
        cadranSolaireGroup.add(heuresLegalesGroupWS); 
}

//---------------------------------------------------------------------------------------------------------
function TracerArcsDiurnes ()
{let a,tubeGeometry,tubeGeometrySP,tubeGeometrySS,mesh,xp,yp,zp,lm,pipeSpline,pipeSplineCRC;
//Effacement des lignes existantes
   lm=arcsDiurnesListeMesh.length;
   for (let i = 0; i < lm; i++)
                    {
   	                mesh = arcsDiurnesListeMesh[ i ];
   	                mesh.geometry.dispose();
					arcsDiurnesGroup.remove(mesh);
					}
   arcsDiurnesListeMesh=[];
   cadranSolaireGroup.remove(arcsDiurnesGroup);
   
   const sunDial=arcsDiurnes
         (base.toRad(cs.lati),base.toRad(-cs.decli),cs.hgnomon,base.toRad(cs.incli),
         TS.jdecSunMin,TS.jdecSunMax,false,arcsDiurnesGroup,materialArcsDiurnes,arcsDiurnesListeMesh);
   CSVtext="Point"+separateurCSV+"x"+separateurCSV+"y"+"\n\n";
   CSVtext +="CadsolOnLine  Version:"+cs.version+"\n\n";
   a=base.toDeg(sunDial.angle);
   CSVtext +="Angle style/plan: "+a.toFixed(3)+"\n\n";
   // tracé des nouvelles lignes
   for (let i = 0; i < sunDial.lines.length; i++) {
   		if (sunDial.lines[i].points.length>1) 
   		{ 	 CSVtext +="Date: "+sunDial.lines[i].date.toString()+"\n";
			 pipeSpline = [];
			
			 for (let p = 0; p < sunDial.lines[i].points.length; p++)
			    {
			 	xp=sunDial.lines[i].points[p].x+cs.xgnomon;
   			    yp=sunDial.lines[i].points[p].y+cs.ygnomon;
   			    zp=(cs.epaisseur+cs.egnomon)/2;
				if (pointDansCadran(xp,yp))
				     {pipeSpline.push(new THREE.Vector3(xp,yp,zp));
				     CSVtext+= "point: "+separateurCSV+xp.toFixed(2)+separateurCSV+yp.toFixed(2)+"\n"}
				};			
				if (pipeSpline.length>1) 
				   {
				   pipeSplineCRC=[];
				   pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline);
				   tubeGeometry = new THREE.TubeGeometry( pipeSplineCRC,64, cs.egnomon,8,false );
				   mesh = new THREE.Mesh( tubeGeometry, materialArcsDiurnes);
				   mesh.receiveShadow = true;
				   arcsDiurnesListeMesh.push(mesh);
				   arcsDiurnesGroup.add(mesh);
			       }
   		 }
   }
  TracerStyle(sunDial)
  cadranSolaireGroup.add(arcsDiurnesGroup); 
  
}

/**
 * Point return type represents a point to be used in constructing the sundial.
 */
function Point (x, y) {
  this.x = x || 0
  this.y = y || 0
}

/**
 * Line holds data to draw an hour line on the sundial.
 */
function LigneHoraire (hour, points) {
  this.hour = hour // 0 to 24
  this.points = points || [] // One or more points corresponding to the hour.
}

function LigneArc (date, points) {
  this.date = date // 1 to 365
  this.points = points || [] // One or more points corresponding to the date.
}

//const m = [-23.44,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-9,-8,-7,-6,-5,-4,-3,-2,-1,
//           0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23, 23.44]

/**
 * General computes data for the general case of a planar sundial.
 *
 * Argument φ is geographic latitude at which the sundial will be located.
 * D is gnomonic declination, the azimuth of the perpendicular to the plane
 * of the sundial, measured from the southern meridian towards the west.
 * Argument a is the length of a straight stylus perpendicular to the plane
 * of the sundial, z is zenithal distance of the direction defined by the
 * stylus.  Angles φ, D, and z are in radians.  Units of stylus length a
 * are arbitrary.
 *
 * Results consist of a set of lines, a center point, u, the length of a
 * polar stylus, and ψ, the angle which the polar stylus makes with the plane
 * of the sundial.  The center point, the points defining the hour lines, and
 * u are in units of a, the stylus length.  ψ is in radians.
 */

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
function Correction(H0,j) 
{ let c=0
	c=TS.eqtimes[j] + (cs.longi/15 - cs.offset_sec/3600)* Math.PI / 12;
 return (H0+c);  //angle horaire en radians, de -pi à +pi
}

////////////////////////////////////////////////////////////////////////////////////////////////////////

		  
function generalAJL (φ, D, a, z,debut,fin,legal,group,material,listeMesh) { 
	// (φ, D, a, z float64)  (lines []LigneHoraire, center Point, u, ψ float64)
	let H,xp,yp,xm,ym;
	if (φ*180/Math.PI>89.999999){φ=89.999999*Math.PI/180}
	const [sφ, cφ] = base.sincos(φ)
	const tφ = sφ / cφ
	const [sD, cD] = base.sincos(D)
	const [sz, cz] = base.sincos(z)
	const P = sφ * cz - cφ * sz * cD
	 
	const lines = []
	for (let i = 0; i < 24; i++) {
	  const l = new LigneHoraire(i)
	  const Hi = (i - 12) * 15 * Math.PI / 180
	 
	  let j=debut-1;
	  while (j!==fin) 
	  {
        j++
		if (j>TS.decSuns.length) {j=1}
		if (legal) {H=Correction(Hi,j)}else {H=Hi}
		const aH = Math.abs(H)
		const [sH, cH] = base.sincos(H)
		const tδ = Math.tan(TS.decSuns[j])

		const cosH0=-tφ * tδ
		let  H0 = Math.acos(cosH0)
		if (cosH0> 1){H0=-Math.PI}  //nuit polaire
		if (cosH0<=-1){H0= Math.PI}  //j0ur polaire

		if (aH <H0) { // sun above horizon
			const Q = sD * sz * sH + (cφ * cz + sφ * sz * cD) * cH + P * tδ
			if (Q > 0) { // sun above plane of sundial         
			const Nx = cD * sH - sD * (sφ * cH - cφ * tδ)
			const Ny = cz * sD * sH - (cφ * sz - sφ * cz * cD) * cH - (sφ * sz + cφ * cz * cD) * tδ
			xp=a * Nx / Q ; yp=a * Ny / Q
			if (pointDansCadran(xp+cs.xgnomon,yp+cs.ygnomon)) { l.points.push(new Point(xp,yp ));xm=xp+cs.xgnomon;ym=yp+cs.ygnomon }
		    }
		}
	  }
	  if (l.points.length > 0) {lines.push(l);
	                            EcrireTexte(i.toString(),xm,ym,material,group,listeMesh)
							   }
	}
	const center = new Point()
	center.x = a / P * cφ * sD
	center.y = -a / P * (sφ * sz + cφ * cz * cD)
	const aP = Math.abs(P)
	const u = a / aP
	const ψ = Math.asin(aP)
console.log (lines)
	return {
	  lines: lines,
	  center: center,
	  length: u,
	  angle: ψ
	}
  }

//           b := hstyle;
//           a := distance;
//           d := cosd * (sinPhi * cos(t) - cosPhi * tan(decl)) + sind * sin(t);
//           if d = 0 then
//           begin
//             Ombre := 1;
//             exit
//           end;
//           x3 := -a * (cosd * sin(t) - sind * (sinPhi * cos(t) - cosPhi *
//             tan(decl))) / d;
//           y3 := b * (cosPhi * cos(t) + sinPhi * tan(decl)) / d;
	  
function arcsDiurnes (φ, D, a, z,debut,fin,legal,group,material,listeMesh) { 
	// (φ, D, a, z float64)  (lines []LigneHoraire, center Point, u, ψ float64)
	let H,xp,yp,xm,ym,s;
	const listeDec= [-23.44,0,23.44]

	if (φ*180/Math.PI>89.999999){φ=89.999999*Math.PI/180}
	const [sφ, cφ] = base.sincos(φ)
	const tφ = sφ / cφ
	const [sD, cD] = base.sincos(D)
	const [sz, cz] = base.sincos(z)
	const P = sφ * cz - cφ * sz * cD
	 
	const lines = []
	
	for (const d of cs.datesArcsDiurnes)
	  {
	    const l = new LigneArc(d)       
		for (let i = 0; i < 24*60; i++) {
	    
	    const H = (i - 12*60)/60 * 15 * Math.PI / 180	
		const aH = Math.abs(H)
		const [sH, cH] = base.sincos(H)
	//	const tδ = Math.tan(TS.decSuns[j])
	    const tδ = Math.tan(d[1])
		const cosH0=-tφ * tδ
		let  H0 = Math.acos(cosH0)
		if (cosH0> 1){H0=-Math.PI}  //nuit polaire
		if (cosH0<=-1){H0= Math.PI}  //j0ur polaire

		if (aH <H0) { // sun above horizon
			const Q = sD * sz * sH + (cφ * cz + sφ * sz * cD) * cH + P * tδ
			if (Q > 0) { // sun above plane of sundial         
			const Nx = cD * sH - sD * (sφ * cH - cφ * tδ)
			const Ny = cz * sD * sH - (cφ * sz - sφ * cz * cD) * cH - (sφ * sz + cφ * cz * cD) * tδ
			xp=a * Nx / Q ; yp=a * Ny / Q
			if (pointDansCadran(xp+cs.xgnomon,yp+cs.ygnomon)) { l.points.push(new Point(xp,yp ));xm=xp+cs.xgnomon;ym=yp+cs.ygnomon }
		    }
		}
	  }
	  if (l.points.length > 0) {lines.push(l);
		                        // s=d[0]
								// if (d==0){s="e"}
								// if (Math.abs(d)==23.44){s="s"}
	                            // EcrireTexte(s,xm,ym,material,group,listeMesh)
							   }
	}
	const center = new Point()
	center.x = a / P * cφ * sD
	center.y = -a / P * (sφ * sz + cφ * cz * cD)
	const aP = Math.abs(P)
	const u = a / aP
	const ψ = Math.asin(aP)
console.log (lines) 
	return {
	  lines: lines,
	  center: center,
	  length: u,
	  angle: ψ
	}
  }
		  
//-----------------------------------------------------------------------------------------------------
function loadJsonFile() 
{
//  const content = document.querySelector('.content');
  const [file] = document.querySelector('input[type=file]').files;
//   const docinput = document.querySelector('input');
//   docinput.style.opacity = 0;
  
  const reader = new FileReader();
  reader.addEventListener("load", () => 
    {
    cs.export="?";
    cs=JSON.parse(reader.result); 
//   console.log(file);   
//     document.getElementById("fileinput").disabled = 'true';
//     button.innerHTML = "";
//     button.disabled=true;
    run();
    }, false);
  if (file) 
   {
    reader.readAsText(file);
   }
   
   return reader.result;
  

}		

//--------------------------------------------------------------------------------------------------------
			
            //function saveString
            //saveString('uih uihgb iuo huipo','Bidon.txt');
			const link = document.createElement( 'a' );
			link.style.display = 'none';
			document.body.appendChild( link ); // Firefox workaround, see #6594
			function save( blob, filename ) {
						link.href = URL.createObjectURL( blob );
						link.download = filename;
						link.click();}
			function saveString( text, filename ) {			       
               save( new Blob( [ text ], { type: 'text/plain' } ), filename );
			}
				
// ---------------------------------------------------------------------------------------------------
  function 	eulerCsGroup() 
  {
  	const a = new THREE.Euler( (cs.incli-90)/180*Math.PI, cs.decli/180*Math.PI,cs.rot/180*Math.PI, 'YXZ' );
	cadranSolaireGroup.setRotationFromEuler(a); 	
  }

// ---------------------------------------------------------------------------------------------------
  function 	eulerEarthGroup() 
  {
  	const a = new THREE.Euler( (cs.lati-90)/180*Math.PI, 0*Math.PI,-cs.longi/180*Math.PI, 'YZX' );
	earthGroup.setRotationFromEuler(a); 	
  }

//---------------------------------------------------------------------------------------------------------
function init() {
		

                //Effacement de toute la page d'introduction  

		document.getElementById("info").style.display = "none";		

				// dat.GUI ///////////////////////////////////////////////////////////////////////////////////////

	
        
		
		
	 	
const gui = new GUI( 
			{ width: Math.min(Math.round(window.innerWidth/2),245),title:"Edit sundial..." } 
			);
        const  sp=""  
gui.$title.style.color = 'yellow'


		gui.add( cs, "hsol", 0, 24, 0.01 )
                         .name("Hour  (1/100 h)")
                         .onChange(function(e){cs.hsol=e;PlacerLeSoleil()});
        gui.add( cs, "dayofYear", 1, 365, 1 )
                         .name("Day (1-365))")
                         .onChange(function(e){cs.dayofYear=e;PlacerLeSoleil()}); 
		gui.add(cs,"typeCadran",[SP,BF]).name("Sundial type")
		                 .onChange(function(e){
							 if (e==SP){folderGnomonClassic.show();
							        	ctlIncli.enable();
								        folderGnomonBifilaire.hide()};
							 if (e==BF){folderGnomonClassic.hide();
								        ctlIncli.setValue(90);
										cs.incli=90;
								        ctlIncli.disable();
								        folderGnomonBifilaire.show()};
						 }); ;
			
//// GEOLOCALISATION
const folderGeoSundial = gui.addFolder("Geolocation");  
			  folderGeoSundial.add(cs,"lati",-90,90,0.001) 
                    .name("Latitude")
                    .onChange(function(v){cs.lati=v;orienterAxedumonde();PlacerLaTerre() })
                    .onFinishChange(function(v){cs.lati=v;
                     orienterAxedumonde();
					 PlacerLaTerre();//eulerEarthGroup()
					 PlacerLeSoleil();TracerHeures()})
				    .listen();
              folderGeoSundial.add(cs,"longi",-180,180,0.001) 
                    .name("Longitude")
                    .onChange(function(v){cs.longi=v;PlacerLaTerre()
				  		cs.offset_sec=Math.trunc(cs.longi/15)*3600}) 
                    .onFinishChange(function(v){cs.longi=v;PlacerLaTerre();//eulerEarthGroup():
					                           TracerHeures()})
					.listen();
              folderGeoSundial.add(cs,"adresse") 
                    .name("Seek by adress")
                    .onFinishChange(function(v){
                   	  if (v.length>0){
                   	  	RechercheParAdresse(v);
                     	TracerHeures();
                     	orienterAxedumonde();
						PlacerLaTerre ();}  })  
					.listen();
              folderGeoSundial.add(cs,"timezone") 
                    .name("Time zone")
				    .listen();
              folderGeoSundial.add(cs,"offset_sec",-43200,43200,3600) 
                    .name("offset from UTC (sec)")
                    .onFinishChange(function(v){
                   	    cs.offset_sec=v;
						TracerHeures() })
				    .listen();
            //   folderGeoSundial.add(cs,"offset_string") 
            //        .name(" offset (HHMM)");
            //   folderGeoSundial.add(cs,"now_in_dst") 
            //        .name("summer time (H)");

 const FolderSundial = gui.addFolder( sp+'Geometry and colors' );

//// ORIENTATION				
	      	const folderOrientationSundial = FolderSundial.addFolder("Orientation...");     
				folderOrientationSundial.add( cs, "decli", -180, 180, 0.1 )
				   .name("Declinaison")
				   .onChange(function(v){cs.decli=v;eulerCsGroup()}) 
				   .onFinishChange(function(){TracerHeures() }); 
			const ctlIncli=	folderOrientationSundial.add( cs, "incli", -180, 180, 0.1 )
				   .name("Inclinaison")
				   .onChange(function(v){
				            	cs.incli=v;
					         eulerCsGroup() })
				   .onFinishChange(function(){TracerHeures()});
//                 folderOrientationSundial.add( cs, "rot", -180, 180, 0.1 )
//                    .name("Rotation")
//                    .onChange(function(v){
// 					cs.rot=v;
// 					eulerCsGroup() })
//                    .onFinishChange(function(){TracerHeures()});


//// DIMENTIONS
		      const folderDimensionsSundial = FolderSundial.addFolder("Dimensions...");  
				folderDimensionsSundial.add( cs, "largeur", 10, 1000,0.1 )
				  .name("Width")
				  .onChange(function(v){cs.largeur=v; 
				                        cadran.scale.x=cs.largeur;										
				                        meshDevise.position.x = -cs.largeur/2*0.9;
										})
				  .onFinishChange(function(){ TracerHeures() });				  
				folderDimensionsSundial.add( cs, "hauteur", 10, 1000, 0.1 )
				  .name("Height")
				  .onChange(function(v){cs.hauteur=v;cadran.scale.y=cs.hauteur;
				                        meshDevise.position.y = -cs.hauteur/2*0.9;
										// meshDevise.scale.y=cs.hauteur/400;
										// meshDevise.scale.x=cs.hauteur/400;
										// meshDevise.scale.z=cs.hauteur/400;
										PlacerLaTerre()})
				  .onFinishChange(function(){ TracerHeures() });				
				folderDimensionsSundial.add( cs, "epaisseur", 10, 1000, 0.1 )
				   .name("Depth")
				   .onChange(function(v){
					cs.epaisseur=v;
					cadran.scale.z=cs.epaisseur; 
					meshDevise.position.z = cs.epaisseur/2;					
					gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 })
				   .onFinishChange(function(){ TracerHeures() });    
				   
//// STYLE

const folderGnomon=FolderSundial.addFolder('Cast shadow by ...');
        const folderGnomonClassic=folderGnomon.addFolder('Straight or polar style...');
				folderGnomonClassic.add( cs, "hgnomon", 1, 1000, 0.1 )
				  .name("Length straight style")
				  .onChange( function (e) {
                    cs.hgnomon=e;
                    gnomon.scale.y=cs.hgnomon;
                    gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 })
                  .onFinishChange(function(){TracerHeures()});				
                folderGnomonClassic.add( cs, "vgnomon" )
				  .name("straight style visible")
				  .onChange( function (e ) {
				  	cs.vgnomon=e				    
				    gnomon.visible=e})
				folderGnomonClassic.add( cs, "vstyle" )
				  .name("polar style visible")
				  .onChange( function (e ) {
				  	cs.vstyle=e				    
				    stylePolaire.visible=e})
				folderGnomonClassic.add( cs, "vsousstyle" )
				  .name("under style visible")
				  .onChange( function (e ) {
				  	cs.vsousstyle=e				    
				    sousStylaire.visible=e})
		const folderGnomonBifilaire=folderGnomon.addFolder('Wires...');
		        folderGnomonBifilaire.add( cs, "hfilHorizontal", 1, 500, 0.1 )
				  .name("height horizontal wire ")
				  .onChange( function (e) {
                    cs.hfilHorizontal=e})
                    //gnomon.scale.y=cs.hgnomon;
                    //gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 })
                  .onFinishChange(function(){TracerHeures()});	
				folderGnomonBifilaire.add( cs, "hfilVertical", 1, 500, 0.1 )
				  .name("height vertical wire     ")
				  .onChange( function (e) {
                    cs.hfilVertical=e})
                    //gnomon.scale.y=cs.hgnomon;
                    //gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 })
                  .onFinishChange(function(){TracerHeures()});		
				   
		// if (cs.typeCadran==SP){
			
		// };
		// if (cs.typeCadran==BF){
			
		// }
				
		
		        folderGnomon.add( cs, "egnomon", 0.1, 5, 0.01 )
				  .name("Thickness")
				  .onChange( function (e) {
					cs.egnomon=e;
					gnomon.scale.x=cs.egnomon;
					gnomon.scale.z=cs.egnomon})
				  .onFinishChange(function(){TracerHeures()});				  
				folderGnomon.add( cs, "xgnomon", -1000, 1000, 0.1 )
				  .name(">")
				  .onChange( function (e) {
					cs.xgnomon=e;gnomon.visible=true;
					gnomon.position.x=cs.xgnomon})
				  .onFinishChange(function(){TracerHeures();gnomon.visible=cs.vgnomon});
				folderGnomon.add( cs, "ygnomon", -1000, 1000, 0.1 )
				  .name("^")
				  .onChange( function (e ) {
					cs.ygnomon=e;gnomon.position.y=cs.ygnomon;gnomon.visible=true;})
                  .onFinishChange(function(){TracerHeures();gnomon.visible=cs.vgnomon});


                       
 
 //// COLOR             
 const folderColorsSundial = FolderSundial.addFolder("Colors, opacity, wireframe ...");
				 	materialCS.color.setStyle(cs.colorCS); 
	                materialCS.emissive.setStyle(cs.emissiveCS); 
	                   //materialCS.specular.setStyle(cs.specularCS); 
	                materialCS.transparent=true;
	                materialCS.opacity=cs.opaciteCS;	              
              folderColorsSundial.addColor(cs, 'colorCS').name('reflection').onChange(function (e) {
                   materialCS.color = new THREE.Color(e);
                   cs.colorCS=materialCS.color.getStyle();
                   });           
              folderColorsSundial.addColor(cs, 'emissiveCS').name('emition').onChange(function (e) {
                   materialCS.emissive = new THREE.Color(e);
                   cs.emissiveCS=materialCS.emissive.getStyle();
                   });
//               folderColorsSundial.addColor(controlCS, 'specular').onChange(function (e) {
//                    materialCS.specular = new THREE.Color(e);
//                    cs.specularCS=materialCS.specular.getStyle();
//                    });
//              folderColorsSundial.add(materialCS, 'shininess', 0, 100, )              
              folderColorsSundial.add(cs,'opaciteCS',0,1,0.1)
                   .name('opacity').onChange(function(e)
                            {  materialCS.transparent=true;
              	               cs.opaciteCS=e;
                               materialCS.opacity=e }  );                      
              folderColorsSundial.add(materialCS, 'wireframe')
			                     .onChange(function(v){
									 materialGnomon.wireframe=v;
									 materialHeuresSolaires.wireframe=v;
									 materialHeuresLegalesSA.wireframe=v;
									 materialHeuresLegalesWS.wireframe=v;
									 materialArcsDiurnes.wireframe=v
								 });

                   
const FolderTime = gui.addFolder( sp+'Hour lines and diurnal arcs' );
const heures={}                 
///// HOURS   ☻♪♪♣ ☼◄►→
        materialHeuresSolaires.color.setStyle(cs.colorHS);     
		materialHeuresLegalesSA.color.setStyle(cs.colorHLSummerAutums);  
		materialHeuresLegalesWS.color.setStyle(cs.colorHLWinterSpring);
		const folderHours = FolderTime.addFolder( 'Hour...' ); 

			            folderHours.add(cs,'heuresSolaires')
			              .name('Solar (local true time) ')
			              .onChange( function  (e){
			            	cs.heuresSolaires=e;
			            	if (e) {TracerHeuresSolaires()}else{cadranSolaireGroup.remove(heuresSolairesGroup)}});			     
			            folderHours.addColor(cs, 'colorHS').name(' ')
			               .onChange(function (e) {
                           materialHeuresSolaires.color = new THREE.Color(e);
                           cs.colorHS=materialHeuresSolaires.color.getStyle()});	

			            folderHours.add(cs,'heuresLegalesSummerAutums')
			              .name ('Legal (Summer Autum)   ')
			              .onChange( function  (e){
			            	cs.heuresLegalesSummerAutums=e;
			            	if (e) {TracerHeuresLegalesSA()}else{cadranSolaireGroup.remove(heuresLegalesGroupSA)}});			     
			            folderHours.addColor(cs, 'colorHLSummerAutums')
						   .name(' ')
			               .onChange(function (e) {
                           materialHeuresLegalesSA.color = new THREE.Color(e);
                           cs.colorHLSummerAutums=materialHeuresLegalesSA.color.getStyle()});

			            folderHours.add(cs,'heuresLegalesWinterSpring')
			              .name('Legal (Winter Spring)   ')
			              .onChange( function  (e){
			            	cs.heuresLegalesWinterSpring=e;
			            	if (e) {TracerHeuresLegalesWS()}else{cadranSolaireGroup.remove(heuresLegalesGroupWS)}});			     
			            folderHours.addColor(cs, 'colorHLWinterSpring')
						   .name(" ")
			               .onChange(function (e) {
                           materialHeuresLegalesWS.color = new THREE.Color(e);
                           cs.colorHLWinterSpring=materialHeuresLegalesWS.color.getStyle()});
						folderHours.add(cs,'deviseSize',0,5,0.1).name('font size')
			              .onFinishChange(function(v){
			            	cs.hoursTextSize=v });

				
///// ARCS
        


        let dateArc={day:1,month:1,function1(){tracerArc()},function2(){effaceArcs()} };
		const folderArcs=   FolderTime.addFolder( 'Diurnials arcs...' ); 
		                const folderDate= folderArcs.addFolder('Date')
						  folderDate.add(dateArc,"month",1,12,1)
						            .onChange(function(v){dateArc.trace=false});
						  folderDate.add(dateArc,"day",1,31,1)
						            .onChange(function(v){dateArc.trace=false});
						  folderDate.add( dateArc, 'function1' )
						            .name("trace one arc");
						  folderDate.add( dateArc, 'function2' )
						            .name("delete all arcs");
				function tracerArc(){
					let j=0,s="";
					j = JULIAN.DayOfYearGregorian(cs.year,dateArc.month,dateArc.day)
					s=dateArc.day+'/'+dateArc.month
					cs.datesArcsDiurnes.push([s,TS.decSuns[j]])
					TracerArcsDiurnes()	
				}
				function effaceArcs(){
					cs.datesArcsDiurnes=cs.datesArcsDiurnes.filter(
					function(d){return((d[0]=='so.')||(d[0]=='eq.'))})	
					TracerArcsDiurnes()	
				}
						           
		folderArcs.add(cs,'equinoxeAndSolstices')
			.name('Equinoxe and solstices')
			.onChange(function(v){
				cs.equinoxeAndSolstices=v;
				if (v) {
					cs.datesArcsDiurnes.unshift(['so.',base.toRad(-23.44)])
					cs.datesArcsDiurnes.unshift(['so.',base.toRad( 23.44)])
					cs.datesArcsDiurnes.unshift(['eq.',0])
					}
					else{
						cs.datesArcsDiurnes=cs.datesArcsDiurnes.filter(function(d){
							return((d[0]!=='so.')&&(d[0]!=='eq.'))})
						}
						//cs.datesArcsDiurnes=[];
				TracerArcsDiurnes()
				//console.log(cs.datesArcsDiurnes)
				});

		materialArcsDiurnes.color.setStyle(cs.colorequinoxeAndSolstice);
        folderArcs.addColor(cs, 'colorequinoxeAndSolstice')
						   .name("color ")
			               .onChange(function (e) {
                           materialArcsDiurnes.color = new THREE.Color(e);
                           cs.colorequinoxeAndSolstice=materialArcsDiurnes.color.getStyle()});
						




///// Displays and animations

    const folderView = gui.addFolder( sp+'Displays and animations' );       

         folderView.add( cs,"vrotscene",0,10,1 )
                         .name('Rotation of the scene')  
						 .listen;

		 folderView.add(cs,"axesESZ").name("East,South,Zenith")
                            .onChange(function(e){cs.axesESZ=e;axesESZHelper.visible=e});	

         folderView.add(cs,"voirTerre").name("Earth")
                            .onChange(function(e){
                            	cs.voirTerre=e;PlacerLaTerre()});	

	    const Vsun={ "0":0,
				"1sec  /sec":1,
				"1min  /sec":60,
				"10min /sec":600,
				"20min /sec":1200,
				"30min /sec":1800,
				"1h    /sec":3600}    
		folderView.add( cs,"vrotSun", Vsun )
                         .name('Rotation of sun')
                         .onChange(function(e){RotationSoleil(e)});
		///// DEVISE
        const folderDevise=   folderView.addFolder( 'Motto ...' ); 
             folderDevise.add(cs,'devise').name('text')
			    .onFinishChange(function(v){
				cs.devise=v;
				cadranSolaireGroup.remove(meshDevise);
				EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9) });
				folderDevise.add(cs,'deviseSize',0.5,5,0.1).name('font size')
			    .onFinishChange(function(v){
				cs.deviseSize=v;
				cadranSolaireGroup.remove(meshDevise);
				EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9) });
								
            		
///// EXPORT
        const folderFiles = gui.addFolder( sp+'Downloads' ); 
                
                folderFiles.add(cs,"nameFile").name("File name").onChange( function  (e) {
                	cs.nameFile=e;
                	});
                folderFiles.add(cs,"export",
				["?","Sundial(JSON)","Spreadsheet(CSV)","3D(PLY)","3D(OBJ)","Ephemeris(CSV)"])
				    .name('Type of file')
					.onChange( function  (e)  {
                	if (e=="Sundial(JSON)") 
                               	  {saveString(JSON.stringify(cs,null,2),cs.nameFile+'.sundial.json')};
                    // if (e=="Scene(JSON)")
                	//               {saveString(JSON.stringify(cadranSolaireGroup.toJSON(),null,2),cs.nameFile+'.scene.json')};
                	if (e=="Spreadsheet(CSV)")
                	              {saveString(CSVtext,cs.nameFile+'.csv')};
				 	if (e=="Ephemeris(CSV)")
								  {Ephemerid(cs.year);saveString(CSVephemerid,cs.nameFile+'.ephemerid.csv')};
					if (e=="3D(PLY)"){saveString(GenererPLY(),cs.nameFile+".PLY")};
					if (e=="3D(OBJ)"){saveString(GenererOBJ(),cs.nameFile+".OBJ")
					};
					cs.export="?";
                	})
					.listen();
					         

              //generateGeometry;           

              geometryCS = new THREE.BoxGeometry(1,1,1);	
             
			  cadran = new THREE.Mesh( geometryCS, materialCS ); 
			  cadran.scale.x=cs.largeur; 
			  cadran.scale.y=cs.hauteur; 
			  cadran.scale.z=cs.epaisseur;
			  cadran.receiveShadow = true;


               const geometryGnomon = new THREE.CylinderGeometry( 1, 1, 1, 16 );
              
               gnomon = new THREE.Mesh( geometryGnomon, materialGnomon );  
               //cadran.add(gnomon);
               gnomon.position.x=cs.xgnomon; 
               gnomon.position.y=cs.ygnomon;
               gnomon.position.z=(cs.hgnomon+cs.epaisseur)/2 ; 
               gnomon.scale.y=cs.hgnomon;
               gnomon.scale.x=cs.egnomon;
			   gnomon.scale.z=cs.egnomon;
               gnomon.rotation.x = Math.PI*0.5;
               gnomon.castShadow = true; //default is false
	//		   folderGnomonClassic.show();folderGnomonBifilaire.hide()	
               
               
			   //	cadranSolaireGroup 
			   cadranSolaireGroup.add( cadran );
			   cadranSolaireGroup.add( gnomon );
			   //cadranSolaireGroup.add(meshDevise);
  
				
				//if (cs.heuresSolaires==true)  {TracerHeuresSolaires()};
				scene.add( cadranSolaireGroup );
				eulerCsGroup();
 
               PlacerLeSoleil();
		       PlacerLaTerre();
			   sphereEarth.rotation.y = -Math.PI*0.5;
              
 
               // helpers 
                const axesESZHelper = new THREE.AxesHelper( Math.max(cs.largeur,cs.hauteur,cs.epaisseur) );
                scene.add(axesESZHelper);
// 				const camHelper = new THREE.CameraHelper( light.shadow.camera );
//              scene.add(camHelper) 
               EcrireDevise(cs.devise,-cs.largeur/2*0.9,-cs.hauteur/2*0.9)

			   TracerHeures()
			   TracerArcsDiurnes()

			   const couleurMenu="#BB1100"
			   folderGeoSundial.$title.style.color =couleurMenu 
			   FolderSundial.$title.style.color =couleurMenu 
			   FolderTime.$title.style.color = couleurMenu
			   folderView.$title.style.color = couleurMenu
			   folderFiles.$title.style.color = couleurMenu

				FolderSundial.close()
				FolderTime.close()
				folderView.close()
				folderFiles.close()
		

   }//init

//  EXPORT---------------------------------------------------------------------------------

function GenererPLY(){
  const plyExporter = new PLYExporter();
  return plyExporter.parse(cadranSolaireGroup)
  
}

function GenererOBJ(){
  const objExporter = new OBJExporter();
  return objExporter.parse(cadranSolaireGroup)
  
}



//--------------------------------------------------------------------------------------------------------
function RechercheParAdresse(v){
//  adrAPIOpenStreet :=
//       'http://api.opencagedata.com/geocode/v1/json?key=a110b502b29f4de9a47d95bc3b6c5e98&q='
//       + adresse + '&limit=1';
//  OpenStreetURL: String = 'https://www.openstreetmap.org/#map=15/%s/%s';

           // Create an XMLHttpRequest object
             const xhttp = new XMLHttpRequest();

           // Define a callback function
             xhttp.onload = function() {
				  // Here you can use the Data
					 let myObj = JSON.parse(this.responseText);
					 //console.log(JSON.stringify(myObj,null,2));
					 if (myObj.total_results>0) {           
					  cs.adresse=myObj.results[0].formatted;          
					  cs.lati=myObj.results[0].geometry.lat;
					  cs.longi=myObj.results[0].geometry.lng;
					  cs.urlOpenStreet=myObj.results[0].annotations.OSM.url;
					  cs.timezone=myObj.results[0].annotations.timezone.name;
					  cs.offset_sec=myObj.results[0].annotations.timezone.offset_sec;
					  cs.offset_string=myObj.results[0].annotations.timezone.offset_string;
					  cs.now_in_dst=myObj.results[0].annotations.timezone.now_in_dst;
					  
// 					"timezone": {
//                       "name": "America/New_York",
//                       "now_in_dst": 0,
//                       "offset_sec": -18000,
//                       "offset_string": "-0500",
					window.open(cs.urlOpenStreet, "_blank", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
                      }else {alert('no result for '+v)}
               console.log(cs);

             }
          // Send a request
		  try {xhttp.open("GET", "https://api.opencagedata.com/geocode/v1/json?key=a110b502b29f4de9a47d95bc3b6c5e98&q="+ v + "&limit=1",false);
			 xhttp.send();
			  
		  } catch (error) {
			 alert('no connection') 
		  }
			 
           }

//-------------------------------------------------------------------------------------------------------------

function orienterAxedumonde() {
               
               axeMonde.setDirection( new THREE.Vector3( 0, Math.sin(cs.lati*Math.PI/180),
                                                           -Math.cos(cs.lati*Math.PI/180)));
               axeMonde.setLength(Math.max(cs.largeur,cs.hauteur,cs.epaisseur),30,10);
            //   helperLight.update()
            //   axeMonde.visible=cs.voirTerre;
			  
			   axeMonde.visible=false;

             
           }

//--------------------------------------------------------------------------------------
 function PlacerLeSoleil(){
           	   const k=2*Math.max(cs.largeur,cs.hauteur,cs.epaisseur);
			   const v3=new THREE.Vector3();
			   let h,min,sec,y,m,d,dec,eqt,date,sdate,hsol;

                h=Math.floor(cs.hsol);
				min=Math.floor((cs.hsol-h)*60); 
				sec=Math.floor((cs.hsol-h-min/60)*3600);
		        //console.log(cs.hsol,sec)
				h = (h < 10) ? "0" + h : h;
                min = (min < 10) ? "0" + min : min;
				sec = (sec < 10) ? "0" + sec: sec;

				date=JULIAN.JDToCalendarGregorian(TS.jdates[cs.dayofYear-1]);
				//jde= JULIAN.CalendarGregorianToJD(cs.year, date.month, date.day); 
				dec=base.toDeg(TS.decSuns[cs.dayofYear-1]);

				dec=Math.round(dec*1000)/1000;
				cs.decsol=dec;
				eqt=Math.round(SEXA.secFromHourAngle(TS.eqtimes[cs.dayofYear-1]));

				hsol=cs.hsol + eqt/3600 +(cs.longi/15 - cs.offset_sec/3600); //correction de l'heure
				d=Math.floor(date.day);m=date.month;y=date.month;
				d = (d < 10) ? "0" + d : d;
                m = (m < 10) ? "0" + m : m;
		        sdate=d+"/"+m+"/"+date.year;  //date JJ/MM/YYYY
				
	           sphereSun.position.z=k*Math.cos(base.toRad(cs.decsol))*Math.cos(base.toRad(-(hsol-12)*15));
			   sphereSun.position.x=k*Math.cos(base.toRad(cs.decsol))*Math.sin(base.toRad(-(hsol-12)*15));
			   sphereSun.position.y=k*Math.sin(base.toRad(cs.decsol));
	        
               sphereSun.getWorldPosition ( v3 );
			   light.position.set( v3.x,v3.y,v3.z ).normalize();
			   light.castShadow =(v3.y>0) 
		    
			   labelutc.innerHTML=h + ":" + min+':'+sec +"  "+sdate+ "  dec:"+dec.toFixed(3)+"°  eqt:"+eqt+'s';
                //  helperLight.update()
           }

function myTimerSun() {
            cs.hsol+=cs.vrotSun/360000;
			if (cs.hsol>24) {cs.hsol=0} ;
			PlacerLeSoleil()
		    }
let temporisation=null;	
function RotationSoleil(e){
	      window.clearInterval(temporisation);
		  if (e>0) { temporisation = window.setInterval(myTimerSun,10)}; //    1/100 sec
  		}

// Terre ---------------------------------------------------------------------------------------------------
function PlacerLaTerre( ){
	            let r,l;
			    r=cs.hauteur;
	            sphereEarth.scale.x=r;sphereEarth.scale.y=r;sphereEarth.scale.z=r;
                earthGroup.position.x=0;
			    earthGroup.position.y=-(cs.hauteur/2+r)*1.2;
			    earthGroup.position.z=0;
			    earthGroup.rotation.x = -base.toRad(90-cs.lati); 
			    earthGroup.rotation.y = -base.toRad(cs.longi);
                earthGroup.visible=cs.voirTerre;			    
			    axeTerre.setLength(r*1.5,r*1.5*0.1,r*1.5*0.02);
			    l=-earthGroup.position.y-r;
			    axeLocalisation.setLength(l,0.1*l,0.02*l)
			    axeLocalisation.visible=cs.voirTerre;

			//	console.log(renderer.info)
			
}
			
//---------------------------------------------------------------------------------------------------------

function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );

			}


function animate() {

				requestAnimationFrame( animate );
               
                if (cs.vrotscene>0){scene.rotation.y +=0.001*cs.vrotscene}else{scene.rotation.y=0};

				render();
				stats.update();

			}

			//

function render() {
				
				renderer.render( scene,camera );

			}
      
        </script>
</body>

</html>